This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: **/.env, repomix.config.json, **/repomix.config.json, repomix-base.prompt, **/repomix-base.prompt, repomix-output.xml, **/repomix-output.xml, **/.github, **/.vscode, .vscode, **/.gitignore, **/*.git, **/*.yml, cursor, .cursor, **/*.storybook, **/*.idea, **/public, **/node_modules, apps/debug, **/repomix.config.json, packages/headless-basics-starter-site/.prettierrc.json, **/babel.config.cjs, **/jest.config.cjs, apps/plugin/dist, **/tsconfig.tsbuildinfo, packages/headless-basics-starter-site/data-backup, **/*.css, **/merged_rules.prompt, **/repomix-base.prompt, **/merged_review.prompt, **/build_error_temp.prompt, **/merged_dev_error.prompt, **/3_component_rules.prompt, **/upsertDemoData.ts, LICENSE, packages/headless-basics-starter-site/.env.local.example, packages/headless-basics-starter-site/scripts, packages/headless-basics-starter-site/.next, packages/headless-basics-starter-site/.vscode, packages/headless-basics-starter-site/.git, packages/headless-basics-starter-site/node_modules, packages/headless-basics-starter-site/dist, packages/headless-basics-starter-site/package-lock.json, packages/headless-basics-starter-site/repomix-base.prompt, packages/headless-basics-starter-site/repomix-output.xml, packages/headless-basics-starter-site/next.config.mjs, packages/headless-basics-starter-site/README.md, packages/headless-basics-components/.next, packages/headless-basics-components/.git, packages/headless-basics-components/node_modules, packages/headless-basics-components/dist, packages/headless-basics-components/.github, packages/headless-basics-components/package-lock.json, packages/headless-basics-components/repomix-base.prompt, packages/headless-basics-components/repomix-output.xml, packages/headless-basics-components/src/mockup-data, packages/headless-basics-components/.idea, packages/headless-basics-components/custom.d.ts, packages/headless-basics-components/.storybook, packages/headless-basics-components/repomix, packages/headless-basics-components/src/icons, packages/headless-basics-components/.prettierrc.json, packages/headless-basics-data/.vscode, packages/headless-basics-data/node_modules, packages/headless-basics-data/dist, packages/headless-basics-data/readme.txt, packages/headless-basics-data/package-lock.json, packages/headless-basics-data/repomix-base.prompt, packages/headless-basics-data/repomix-output.xml, packages/headless-basics-data/README.md, packages/headless-basics-data/.git, packages/headless-basics-sanity-cms/.git, packages/headless-basics-sanity-cms/.sanity, packages/headless-basics-sanity-cms/repomix-output.xml, packages/headless-basics-sanity-cms/repomix.config.json, packages/headless-basics-sanity-cms/repomix-base.prompt, packages/headless-basics-sanity-cms/dist, packages/headless-basics-sanity-cms/package.json, packages/headless-basics-sanity-cms/sanity.config.ts, packages/Figma-Context-MCP, ai_knowledge/architecture-overview.prompt, ai_knowledge/temp/build_error_temp.prompt, ai_knowledge/2_page_data_builder.prompt, ai_knowledge/3_component_rules.prompt, ai_knowledge/alt/3a_component_rules_over.prompt, ai_knowledge/4_component_template_review.prompt, ai_knowledge/5_component_image_review.prompt, ai_knowledge/6_dev_server_error.prompt, packages/headless-basics-data/.npmrc, ai_knowledge/tree_structure.prompt, ai_knowledge/repo_reserve, **/.env, **/merged_rules.prompt, **/merged_review.prompt, **/build_error_temp.prompt, packages/headless-basics-components/src/components/sections/, packages/headless-basics-components/src/theme/deep-purple, packages/headless-basics-components/src/theme/default/structures, packages/headless-basics-components/src/components, packages/headless-basics-components/src/theme/corporate1/components/!(frame469)/**, packages/headless-basics-components/src/theme/default/components/!(__[template]|hero)/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

</additional_info>

</file_summary>

<directory_structure>
apps/
  plugin/
    plugin-src/
      code.ts
      tsconfig.json
    ui-src/
      App.tsx
      index.html
      main.tsx
      messaging.ts
    .eslintrc.js
    package.json
    postcss.config.js
    README.md
    tsconfig.json
    vite-env.d.ts
    vite.config.ts
packages/
  backend/
    src/
      altNodes/
        altNodeUtils.ts
        jsonNodeConversion.ts
        oldAltConversion.ts
      api/
        tailwindv4Api.ts
      common/
        retrieveUI/
          commonUI.ts
          convertToCode.ts
          retrieveColors.ts
        color.ts
        commonConversionWarnings.ts
        commonFormatAttributes.ts
        commonPadding.ts
        commonPosition.ts
        commonRadius.ts
        commonStroke.ts
        commonTextHeightSpacing.ts
        convertFontWeight.ts
        curry.ts
        exportAsyncProxy.ts
        images.ts
        indentString.ts
        lowercaseFirstLetter.ts
        nodeVisibility.ts
        nodeWidthHeight.ts
        numToAutoFixed.ts
        parentCoordinates.ts
        parseJSX.ts
        retrieveFill.ts
      flutter/
        builderImpl/
          flutterAutoLayout.ts
          flutterBlend.ts
          flutterBorder.ts
          flutterColor.ts
          flutterPadding.ts
          flutterShadow.ts
          flutterSize.ts
        flutterContainer.ts
        flutterDefaultBuilder.ts
        flutterMain.ts
        flutterTextBuilder.ts
      html/
        builderImpl/
          htmlAutoLayout.ts
          htmlBlend.ts
          htmlBorderRadius.ts
          htmlColor.ts
          htmlPadding.ts
          htmlShadow.ts
          htmlSize.ts
        htmlDefaultBuilder.ts
        htmlMain.ts
        htmlTextBuilder.ts
      nearest-color/
        nearestColor.ts
      swiftui/
        builderImpl/
          swiftuiBlend.ts
          swiftuiBorder.ts
          swiftuiColor.ts
          swiftuiEffects.ts
          swiftuiPadding.ts
          swiftuiParser.ts
          swiftuiSize.ts
          swiftuiTextWeight.ts
        swiftuiDefaultBuilder.ts
        swiftuiMain.ts
        swiftuiTextBuilder.ts
      tailwind/
        builderImpl/
          tailwindAutoLayout.ts
          tailwindBlend.ts
          tailwindBorder.ts
          tailwindColor.ts
          tailwindPadding.ts
          tailwindShadow.ts
          tailwindSize.ts
        conversionTables.ts
        tailwindConfig.ts
        tailwindDefaultBuilder.ts
        tailwindMain.ts
        tailwindTextBuilder.ts
      api_types.ts
      code.ts
      index.ts
      messaging.ts
    package.json
    tsconfig.json
  eslint-config-custom/
    index.js
    package.json
  plugin-ui/
    src/
      components/
        About.tsx
        CodePanel.tsx
        ColorsPanel.tsx
        CopyButton.tsx
        CustomPrefixInput.tsx
        EmptyState.tsx
        ExpandIcon.tsx
        FrameworkTabs.tsx
        GradientsPanel.tsx
        Loading.tsx
        Preview.tsx
        SelectableToggle.tsx
        SettingsGroup.tsx
        TailwindSettings.tsx
        WarningsPanel.tsx
      lib/
        utils.ts
      codegenPreferenceOptions.ts
      index.tsx
      PluginUI.tsx
    package.json
    tsconfig.json
  tsconfig/
    backend.json
    base.json
    nextjs.json
    package.json
    react-library.json
  types/
    src/
      index.ts
      types.ts
    package.json
    tsconfig.json
.eslintrc.js
.node-version
.prettierrc
manifest.json
package.json
pnpm-workspace.yaml
README.md
tsconfig.json
turbo.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/plugin/plugin-src/tsconfig.json">
{
  "extends": "tsconfig/base.json",
  "compilerOptions": {
    "typeRoots": ["../node_modules/@types", "../node_modules/@figma"]
  }
}
</file>

<file path="apps/plugin/ui-src/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Figma to Code</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>
</file>

<file path="apps/plugin/ui-src/messaging.ts">
import { Message, SettingWillChangeMessage, UIMessage } from "types";
if (!parent || !parent.postMessage) {
  throw new Error("parent.postMessage() is not defined");
}
const postMessage = (message: UIMessage, options?: WindowPostMessageOptions) =>
  parent.postMessage(message, options);
export const postUIMessage = (
  message: Message,
  options?: WindowPostMessageOptions,
) => postMessage({ pluginMessage: message }, options);
export const postUISettingsChangingMessage = <T>(
  key: string,
  value: T,
  options?: WindowPostMessageOptions,
) => {
  const message: SettingWillChangeMessage<T> = {
    type: "pluginSettingWillChange",
    key,
    value,
  };
  postUIMessage(message, options);
};
</file>

<file path="apps/plugin/.eslintrc.js">
module.exports = {
  root: true,
  extends: ["custom"],
};
</file>

<file path="apps/plugin/README.md">
# Getting Started

First, run the development server:

```bash
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `pages/index.js`. The page auto-updates as you edit the file.

[API routes](https://nextjs.org/docs/api-routes/introduction) can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/hello.js`.

The `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as [API routes](https://nextjs.org/docs/api-routes/introduction) instead of React pages.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn/foundations/about-nextjs) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_source=github.com&utm_medium=referral&utm_campaign=turborepo-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="apps/plugin/tsconfig.json">
{
  "extends": "tsconfig/base.json",
  "compilerOptions": {
    "target": "ES2021",
    "jsx": "react-jsx",
    "typeRoots": ["node_modules/@types", "node_modules/@figma"]
  }
}
</file>

<file path="apps/plugin/vite-env.d.ts">

</file>

<file path="apps/plugin/vite.config.ts">
import { defineConfig } from "vite";
import { viteSingleFile } from "vite-plugin-singlefile";
import react from "@vitejs/plugin-react-swc";
export default defineConfig({
  root: "./ui-src",
  plugins: [react(), viteSingleFile()],
  build: {
    target: "ES2017",
    assetsInlineLimit: 100000000,
    chunkSizeWarningLimit: 100000000,
    cssCodeSplit: false,
    outDir: "../dist",
    rollupOptions: {
      output: {},
    },
  },
});
</file>

<file path="packages/backend/src/api/tailwindv4Api.ts">
import { tailwindMain } from "../tailwind/tailwindMain";
import { Node } from "../api_types";
import { PluginSettings, Size } from "types";
interface MinimalSceneNode {
  id: string;
  name: string;
  type: string;
  width: number;
  height: number;
  x: number;
  y: number;
  rotation?: number;
  visible?: boolean;
  parent?: MinimalSceneNode | null;
  children?: MinimalSceneNode[];
  fills?: any[];
  strokes?: any[];
  effects?: any[];
  layoutMode?: "NONE" | "HORIZONTAL" | "VERTICAL";
  layoutWrap?: "NO_WRAP" | "WRAP";
  primaryAxisAlignItems?: "MIN" | "MAX" | "CENTER" | "SPACE_BETWEEN";
  counterAxisAlignItems?: "MIN" | "MAX" | "CENTER" | "BASELINE";
  itemSpacing?: number;
  paddingLeft?: number;
  paddingRight?: number;
  paddingTop?: number;
  paddingBottom?: number;
  layoutSizingHorizontal?: "FIXED" | "HUG" | "FILL";
  layoutSizingVertical?: "FIXED" | "HUG" | "FILL";
  isRelative?: boolean;
  clipsContent?: boolean;
}
function getDefaultTailwindSettings(): PluginSettings {
  return {
    framework: "Tailwind",
    showLayerNames: false,
    useOldPluginVersion2025: false,
    responsiveRoot: false,
    htmlGenerationMode: "html",
    tailwindGenerationMode: "html",
    baseFontSize: 16,
    useTailwind4: true,
    roundTailwindValues: true,
    roundTailwindColors: true,
    useColorVariables: false,
    customTailwindPrefix: "",
    embedImages: false,
    embedVectors: false,
    flutterGenerationMode: "snippet",
    swiftUIGenerationMode: "snippet"
  };
}
function parseNode(
  node: any,
  parent?: MinimalSceneNode | null
): MinimalSceneNode {
  const {
    id,
    name,
    type,
    absoluteBoundingBox,
    visible = true,
    layoutMode,
    primaryAxisAlignItems,
    counterAxisAlignItems,
    itemSpacing,
    paddingLeft,
    paddingRight,
    paddingTop,
    paddingBottom,
    clipsContent,
    layoutWrap,
    fills = [],
    strokes = [],
    effects = [],
    children
  } = node;
  let width = 0;
  let height = 0;
  let x = 0;
  let y = 0;
  if (absoluteBoundingBox) {
    width = absoluteBoundingBox.width || 0;
    height = absoluteBoundingBox.height || 0;
    x = absoluteBoundingBox.x || 0;
    y = absoluteBoundingBox.y || 0;
  }
  const minimal: MinimalSceneNode = {
    id,
    name,
    type,
    width,
    height,
    x,
    y,
    visible,
    fills,
    strokes,
    effects,
    parent: parent || null,
    layoutMode: layoutMode || "NONE",
    layoutWrap: layoutWrap || "NO_WRAP",
    primaryAxisAlignItems: primaryAxisAlignItems || "MIN",
    counterAxisAlignItems: counterAxisAlignItems || "MIN",
    itemSpacing: itemSpacing || 0,
    paddingLeft: paddingLeft || 0,
    paddingRight: paddingRight || 0,
    paddingTop: paddingTop || 0,
    paddingBottom: paddingBottom || 0,
    layoutSizingHorizontal: "FIXED",
    layoutSizingVertical: "FIXED",
    clipsContent: clipsContent || false,
    children: []
  };
  if (Array.isArray(children) && children.length > 0) {
    const parsedChildren: MinimalSceneNode[] = [];
    for (const c of children) {
      const childNode = parseNode(c, minimal);
      if (childNode.visible !== false) {
        parsedChildren.push(childNode);
      }
    }
    minimal.children = parsedChildren;
  } else {
    minimal.children = [];
  }
  return minimal;
}
export async function generateTailwindv4FromFigma(
  figmaApiKey: string,
  fileId: string,
  nodeIds: string
): Promise<string> {
  if (!figmaApiKey || !fileId || !nodeIds || nodeIds.length === 0) {
    throw new Error("Missing required parameters for generating Tailwind code.");
  }
  const baseUrl = `https://api.figma.com/v1/files/${fileId}/nodes`;
  const url = new URL(baseUrl);
  url.searchParams.append("ids", nodeIds);
  url.searchParams.append("geometry", "paths");
  const finalApiUrl = url.toString();
  console.log("[generateTailwindv4FromFigma] calling one", finalApiUrl);
  const response = await fetch(url.toString(), {
    method: "GET",
    headers: {
      "X-Figma-Token": figmaApiKey
    }
  });
  if (!response.ok) {
  console.log("[generateTailwindv4FromFigma] calling 2");
    throw new Error(
      `[185] Figma API responded with HTTP ${response.status} ${response.statusText}`
    );
  }
  const data = await response.json();
  if (!data.nodes) {
    console.log("[generateTailwindv4FromFigma] calling 3");
    throw new Error("No nodes found in Figma API response");
  }else{
    console.log(`[generateTailwindv4FromFigma][calling 3aa] data.nodes.length = ${data.nodes}`, data);
  }
  const convertedSceneNodes: MinimalSceneNode[] = [];
    console.log(`[generateTailwindv4FromFigma][calling 3a] nodeId ${nodeIds}`);
    const nodeIdFixed = nodeIds.replace("-", ":");
    const doc = data.nodes[nodeIdFixed]?.document;
    if (!doc) {
      console.log("[generateTailwindv4FromFigma][205] no doc found");
      return "";
    }
    const parsed = parseNode(doc, null);
    convertedSceneNodes.push(parsed);
  // }
  console.log(`[generateTailwindv4FromFigma][calling 4] convertedSceneNodes ${convertedSceneNodes.length}`);
  // pass them to tailwindMain with useTailwind4 = true
  const tailwindSettings = getDefaultTailwindSettings();
  // we transform each top-level node individually
  let finalCode = "";
  for (const topNode of convertedSceneNodes) {
    console.log("[generateTailwindv4FromFigma][calling 5] ");
    // tailwindMain expects an array of SceneNode-likes
    // We can try calling tailwindMain with [topNode] to produce code
    let codeFragment = "";
    try{
      codeFragment = await tailwindMain([topNode] as any, tailwindSettings);
    }catch(e){
      console.log("[generateTailwindv4FromFigma][225] exception", e);
    }
    console.log("[generateTailwindv4FromFigma][calling 5a] ");
    finalCode += codeFragment + "\n";
  }
  console.log("[generateTailwindv4FromFigma][calling 6] ");
  return finalCode.trim();
}
</file>

<file path="packages/backend/src/common/retrieveUI/commonUI.ts">
export const calculateContrastRatio = (color1: RGB, color2: RGB): number => {
  const color1luminance = luminance(color1);
  const color2luminance = luminance(color2);
  const contrast =
    color1luminance > color2luminance
      ? (color2luminance + 0.05) / (color1luminance + 0.05)
      : (color1luminance + 0.05) / (color2luminance + 0.05);
  return 1 / contrast;
};
function luminance(color: RGB) {
  const a = [color.r * 255, color.g * 255, color.b * 255].map((v) => {
    v /= 255;
    return v <= 0.03928 ? v / 12.92 : ((v + 0.055) / 1.055) ** 2.4;
  });
  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
}
export const deepFlatten = (arr: Array<SceneNode>): Array<SceneNode> => {
  let result: Array<SceneNode> = [];
  arr.forEach((d) => {
    if ("children" in d) {
      result.push(d);
      result = Object.assign(result, deepFlatten([...d.children]));
    } else {
      result.push(d);
    }
  });
  return result;
};
</file>

<file path="packages/backend/src/common/commonConversionWarnings.ts">
import { Warning } from "types";
export const warnings = new Set<Warning>();
export const addWarning = (warning: Warning) => {
  if (warnings.has(warning) === false) {
    console.warn(warning);
  }
  warnings.add(warning);
};
export const clearWarnings = () => warnings.clear();
</file>

<file path="packages/backend/src/common/commonPadding.ts">
import { PaddingType } from "types";
export const commonPadding = (
  node: InferredAutoLayoutResult,
): PaddingType | null => {
  if ("layoutMode" in node && node.layoutMode !== "NONE") {
    const paddingLeft = parseFloat((node.paddingLeft ?? 0).toFixed(2));
    const paddingRight = parseFloat((node.paddingRight ?? 0).toFixed(2));
    const paddingTop = parseFloat((node.paddingTop ?? 0).toFixed(2));
    const paddingBottom = parseFloat((node.paddingBottom ?? 0).toFixed(2));
    if (
      paddingLeft === paddingRight &&
      paddingLeft === paddingBottom &&
      paddingTop === paddingBottom
    ) {
      return { all: paddingLeft };
    } else if (paddingLeft === paddingRight && paddingTop === paddingBottom) {
      return {
        horizontal: paddingLeft,
        vertical: paddingTop,
      };
    } else {
      return {
        left: paddingLeft,
        right: paddingRight,
        top: paddingTop,
        bottom: paddingBottom,
      };
    }
  }
  return null;
};
</file>

<file path="packages/backend/src/common/commonStroke.ts">
import { BorderSide } from "types";
export const commonStroke = (
  node: SceneNode,
  divideBy: number = 1,
): BorderSide | null => {
  if (!("strokes" in node) || !node.strokes || node.strokes.length === 0) {
    return null;
  }
  if ("strokeTopWeight" in node) {
    if (
      node.strokeTopWeight === node.strokeBottomWeight &&
      node.strokeTopWeight === node.strokeLeftWeight &&
      node.strokeTopWeight === node.strokeRightWeight
    ) {
      return { all: node.strokeTopWeight / divideBy };
    }
    return {
      left: node.strokeLeftWeight / divideBy,
      top: node.strokeTopWeight / divideBy,
      right: node.strokeRightWeight / divideBy,
      bottom: node.strokeBottomWeight / divideBy,
    };
  } else if (node.strokeWeight !== figma.mixed && node.strokeWeight !== 0) {
    return { all: node.strokeWeight / divideBy };
  }
  return null;
};
</file>

<file path="packages/backend/src/common/commonTextHeightSpacing.ts">
export const commonLineHeight = (
  lineHeight: LineHeight,
  fontSize: number,
): number => {
  switch (lineHeight.unit) {
    case "AUTO":
      return 0;
    case "PIXELS":
      return lineHeight.value;
    case "PERCENT":
      return (fontSize * lineHeight.value) / 100;
  }
};
export const commonLetterSpacing = (
  letterSpacing: LetterSpacing,
  fontSize: number,
): number => {
  switch (letterSpacing.unit) {
    case "PIXELS":
      return letterSpacing.value;
    case "PERCENT":
      return (fontSize * letterSpacing.value) / 100;
  }
};
</file>

<file path="packages/backend/src/common/curry.ts">
export function curry<T extends (...args: any[]) => any>(
  fn: T,
  arity = fn.length,
): any {
  return function curried(...args: any[]): any {
    if (args.length >= arity) {
      return fn(...args);
    }
    return function (...moreArgs: any[]) {
      return curried(...args, ...moreArgs);
    };
  };
}
</file>

<file path="packages/backend/src/common/indentString.ts">
export const indentString = (str: string, indentLevel: number = 2): string => {
  const regex = /^(?!\s*$)/gm;
  return str.replace(regex, " ".repeat(indentLevel));
};
export const indentStringFlutter = (
  str: string,
  indentLevel: number = 2,
): string => {
  const regex = /^(?!\s*$)/gm;
  return str.replace(regex, " ".repeat(indentLevel));
};
</file>

<file path="packages/backend/src/common/nodeVisibility.ts">
export const getVisibleNodes = (nodes: readonly SceneNode[]) =>
  nodes.filter((d) => d.visible ?? true);
</file>

<file path="packages/backend/src/common/numToAutoFixed.ts">
import { indentStringFlutter } from "./indentString";
export const numberToFixedString = (num: number): string => {
  return num.toFixed(2).replace(/\.00$/, "");
};
export const roundToNearestDecimal = (decimal: number) => (n: number) =>
  Math.round(n * 10 ** decimal) / 10 ** decimal;
export const roundToNearestHundreth = roundToNearestDecimal(2);
export const printPropertyIfNotDefault = (
  propertyName: string,
  propertyValue: any,
  defaultProperty: any,
): string => {
  if (propertyValue === defaultProperty) {
    return "";
  }
  return `${propertyName}: ${propertyValue}`;
};
export const skipDefaultProperty = <T>(
  propertyValue: T,
  defaultProperty: T,
): T | string => {
  if (propertyValue === defaultProperty) {
    return "";
  }
  return propertyValue;
};
export const propertyIfNotDefault = (
  propertyValue: any,
  defaultProperty: any,
): string => {
  if (propertyValue === defaultProperty) {
    return "";
  }
  return propertyValue;
};
export const generateWidgetCode = (
  className: string,
  properties: Record<string, number | string | string[]>,
  positionedValues?: string[],
): string => {
  console.log("properties", properties);
  const propertiesArray = Object.entries(properties)
    .filter(([, value]) => {
      if (Array.isArray(value)) {
        return value.length > 0;
      }
      return value !== "";
    })
    .map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}: [\n${indentStringFlutter(value.join(",\n"))},\n],`;
      } else {
        return `${key}: ${
          typeof value === "number" ? numberToFixedString(value) : value
        },`;
      }
    });
  const positionedValuesString = (positionedValues || [])
    .map((value) => {
      return typeof value === "number" ? numberToFixedString(value) : value;
    })
    .join(", ");
  const compactPropertiesArray = propertiesArray.join(" ");
  if (compactPropertiesArray.length < 40 && !positionedValues) {
    return `${className}(${compactPropertiesArray.slice(0, -1)})`;
  }
  const joined = `${positionedValuesString}${
    positionedValuesString ? ",\n" : ""
  }${propertiesArray.join("\n")}`;
  return `${className}(\n${indentStringFlutter(joined.trim())}\n)`;
};
function escapeRegExp(string: string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
export const replaceAllUtil = (str: string, find: string, replace: string) =>
  str.replace(new RegExp(escapeRegExp(find), "g"), replace);
export function stringToClassName(name: string): string {
  const words = name.split(/[^a-zA-Z0-9]+/);
  const camelCaseWords = words.map((word, index) => {
    if (index === 0) {
      const cleanedWord = word.replace(/^[^a-zA-Z]+/g, "");
      return (
        cleanedWord.charAt(0).toUpperCase() + cleanedWord.slice(1).toLowerCase()
      );
    }
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
  });
  return camelCaseWords.join("");
}
</file>

<file path="packages/backend/src/common/parentCoordinates.ts">
export const parentCoordinates = (
  node: DimensionAndPositionMixin,
): [number, number] => {
  const parentX = "layoutMode" in node ? 0 : node.x;
  const parentY = "layoutMode" in node ? 0 : node.y;
  return [parentX, parentY];
};
</file>

<file path="packages/backend/src/common/parseJSX.ts">
import { numberToFixedString } from "./numToAutoFixed";
export const formatWithJSX = (
  property: string,
  isJsx: boolean,
  value: number | string,
): string => {
  const jsx_property = property
    .split("-")
    .map((d, i) => (i > 0 ? d.charAt(0).toUpperCase() + d.slice(1) : d))
    .join("");
  if (typeof value === "number") {
    if (isJsx) {
      return `${jsx_property}: ${numberToFixedString(value)}`;
    } else {
      return `${property}: ${numberToFixedString(value)}px`;
    }
  } else if (isJsx) {
    return `${jsx_property}: '${value}'`;
  } else {
    return `${property}: ${value}`;
  }
};
export const formatMultipleJSXArray = (
  styles: Record<string, string | number>,
  isJsx: boolean,
): string[] =>
  Object.entries(styles)
    .filter(([key, value]) => value !== "")
    .map(([key, value]) => formatWithJSX(key, isJsx, value));
export const formatMultipleJSX = (
  styles: Record<string, string | number | null>,
  isJsx: boolean,
): string =>
  Object.entries(styles)
    .filter(([key, value]) => value)
    .map(([key, value]) => formatWithJSX(key, isJsx, value!))
    .join(isJsx ? ", " : "; ");
</file>

<file path="packages/backend/src/flutter/builderImpl/flutterBorder.ts">
import { commonStroke } from "../../common/commonStroke";
import { getStrokeAlign } from "../flutterContainer";
import {
  generateWidgetCode,
  skipDefaultProperty,
} from "./../../common/numToAutoFixed";
import { flutterColorFromFills } from "./flutterColor";
export const flutterBorder = (node: SceneNode): string => {
  if (!("strokes" in node)) {
    return "";
  }
  const stroke = commonStroke(node);
  if (!stroke) {
    return "";
  }
  const color = skipDefaultProperty(
    flutterColorFromFills(node, "strokes"),
    "Colors.black",
  );
  const strokeAlign = skipDefaultProperty(
    getStrokeAlign(node, 2),
    "BorderSide.strokeAlignInside",
  );
  if ("all" in stroke) {
    if (stroke.all === 0) {
      return "";
    }
    return generateWidgetCode("Border.all", {
      width: stroke.all,
      strokeAlign: strokeAlign,
      color: color,
    });
  } else {
    return generateWidgetCode("Border.only", {
      left: generateBorderSideCode(stroke.left, strokeAlign, color),
      top: generateBorderSideCode(stroke.top, strokeAlign, color),
      right: generateBorderSideCode(stroke.right, strokeAlign, color),
      bottom: generateBorderSideCode(stroke.bottom, strokeAlign, color),
    });
  }
};
const generateBorderSideCode = (
  width: number,
  strokeAlign: string,
  color: string,
): string => {
  return generateWidgetCode("BorderSide", {
    width: skipDefaultProperty(width, 0),
    strokeAlign: strokeAlign,
    color: color,
  });
};
</file>

<file path="packages/backend/src/flutter/builderImpl/flutterPadding.ts">
import {
  generateWidgetCode,
  skipDefaultProperty,
  numberToFixedString,
} from "../../common/numToAutoFixed";
import { commonPadding } from "../../common/commonPadding";
export const flutterPadding = (node: InferredAutoLayoutResult): string => {
  if (!("layoutMode" in node)) {
    return "";
  }
  const padding = commonPadding(node);
  if (!padding) {
    return "";
  }
  if ("all" in padding) {
    return skipDefaultProperty(
      `const EdgeInsets.all(${numberToFixedString(padding.all)})`,
      "const EdgeInsets.all(0)",
    );
  }
  if ("horizontal" in padding) {
    return generateWidgetCode("const EdgeInsets.symmetric", {
      horizontal: skipDefaultProperty(
        numberToFixedString(padding.horizontal),
        "0",
      ),
      vertical: skipDefaultProperty(numberToFixedString(padding.vertical), "0"),
    });
  }
  return generateWidgetCode("const EdgeInsets.only", {
    top: skipDefaultProperty(numberToFixedString(padding.top), "0"),
    left: skipDefaultProperty(numberToFixedString(padding.left), "0"),
    right: skipDefaultProperty(numberToFixedString(padding.right), "0"),
    bottom: skipDefaultProperty(numberToFixedString(padding.bottom), "0"),
  });
};
</file>

<file path="packages/backend/src/flutter/builderImpl/flutterShadow.ts">
import { rgbTo8hex } from "../../common/color";
import {
  generateWidgetCode,
  numberToFixedString,
} from "../../common/numToAutoFixed";
import { indentStringFlutter } from "../../common/indentString";
export const flutterShadow = (node: SceneNode): string => {
  let propBoxShadow = "";
  if ("effects" in node && node.effects?.length > 0) {
    const visibleEffects: Array<Effect> = node.effects.filter((d) => d.visible);
    if (visibleEffects.length > 0) {
      let boxShadow = "";
      visibleEffects.forEach((effect: Effect) => {
        if (effect.type === "DROP_SHADOW") {
          boxShadow += generateWidgetCode("BoxShadow", {
            color: `Color(0x${rgbTo8hex(
              effect.color,
              effect.color.a,
            ).toUpperCase()})`,
            blurRadius: numberToFixedString(effect.radius),
            offset: `Offset(${numberToFixedString(effect.offset.x)}, ${numberToFixedString(
              effect.offset.y,
            )})`,
            spreadRadius: effect.spread
              ? numberToFixedString(effect.spread)
              : "0",
          });
        }
      });
      if (boxShadow) {
        propBoxShadow = `[\n${indentStringFlutter(boxShadow)}\n]`;
      }
    }
  }
  return propBoxShadow;
};
</file>

<file path="packages/backend/src/html/builderImpl/htmlPadding.ts">
import { commonPadding } from "../../common/commonPadding";
import { formatWithJSX } from "../../common/parseJSX";
export const htmlPadding = (
  node: InferredAutoLayoutResult,
  isJsx: boolean,
): string[] => {
  const padding = commonPadding(node);
  if (padding === null) {
    return [];
  }
  if ("all" in padding) {
    if (padding.all !== 0) {
      return [formatWithJSX("padding", isJsx, padding.all)];
    } else {
      return [];
    }
  }
  let comp: string[] = [];
  if ("horizontal" in padding) {
    if (padding.horizontal !== 0) {
      comp.push(formatWithJSX("padding-left", isJsx, padding.horizontal));
      comp.push(formatWithJSX("padding-right", isJsx, padding.horizontal));
    }
    if (padding.vertical !== 0) {
      comp.push(formatWithJSX("padding-top", isJsx, padding.vertical));
      comp.push(formatWithJSX("padding-bottom", isJsx, padding.vertical));
    }
    return comp;
  }
  if (padding.top !== 0) {
    comp.push(formatWithJSX("padding-top", isJsx, padding.top));
  }
  if (padding.bottom !== 0) {
    comp.push(formatWithJSX("padding-bottom", isJsx, padding.bottom));
  }
  if (padding.left !== 0) {
    comp.push(formatWithJSX("padding-left", isJsx, padding.left));
  }
  if (padding.right !== 0) {
    comp.push(formatWithJSX("padding-right", isJsx, padding.right));
  }
  return comp;
};
</file>

<file path="packages/backend/src/html/builderImpl/htmlShadow.ts">
import { htmlColor } from "./htmlColor";
export const htmlShadow = (node: BlendMixin): string => {
  if (node.effects && node.effects.length > 0) {
    const shadowEffects = node.effects.filter(
      (d) =>
        (d.type === "DROP_SHADOW" ||
          d.type === "INNER_SHADOW" ||
          d.type === "LAYER_BLUR") &&
        d.visible,
    );
    if (shadowEffects.length > 0) {
      const shadow = shadowEffects[0];
      let x = 0;
      let y = 0;
      let blur = 0;
      let spread = "";
      let inner = "";
      let color = "";
      if (shadow.type === "DROP_SHADOW" || shadow.type === "INNER_SHADOW") {
        x = shadow.offset.x;
        y = shadow.offset.y;
        blur = shadow.radius;
        spread = shadow.spread ? `${shadow.spread}px ` : "";
        inner = shadow.type === "INNER_SHADOW" ? " inset" : "";
        color = htmlColor(shadow.color, shadow.color.a);
      } else if (shadow.type === "LAYER_BLUR") {
        x = shadow.radius;
        y = shadow.radius;
        blur = shadow.radius;
      }
      return `${x}px ${y}px ${blur}px ${spread}${color}${inner}`;
    }
  }
  return "";
};
</file>

<file path="packages/backend/src/nearest-color/nearestColor.ts">
import { ColorSpec, RGB } from "types";
function nearestColor(needle: RGB | string, colors: Array<ColorSpec>): string {
  needle = parseColor(needle);
  let distanceSq;
  let minDistanceSq = Infinity;
  let rgb;
  let value: ColorSpec;
  for (let i = 0; i < colors.length; ++i) {
    rgb = colors[i].rgb;
    distanceSq =
      (needle.r - rgb.r) ** 2 +
      (needle.g - rgb.g) ** 2 +
      (needle.b - rgb.b) ** 2;
    if (distanceSq < minDistanceSq) {
      minDistanceSq = distanceSq;
      value = colors[i];
    }
  }
  return value.source;
}
function mapColors(colors: Array<string>): Array<ColorSpec> {
  return colors.map((color) => createColorSpec(color));
}
export const nearestColorFrom = (
  availableColors: Array<string>,
): ((hex: string | RGB) => string) => {
  const colors = mapColors(availableColors);
  return (hex: string | RGB) => nearestColor(hex, colors);
};
function parseColor(source: RGB | string): RGB {
  let red, green, blue;
  if (typeof source === "object") {
    return source;
  }
  let hexMatchArr = source.match(/^#?((?:[0-9a-f]{3}){1,2})$/i);
  if (hexMatchArr) {
    const hexMatch = hexMatchArr[1];
    if (hexMatch.length === 3) {
      hexMatchArr = [
        hexMatch.charAt(0) + hexMatch.charAt(0),
        hexMatch.charAt(1) + hexMatch.charAt(1),
        hexMatch.charAt(2) + hexMatch.charAt(2),
      ];
    } else {
      hexMatchArr = [
        hexMatch.substring(0, 2),
        hexMatch.substring(2, 4),
        hexMatch.substring(4, 6),
      ];
    }
    red = parseInt(hexMatchArr[0], 16);
    green = parseInt(hexMatchArr[1], 16);
    blue = parseInt(hexMatchArr[2], 16);
    return { r: red, g: green, b: blue };
  }
  throw Error(`"${source}" is not a valid color`);
}
function createColorSpec(input: string): ColorSpec {
  return {
    source: input,
    rgb: parseColor(input),
  };
}
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiBorder.ts">
import { commonStroke } from "./../../common/commonStroke";
import { getCommonRadius } from "../../common/commonRadius";
import { numberToFixedString } from "../../common/numToAutoFixed";
import { swiftUISolidColor } from "./swiftuiColor";
import { SwiftUIElement } from "./swiftuiParser";
import { SwiftUIModifier } from "types";
const swiftUIStroke = (node: SceneNode): number => {
  if (!("strokes" in node) || !node.strokes || node.strokes.length === 0) {
    return 0;
  }
  const stroke = commonStroke(node, 2);
  if (!stroke) {
    return 0;
  }
  if ("all" in stroke) {
    return stroke.all;
  }
  return Math.max(stroke.left, stroke.top, stroke.right, stroke.bottom);
};
export const swiftuiBorder = (node: SceneNode): string[] | null => {
  if (!("strokes" in node) || !node.strokes || node.strokes.length === 0) {
    return null;
  }
  const width = swiftUIStroke(node);
  const inset = strokeInset(node, width);
  if (!width) {
    return null;
  }
  return node.strokes
    .map((stroke) => {
      const strokeColor = swiftUISolidColor(stroke);
      const strokeModifier: SwiftUIModifier = [
        "stroke",
        `${strokeColor}, lineWidth: ${numberToFixedString(width)}`,
      ];
      if (strokeColor) {
        return new SwiftUIElement(getViewType(node))
          .addModifier(inset)
          .addModifier(strokeModifier)
          .toString();
      }
      return null;
    })
    .filter((d) => d !== null) as string[];
};
const getViewType = (node: SceneNode): string => {
  if (node.type === "ELLIPSE") {
    return "Ellipse()";
  }
  const corner = swiftuiCornerRadius(node);
  if (corner) {
    return `RoundedRectangle(cornerRadius: ${corner})`;
  } else {
    return "Rectangle()";
  }
};
const strokeInset = (
  node: MinimalStrokesMixin,
  width: number,
): [string, string | null] => {
  switch (node.strokeAlign) {
    case "INSIDE":
      return ["inset", `by: ${numberToFixedString(width)}`];
    case "OUTSIDE":
      return ["inset", `by: -${numberToFixedString(width)}`];
    case "CENTER":
      return ["inset", null];
  }
};
export const swiftuiCornerRadius = (node: SceneNode): string => {
  const radius = getCommonRadius(node);
  if ("all" in radius) {
    if (radius.all > 0) {
      return numberToFixedString(radius.all);
    } else {
      return "";
    }
  }
  // SwiftUI doesn't support individual corner radius, so get the largest one
  const maxBorder = Math.max(
    radius.topLeft,
    radius.topRight,
    radius.bottomLeft,
    radius.bottomRight,
  );
  if (maxBorder > 0) {
    return numberToFixedString(maxBorder);
  }
  return "";
};
/**
 * Produce a Rectangle with border radius.
 * The reason this was extracted into its own method is for reusability in [swiftuiBorder],
 * where a RoundedRectangle is needed again to be part of the overlay.
 *
 * @param node with cornerRadius and topLeftRadius properties.
 * @returns a string with RoundedRectangle, if node has a corner larger than zero; else "".
 */
export const swiftuiRoundedRectangle = (node: SceneNode): string => {
  const corner = swiftuiCornerRadius(node);
  if (corner) {
    return `RoundedRectangle(cornerRadius: ${corner})`;
  }
  return "";
};
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiEffects.ts">
import { numberToFixedString } from "../../common/numToAutoFixed";
import { SwiftUIModifier } from "types";
export const swiftuiShadow = (node: SceneNode): SwiftUIModifier | null => {
  if (!("effects" in node) || node.effects.length === 0) {
    return null;
  }
  const dropShadow: Array<DropShadowEffect> = node.effects.filter(
    (d): d is DropShadowEffect => d.type === "DROP_SHADOW" && d.visible,
  );
  if (dropShadow.length === 0) {
    return null;
  }
  const shadow = dropShadow[0];
  let comp: string[] = [];
  const color = shadow.color;
  const a = numberToFixedString(color.a);
  const r = numberToFixedString(color.r);
  const g = numberToFixedString(color.g);
  const b = numberToFixedString(color.b);
  comp.push(`color: Color(red: ${r}, green: ${g}, blue: ${b}, opacity: ${a})`);
  comp.push(`radius: ${numberToFixedString(shadow.radius)}`);
  const x =
    shadow.offset.x > 0 ? `x: ${numberToFixedString(shadow.offset.x)}` : "";
  const y =
    shadow.offset.y > 0 ? `y: ${numberToFixedString(shadow.offset.y)}` : "";
  // add initial comma since this is an optional paramater and radius must come first.
  if (x && y) {
    comp.push(x, y);
  } else {
    if (x) {
      comp.push(x);
    } else if (y) {
      comp.push(y);
    }
  }
  return ["shadow", comp.join(", ")];
};
export const swiftuiBlur = (node: SceneNode): SwiftUIModifier | null => {
  if (!("effects" in node) || node.effects.length === 0) {
    return null;
  }
  const layerBlur: Array<BlurEffect> = node.effects.filter(
    (d): d is BlurEffect => d.type === "LAYER_BLUR" && d.visible,
  );
  if (layerBlur.length === 0) {
    return null;
  }
  const blur = layerBlur[0].radius;
  return ["blur", `radius: ${numberToFixedString(blur)})`];
};
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiPadding.ts">
import { numberToFixedString } from "../../common/numToAutoFixed";
import { commonPadding } from "../../common/commonPadding";
import { SwiftUIModifier } from "types";
export const swiftuiPadding = (
  node: InferredAutoLayoutResult,
): SwiftUIModifier | null => {
  if (!("layoutMode" in node)) {
    return null;
  }
  const padding = commonPadding(node);
  if (!padding) {
    return null;
  }
  if ("all" in padding) {
    if (padding.all === 0) {
      return null;
    }
    return ["padding", numberToFixedString(padding.all)];
  }
  if ("horizontal" in padding) {
    const vertical = numberToFixedString(padding.vertical);
    const horizontal = numberToFixedString(padding.horizontal);
    return [
      "padding",
      `EdgeInsets(top: ${vertical}, leading: ${horizontal}, bottom: ${vertical}, trailing: ${horizontal})`,
    ];
  }
  const top = numberToFixedString(padding.top);
  const left = numberToFixedString(padding.left);
  const bottom = numberToFixedString(padding.bottom);
  const right = numberToFixedString(padding.right);
  return [
    "padding",
    `EdgeInsets(top: ${top}, leading: ${left}, bottom: ${bottom}, trailing: ${right})`,
  ];
};
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiParser.ts">
import { indentString } from "../../common/indentString";
import { SwiftUIModifier } from "types";
export class SwiftUIElement {
  private readonly element: string;
  private readonly modifiers: SwiftUIModifier[];
  constructor(element: string = "", modifiers: SwiftUIModifier[] = []) {
    this.element = element;
    this.modifiers = modifiers;
  }
  addModifierMixed(
    property: string,
    value: string | SwiftUIModifier | SwiftUIModifier[],
  ): this {
    this.modifiers.push([property, value]);
    return this;
  }
  addModifier(
    modifier: SwiftUIModifier | [string | null, string | null],
  ): this {
    if (modifier && modifier[0] !== null && modifier[1] !== null) {
      this.modifiers.push([modifier[0], modifier[1]]);
    }
    return this;
  }
  addChildElement(
    element: string,
    ...modifiers: SwiftUIModifier[]
  ): SwiftUIElement {
    const childModifiers = modifiers.length === 1 ? modifiers[0] : modifiers;
    return this.addModifierMixed(element, childModifiers as SwiftUIModifier);
  }
  private buildModifierLines(indentLevel: number): string {
    const indent = " ".repeat(indentLevel);
    return this.modifiers
      .map(([property, value]) =>
        Array.isArray(value)
          ? `${indent}.${property}(${new SwiftUIElement(
              property,
              value as SwiftUIModifier[],
            )
              .toString()
              .trim()})`
          : value.length > 60
            ? `${indent}.${property}(\n${indentString(
                value,
                indentLevel + 2,
              )}\n${indent})`
            : `${indent}.${property}(${value})`,
      )
      .join("\n");
  }
  toString(indentLevel = 0): string {
    if (this.modifiers.length === 0) {
      return this.element;
    }
    const modifierLines = this.buildModifierLines(indentLevel + 2);
    return indentString(`${this.element}\n${modifierLines}`, 0);
  }
}
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiTextWeight.ts">
export const swiftuiFontMatcher = (node: TextNode): string => {
  if (node.fontSize === figma.mixed) {
    return "";
  }
  if (node.fontSize <= 11) {
    return ".caption2";
  } else if (node.fontSize <= 12) {
    return ".caption";
  } else if (node.fontSize <= 13) {
    return ".footnote";
  } else if (node.fontSize <= 15) {
    return ".subheadline";
  } else if (node.fontSize <= 16) {
    return ".callout";
  } else if (node.fontSize <= 17) {
    return ".body";
  } else if (node.fontSize <= 20) {
    return ".title3";
  } else if (node.fontSize <= 22) {
    return ".title2";
  } else if (node.fontSize <= 28) {
    return ".title";
  } else {
    return ".largeTitle";
  }
};
export const swiftuiWeightMatcher = (weight: number): string => {
  switch (weight) {
    case 100:
      return ".ultraLight";
    case 200:
      return ".thin";
    case 300:
      return ".light";
    case 400:
      return ".regular";
    case 500:
      return ".medium";
    case 600:
      return ".semibold";
    case 700:
      return ".bold";
    case 800:
      return ".heavy";
    case 900:
      return ".black";
    default:
      return "";
  }
};
</file>

<file path="packages/backend/src/tailwind/builderImpl/tailwindPadding.ts">
import { pxToLayoutSize } from "../conversionTables";
import { commonPadding } from "../../common/commonPadding";
export const tailwindPadding = (node: InferredAutoLayoutResult): string[] => {
  const padding = commonPadding(node);
  if (!padding) {
    return [];
  }
  if ("all" in padding) {
    if (padding.all === 0) {
      return [];
    }
    return [`p-${pxToLayoutSize(padding.all)}`];
  }
  let comp: string[] = [];
  if ("horizontal" in padding) {
    if (padding.horizontal && padding.horizontal !== 0) {
      comp.push(`px-${pxToLayoutSize(padding.horizontal)}`);
    }
    if (padding.vertical && padding.vertical !== 0) {
      comp.push(`py-${pxToLayoutSize(padding.vertical)}`);
    }
    return comp;
  }
  const { left, right, top, bottom } = padding;
  if (left || right) {
    const pl = left ? `pl-${pxToLayoutSize(left)}` : "";
    const pr = right ? `pr-${pxToLayoutSize(right)}` : "";
    comp.push(
      ...(left && right && pxToLayoutSize(left) === pxToLayoutSize(right)
        ? [`px-${pxToLayoutSize(left)}`]
        : [pl, pr]),
    );
  }
  if (top || bottom) {
    const pt = top ? `pt-${pxToLayoutSize(top)}` : "";
    const pb = bottom ? `pb-${pxToLayoutSize(bottom)}` : "";
    comp.push(
      ...(top && bottom && pxToLayoutSize(top) === pxToLayoutSize(bottom)
        ? [`py-${pxToLayoutSize(top)}`]
        : [pt, pb]),
    );
  }
  return comp;
};
</file>

<file path="packages/backend/src/messaging.ts">
import {
  ConversionMessage,
  ConversionStartMessage,
  EmptyMessage,
  ErrorMessage,
  PluginSettings,
  SettingsChangedMessage,
} from "types";
function getPostMessageFunction() {
  if (typeof figma !== "undefined" && figma.ui && figma.ui.postMessage) {
    return figma.ui.postMessage.bind(figma.ui);
  } else {
    console.warn("figma.ui.postMessage is not available; using fallback stub");
    return (message: any, options?: WindowPostMessageOptions) => {
      console.log("postBackendMessage fallback:", message, options);
    };
  }
}
export const postBackendMessage = getPostMessageFunction();
export const postEmptyMessage = () =>
  postBackendMessage({ type: "empty" } as EmptyMessage);
export const postConversionStart = () =>
  postBackendMessage({ type: "conversionStart" } as ConversionStartMessage);
export const postConversionComplete = (
  conversionData: ConversionMessage | Omit<ConversionMessage, "type">
) => postBackendMessage({ ...conversionData, type: "code" });
export const postError = (error: string) =>
  postBackendMessage({ type: "error", error } as ErrorMessage);
export const postSettingsChanged = (settings: PluginSettings) =>
  postBackendMessage({
    type: "pluginSettingsChanged",
    settings,
  } as SettingsChangedMessage);
</file>

<file path="packages/backend/tsconfig.json">
{
  "extends": "tsconfig/base.json",
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./node_modules/@figma"]
  }
}
</file>

<file path="packages/eslint-config-custom/index.js">
module.exports = {
  extends: ["next", "turbo", "prettier"],
  rules: {
    "@next/next/no-html-link-for-pages": "off",
  },
  parserOptions: {
    babelOptions: {
      presets: [require.resolve("next/babel")],
    },
  },
};
</file>

<file path="packages/plugin-ui/src/index.tsx">
export * from "./PluginUI";
</file>

<file path="packages/tsconfig/backend.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Backend",
  "extends": "./base.json",
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./node_modules/@figma"]
  },
  "exclude": ["node_modules"]
}
</file>

<file path="packages/tsconfig/base.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    "target": "ESNext",
    "composite": false,
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "inlineSources": false,
    "isolatedModules": true,
    "moduleResolution": "node",
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "preserveWatchOutput": true,
    "skipLibCheck": true,
    "strict": true,
    "typeRoots": ["./node_modules/@types", "./node_modules/@figma"]
  },
  "exclude": ["node_modules"]
}
</file>

<file path="packages/tsconfig/nextjs.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Next.js",
  "extends": "./base.json",
  "compilerOptions": {
    "allowJs": true,
    "declaration": false,
    "declarationMap": false,
    "incremental": true,
    "jsx": "preserve",
    "lib": ["dom", "dom.iterable", "esnext"],
    "module": "esnext",
    "noEmit": true,
    "resolveJsonModule": true,
    "strict": false,
    "target": "ES2017"
  },
  "include": ["src", "next-env.d.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="packages/tsconfig/package.json">
{
  "name": "tsconfig",
  "version": "0.0.0",
  "private": true,
  "license": "MIT",
  "publishConfig": {
    "access": "public"
  }
}
</file>

<file path="packages/tsconfig/react-library.json">
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "React Library",
  "extends": "./base.json",
  "compilerOptions": {
    "jsx": "react-jsx",
    "module": "ESNext"
  }
}
</file>

<file path="packages/types/src/index.ts">
export * from "./types";
</file>

<file path="packages/types/tsconfig.json">
{
  "extends": "tsconfig/base.json",
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./node_modules/@figma"]
  }
}
</file>

<file path=".eslintrc.js">
const config = {
  extends: ["kentcdodds"],
  rules: {
    "valid-jsdoc": "off",
    "max-len": "off",
    "no-negated-condition": "off",
    complexity: "off",
    "default-case": "off",
    "no-use-before-define": "off",
    "@typescript-eslint/no-use-before-define": "off",
    "@typescript-eslint/no-unnecessary-condition": "off",
    "space-before-function-paren": [
      "error",
      {
        anonymous: "never",
        named: "never",
        asyncArrow: "always",
      },
    ],
    "import/no-import-module-exports": "off",
  },
};
module.exports = config;
</file>

<file path=".node-version">
v22.12.0
</file>

<file path=".prettierrc">
{}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - "apps/*"
  - "packages/*"
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./packages/types" },
    { "path": "./packages/backend" },
    { "path": "./packages/plugin-ui" },
    { "path": "./apps/plugin" },
    { "path": "./apps/debug" }
  ],
  "exclude": ["./../node_modules"]
}
</file>

<file path="turbo.json">
{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "outputs": [".next/**", "!.next/cache/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "lint": {
      "outputs": [],
      "dependsOn": ["^build"],
      "inputs": ["src/**/*.tsx", "src/**/*.ts", "test/**/*.ts", "test/**/*.tsx", ".eslintrc.js"]
    },
    "type-check": {}
  }
}
</file>

<file path="apps/plugin/ui-src/main.tsx">
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";
ReactDOM.createRoot(document.getElementById("root")!).render(<App />);
</file>

<file path="apps/plugin/postcss.config.js">
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};
</file>

<file path="packages/backend/src/altNodes/oldAltConversion.ts">
import { StyledTextSegmentSubset, ParentNode, AltNode } from "types";
import {
  assignParent,
  isNotEmpty,
  assignRectangleType,
  assignChildren,
} from "./altNodeUtils";
import { curry } from "../common/curry";
export const isTypeOrGroupOfTypes = curry(
  (matchTypes: NodeType[], node: SceneNode): boolean => {
    if (node.visible === false || matchTypes.includes(node.type)) return true;
    if ("children" in node) {
      for (let i = 0; i < node.children.length; i++) {
        const childNode = node.children[i];
        const result = isTypeOrGroupOfTypes(matchTypes, childNode);
        if (result) continue;
        return false;
      }
      return true;
    }
    return false;
  },
);
export let globalTextStyleSegments: Record<string, StyledTextSegmentSubset[]> =
  {};
const canBeFlattened = isTypeOrGroupOfTypes([
  "VECTOR",
  "STAR",
  "POLYGON",
  "BOOLEAN_OPERATION",
]);
export const convertNodeToAltNode =
  (parent: ParentNode | null) =>
  (node: SceneNode): SceneNode => {
    const type = node.type;
    switch (type) {
      case "RECTANGLE":
      case "ELLIPSE":
      case "LINE":
      case "STAR":
      case "POLYGON":
      case "VECTOR":
      case "BOOLEAN_OPERATION":
        return cloneNode(node, parent);
      case "FRAME":
      case "INSTANCE":
      case "COMPONENT":
      case "COMPONENT_SET":
        if (node.children.length === 0)
          return cloneAsRectangleNode(node, parent);
      case "GROUP":
        if (type === "GROUP" && node.children.length === 1 && node.visible)
          return convertNodeToAltNode(parent)(node.children[0]);
      case "SECTION":
        const group = cloneNode(node, parent);
        const groupChildren = oldConvertNodesToAltNodes(node.children, group);
        return assignChildren(groupChildren, group);
      case "TEXT":
        globalTextStyleSegments[node.id] = extractStyledTextSegments(node);
        return cloneNode(node, parent);
      case "SLICE":
        throw new Error(
          `Sorry, Slices are not supported. Type:${node.type} id:${node.id}`,
        );
      default:
        throw new Error(
          `Sorry, an unsupported node type was selected. Type:${node.type} id:${node.id}`,
        );
    }
  };
export const oldConvertNodesToAltNodes = (
  sceneNode: ReadonlyArray<SceneNode>,
  parent: ParentNode | null,
): Array<SceneNode> =>
  sceneNode.map(convertNodeToAltNode(parent)).filter(isNotEmpty);
export const cloneNode = <T extends BaseNode>(
  node: T,
  parent: ParentNode | null,
): T => {
  const cloned = {} as T;
  for (const prop in node) {
    if (
      prop !== "parent" &&
      prop !== "children" &&
      prop !== "horizontalPadding" &&
      prop !== "verticalPadding" &&
      prop !== "mainComponent" &&
      prop !== "masterComponent" &&
      prop !== "variantProperties" &&
      prop !== "get_annotations" &&
      prop !== "componentPropertyDefinitions" &&
      prop !== "exposedInstances" &&
      prop !== "instances" &&
      prop !== "componentProperties" &&
      prop !== "componenPropertyReferences" &&
      prop !== "constrainProportions"
    ) {
      cloned[prop as keyof T] = node[prop as keyof T];
    }
  }
  assignParent(parent, cloned);
  const altNode = {
    ...cloned,
    parent: cloned.parent,
    originalNode: node,
    canBeFlattened: canBeFlattened(node),
  } as AltNode<T>;
  if (globalTextStyleSegments[node.id]) {
    altNode.styledTextSegments = globalTextStyleSegments[node.id];
  }
  console.log("altnode:", altNode.parent, cloned.parent);
  return altNode;
};
const cloneAsRectangleNode = <T extends BaseNode>(
  node: T,
  parent: ParentNode | null,
): RectangleNode => {
  const clonedNode = cloneNode(node, parent);
  assignRectangleType(clonedNode);
  return clonedNode as unknown as RectangleNode;
};
const extractStyledTextSegments = (node: TextNode) =>
  node.getStyledTextSegments([
    "fontName",
    "fills",
    "fontSize",
    "fontWeight",
    "hyperlink",
    "indentation",
    "letterSpacing",
    "lineHeight",
    "listOptions",
    "textCase",
    "textDecoration",
    "textStyleId",
    "fillStyleId",
    "openTypeFeatures",
  ]);
</file>

<file path="packages/backend/src/common/retrieveUI/convertToCode.ts">
import { PluginSettings } from "types";
import { flutterMain } from "../../flutter/flutterMain";
import { htmlMain } from "../../html/htmlMain";
import { swiftuiMain } from "../../swiftui/swiftuiMain";
import { tailwindMain } from "../../tailwind/tailwindMain";
export const convertToCode = async (
  nodes: SceneNode[],
  settings: PluginSettings,
) => {
  switch (settings.framework) {
    case "Tailwind":
      return await tailwindMain(nodes, settings);
    case "Flutter":
      return await flutterMain(nodes, settings);
    case "SwiftUI":
      return await swiftuiMain(nodes, settings);
    case "HTML":
    default:
      return (await htmlMain(nodes, settings)).html;
  }
};
</file>

<file path="packages/backend/src/common/commonRadius.ts">
import { CornerRadius } from "types";
export const getCommonRadius = (node: SceneNode): CornerRadius => {
  if ("rectangleCornerRadii" in node) {
    const [topLeft, topRight, bottomRight, bottomLeft] =
      node.rectangleCornerRadii as any;
    if (
      topLeft === topRight &&
      topLeft === bottomRight &&
      topLeft === bottomLeft
    ) {
      return { all: topLeft };
    }
    return {
      topLeft,
      topRight,
      bottomRight,
      bottomLeft,
    };
  }
  if (
    "cornerRadius" in node &&
    node.cornerRadius !== figma.mixed &&
    node.cornerRadius
  ) {
    return { all: node.cornerRadius };
  }
  if ("topLeftRadius" in node) {
    if (
      node.topLeftRadius === node.topRightRadius &&
      node.topLeftRadius === node.bottomRightRadius &&
      node.topLeftRadius === node.bottomLeftRadius
    ) {
      return { all: node.topLeftRadius };
    }
    return {
      topLeft: node.topLeftRadius,
      topRight: node.topRightRadius,
      bottomRight: node.bottomRightRadius,
      bottomLeft: node.bottomLeftRadius,
    };
  }
  return { all: 0 };
};
</file>

<file path="packages/backend/src/common/convertFontWeight.ts">
import { FontWeightNumber } from "types";
export const convertFontWeight = (weight: string): FontWeightNumber | null => {
  weight = weight.replaceAll(" ", "").replaceAll("-", "").toLowerCase();
  switch (weight) {
    case "thin":
      return "100";
    case "extralight":
      return "200";
    case "light":
      return "300";
    case "regular":
      return "400";
    case "medium":
      return "500";
    case "semibold":
      return "600";
    case "bold":
      return "700";
    case "extrabold":
      return "800";
    case "heavy":
      return "800";
    case "black":
      return "900";
    default:
      return "400";
  }
};
</file>

<file path="packages/backend/src/common/images.ts">
import { AltNode, ExportableNode } from "types";
import { btoa } from "js-base64";
import { addWarning } from "./commonConversionWarnings";
import { exportAsyncProxy } from "./exportAsyncProxy";
export const PLACEHOLDER_IMAGE_DOMAIN = "https://placehold.co";
export const getPlaceholderImage = (w: number, h = -1) => {
  const _w = w.toFixed(0);
  const _h = (h < 0 ? w : h).toFixed(0);
  return `${PLACEHOLDER_IMAGE_DOMAIN}/${_w}x${_h}`;
};
const fillIsImage = ({ type }: Paint) => type === "IMAGE";
export const getImageFills = (node: MinimalFillsMixin): ImagePaint[] => {
  try {
    return (node.fills as ImagePaint[]).filter(fillIsImage);
  } catch (e) {
    return [];
  }
};
export const nodeHasImageFill = (node: MinimalFillsMixin): Boolean =>
  getImageFills(node).length > 0;
export const nodeHasMultipleFills = (node: MinimalFillsMixin) =>
  node.fills instanceof Array && node.fills.length > 1;
const imageBytesToBase64 = (bytes: Uint8Array): string => {
  const binaryString = bytes.reduce((data, byte) => {
    return data + String.fromCharCode(byte);
  }, "");
  // Encode binary string to base64
  const b64 = btoa(binaryString);
  return `data:image/png;base64,${b64}`;
};
export const exportNodeAsBase64PNG = async <T extends ExportableNode>(
  node: AltNode<T>,
  excludeChildren: boolean,
) => {
  // Shorcut export if the node has already been converted.
  if (node.base64 !== undefined && node.base64 !== "") {
    return node.base64;
  }
  const n: ExportableNode = node;
  const temporarilyHideChildren =
    excludeChildren && "children" in n && n.children.length > 0;
  const parent = n as ChildrenMixin;
  const originalVisibility = new Map<SceneNode, boolean>();
  if (temporarilyHideChildren) {
    parent.children.map((child: SceneNode) =>
      originalVisibility.set(child, child.visible),
    ),
      parent.children.forEach((child) => {
        child.visible = false;
      });
  }
  const exportSettings: ExportSettingsImage = {
    format: "PNG",
    constraint: { type: "SCALE", value: 1 },
  };
  const bytes = await exportAsyncProxy(n, exportSettings);
  if (temporarilyHideChildren) {
    parent.children.forEach((child) => {
      child.visible = originalVisibility.get(child) ?? false;
    });
  }
  addWarning("Some images exported as Base64 PNG");
  const base64 = imageBytesToBase64(bytes);
  node.base64 = base64;
  return base64;
};
</file>

<file path="packages/backend/src/common/lowercaseFirstLetter.ts">
export function lowercaseFirstLetter(str: string): string {
  if (!str || str.length === 0) {
    return str;
  }
  return str.charAt(0).toLowerCase() + str.slice(1);
}
</file>

<file path="packages/backend/src/common/retrieveFill.ts">
import { Paint } from "../api_types";
export const retrieveTopFill = (
  fills: ReadonlyArray<Paint> | undefined,
): Paint | undefined => {
  if (fills && Array.isArray(fills) && fills.length > 0) {
    return [...fills].reverse().find((d) => d.visible !== false);
  }
  return undefined;
};
</file>

<file path="packages/backend/src/flutter/builderImpl/flutterBlend.ts">
import {
  generateWidgetCode,
  numberToFixedString,
} from "../../common/numToAutoFixed";
export const flutterOpacity = (
  node: MinimalBlendMixin,
  child: string,
): string => {
  if (node.opacity !== undefined && node.opacity !== 1 && child !== "") {
    return generateWidgetCode("Opacity", {
      opacity: numberToFixedString(node.opacity),
      child: child,
    });
  }
  return child;
};
export const flutterVisibility = (node: SceneNode, child: string): string => {
  if (node.visible !== undefined && !node.visible && child !== "") {
    return generateWidgetCode("Visibility", {
      visible: `${node.visible}`,
      child: child,
    });
  }
  return child;
};
export const flutterRotation = (node: LayoutMixin, child: string): string => {
  if (
    node.rotation !== undefined &&
    child !== "" &&
    Math.round(node.rotation) !== 0
  ) {
    const matrix = generateRotationMatrix(node);
    if (matrix) {
      return generateWidgetCode("Transform", {
        transform: matrix,
        child: child,
      });
    }
  }
  return child;
};
export const generateRotationMatrix = (node: LayoutMixin): string => {
  const rotation = (node.rotation || 0) + (node.cumulativeRotation || 0);
  if (Math.round(rotation) === 0) {
    return "";
  }
  return `Matrix4.identity()..translate(0.0, 0.0)..rotateZ(${numberToFixedString(
    rotation * (-Math.PI / 180),
  )})`;
};
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiBlend.ts">
import { SwiftUIModifier } from "types";
import { numberToFixedString } from "../../common/numToAutoFixed";
export const swiftuiOpacity = (
  node: MinimalBlendMixin,
): SwiftUIModifier | null => {
  if (node.opacity !== undefined && node.opacity !== 1) {
    return ["opacity", numberToFixedString(node.opacity)];
  }
  return null;
};
export const swiftuiVisibility = (
  node: SceneNodeMixin,
): SwiftUIModifier | null => {
  if (node.visible !== undefined && !node.visible) {
    return ["hidden", ""];
  }
  return null;
};
/**
 * https://developer.apple.com/documentation/swiftui/modifiedcontent/rotationeffect(_:anchor:)
 */
export const swiftuiRotation = (node: LayoutMixin): SwiftUIModifier | null => {
  const rotation = (node.rotation || 0) + (node.cumulativeRotation || 0);
  if (Math.round(rotation) !== 0) {
    return ["rotationEffect", `.degrees(${numberToFixedString(rotation)})`];
  }
  return null;
};
export const swiftuiBlendMode = (
  node: MinimalBlendMixin,
): SwiftUIModifier | null => {
  const fromBlendEnum = blendModeEnum(node);
  if (fromBlendEnum) {
    return ["blendMode", fromBlendEnum];
  }
  return null;
};
const blendModeEnum = (node: MinimalBlendMixin): string => {
  switch (node.blendMode) {
    case "COLOR":
      return ".color";
    case "COLOR_BURN":
      return ".colorBurn";
    case "COLOR_DODGE":
      return ".colorDodge";
    case "DIFFERENCE":
      return ".difference";
    case "EXCLUSION":
      return ".exclusion";
    case "HARD_LIGHT":
      return ".hardLight";
    case "HUE":
      return ".hue";
    case "LIGHTEN":
      return ".lighten";
    case "LUMINOSITY":
      return ".luminosity";
    case "MULTIPLY":
      return ".multiply";
    case "OVERLAY":
      return ".overlay";
    case "SATURATION":
      return ".saturation";
    case "SCREEN":
      return ".screen";
    case "SOFT_LIGHT":
      return ".softLight";
    default:
      return "";
  }
};
</file>

<file path="packages/backend/src/tailwind/builderImpl/tailwindShadow.ts">
import { localTailwindSettings } from "../tailwindMain";
export const tailwindShadow = (node: BlendMixin): string[] => {
  if (node.effects && node.effects.length > 0) {
    const EPSILON = 0.0001;
    const dropShadow = node.effects.map((d) => {
      if (d.type === "DROP_SHADOW") {
        if (
          d.offset?.x === 0 &&
          d.offset?.y === 1 &&
          d.radius === 2 &&
          d.spread === 0 &&
          d.color?.r === 0 &&
          d.color?.g === 0 &&
          d.color?.b === 0 &&
          Math.abs(d.color?.a - 0.05) < EPSILON
        ) {
          return localTailwindSettings.useTailwind4 ? "shadow-xs" : "shadow-sm";
        } else if (
          d.offset?.x === 0 &&
          d.offset?.y === 1 &&
          d.radius === 3 &&
          d.spread === 0 &&
          d.color?.r === 0 &&
          d.color?.g === 0 &&
          d.color?.b === 0 &&
          Math.abs(d.color?.a - 0.1) < EPSILON
        ) {
          return localTailwindSettings.useTailwind4 ? "shadow-sm" : "shadow";
        } else if (
          d.offset?.x === 0 &&
          d.offset?.y === 4 &&
          d.radius === 6 &&
          d.spread === -1 &&
          d.color?.r === 0 &&
          d.color?.g === 0 &&
          d.color?.b === 0 &&
          Math.abs(d.color?.a - 0.1) < EPSILON
        ) {
          return "shadow-md";
        } else if (
          d.offset?.x === 0 &&
          d.offset?.y === 10 &&
          d.radius === 15 &&
          d.spread === -3 &&
          d.color?.r === 0 &&
          d.color?.g === 0 &&
          d.color?.b === 0 &&
          Math.abs(d.color?.a - 0.1) < EPSILON
        ) {
          return "shadow-lg";
        } else if (
          d.offset?.x === 0 &&
          d.offset?.y === 20 &&
          d.radius === 25 &&
          d.spread === -5 &&
          d.color?.r === 0 &&
          d.color?.g === 0 &&
          d.color?.b === 0 &&
          Math.abs(d.color?.a - 0.1) < EPSILON
        ) {
          return "shadow-xl";
        } else if (
          d.offset?.x === 0 &&
          d.offset?.y === 25 &&
          d.radius === 50 &&
          d.spread === -12 &&
          d.color?.r === 0 &&
          d.color?.g === 0 &&
          d.color?.b === 0 &&
          Math.abs(d.color?.a - 0.25) < EPSILON
        ) {
          return "shadow-2xl";
        } else {
          const offsetX = d.offset?.x || 0;
          const offsetY = d.offset?.y || 0;
          const radius = d.radius || 0;
          const spread = d.spread || 0;
          const r = Math.round((d.color?.r || 0) * 255);
          const g = Math.round((d.color?.g || 0) * 255);
          const b = Math.round((d.color?.b || 0) * 255);
          const a = (d.color?.a || 0).toFixed(2);
          return `shadow-[${offsetX}px_${offsetY}px_${radius}px_${spread}px_rgba(${r},${g},${b},${a})]`;
        }
      }
      return "";
    }).filter(Boolean);
    const innerShadow = node.effects.map((d) => {
      if (d.type === "INNER_SHADOW") {
        if (
          d.offset?.x === 0 &&
          d.offset?.y === 2 &&
          d.radius === 4 &&
          d.spread === 0 &&
          d.color?.r === 0 &&
          d.color?.g === 0 &&
          d.color?.b === 0 &&
          Math.abs(d.color?.a - 0.05) < EPSILON
        ) {
          return "shadow-inner";
        } else {
          const offsetX = d.offset?.x || 0;
          const offsetY = d.offset?.y || 0;
          const radius = d.radius || 0;
          const spread = d.spread || 0;
          const r = Math.round((d.color?.r || 0) * 255);
          const g = Math.round((d.color?.g || 0) * 255);
          const b = Math.round((d.color?.b || 0) * 255);
          const a = (d.color?.a || 0).toFixed(2);
          return `shadow-[inset_${offsetX}px_${offsetY}px_${radius}px_${spread}px_rgba(${r},${g},${b},${a})]`;
        }
      }
      return "";
    }).filter(Boolean);
    return [...dropShadow, ...innerShadow];
  }
  return [];
};
</file>

<file path="packages/backend/src/api_types.ts">
export type IsLayerTrait = {
    id: string
    name: string
    type: string
    visible?: boolean
    locked?: boolean
    isFixed?: boolean
    scrollBehavior: 'SCROLLS' | 'FIXED' | 'STICKY_SCROLLS'
    rotation?: number
    componentPropertyReferences?: { [key: string]: string }
    pluginData?: unknown
    sharedPluginData?: unknown
    boundVariables?: {
      size?: {
        x?: VariableAlias
        y?: VariableAlias
      }
      individualStrokeWeights?: {
        top?: VariableAlias
        bottom?: VariableAlias
        left?: VariableAlias
        right?: VariableAlias
      }
      characters?: VariableAlias
      itemSpacing?: VariableAlias
      paddingLeft?: VariableAlias
      paddingRight?: VariableAlias
      paddingTop?: VariableAlias
      paddingBottom?: VariableAlias
      visible?: VariableAlias
      topLeftRadius?: VariableAlias
      topRightRadius?: VariableAlias
      bottomLeftRadius?: VariableAlias
      bottomRightRadius?: VariableAlias
      minWidth?: VariableAlias
      maxWidth?: VariableAlias
      minHeight?: VariableAlias
      maxHeight?: VariableAlias
      counterAxisSpacing?: VariableAlias
      opacity?: VariableAlias
      fontFamily?: VariableAlias[]
      fontSize?: VariableAlias[]
      fontStyle?: VariableAlias[]
      fontWeight?: VariableAlias[]
      letterSpacing?: VariableAlias[]
      lineHeight?: VariableAlias[]
      paragraphSpacing?: VariableAlias[]
      paragraphIndent?: VariableAlias[]
      fills?: VariableAlias[]
      strokes?: VariableAlias[]
      componentProperties?: { [key: string]: VariableAlias }
      textRangeFills?: VariableAlias[]
      effects?: VariableAlias[]
      layoutGrids?: VariableAlias[]
    }
    explicitVariableModes?: { [key: string]: string }
  }
  export type HasChildrenTrait = {
    children: SubcanvasNode[]
  }
  export type HasLayoutTrait = {
    absoluteBoundingBox: Rectangle | null
    absoluteRenderBounds: Rectangle | null
    preserveRatio?: boolean
    constraints?: LayoutConstraint
    relativeTransform?: Transform
    size?: Vector
    layoutAlign?: 'INHERIT' | 'STRETCH' | 'MIN' | 'CENTER' | 'MAX'
    layoutGrow?: 0 | 1
    layoutPositioning?: 'AUTO' | 'ABSOLUTE'
    minWidth?: number
    maxWidth?: number
    minHeight?: number
    maxHeight?: number
    layoutSizingHorizontal?: 'FIXED' | 'HUG' | 'FILL'
    layoutSizingVertical?: 'FIXED' | 'HUG' | 'FILL'
  }
  export type HasFramePropertiesTrait = {
    clipsContent: boolean
    background?: Paint[]
    backgroundColor?: RGBA
    layoutGrids?: LayoutGrid[]
    overflowDirection?:
      | 'HORIZONTAL_SCROLLING'
      | 'VERTICAL_SCROLLING'
      | 'HORIZONTAL_AND_VERTICAL_SCROLLING'
      | 'NONE'
    layoutMode?: 'NONE' | 'HORIZONTAL' | 'VERTICAL'
    primaryAxisSizingMode?: 'FIXED' | 'AUTO'
    counterAxisSizingMode?: 'FIXED' | 'AUTO'
    primaryAxisAlignItems?: 'MIN' | 'CENTER' | 'MAX' | 'SPACE_BETWEEN'
    counterAxisAlignItems?: 'MIN' | 'CENTER' | 'MAX' | 'BASELINE'
    paddingLeft?: number
    paddingRight?: number
    paddingTop?: number
    paddingBottom?: number
    itemSpacing?: number
    itemReverseZIndex?: boolean
    strokesIncludedInLayout?: boolean
    layoutWrap?: 'NO_WRAP' | 'WRAP'
    counterAxisSpacing?: number
    counterAxisAlignContent?: 'AUTO' | 'SPACE_BETWEEN'
  }
  export type HasBlendModeAndOpacityTrait = {
    blendMode: BlendMode
    opacity?: number
  }
  export type HasExportSettingsTrait = {
    exportSettings?: ExportSetting[]
  }
  export type HasGeometryTrait = MinimalFillsTrait &
    MinimalStrokesTrait & {
      fillOverrideTable?: { [key: string]: PaintOverride | null }
      fillGeometry?: Path[]
      strokeGeometry?: Path[]
      strokeCap?:
        | 'NONE'
        | 'ROUND'
        | 'SQUARE'
        | 'LINE_ARROW'
        | 'TRIANGLE_ARROW'
        | 'DIAMOND_FILLED'
        | 'CIRCLE_FILLED'
        | 'TRIANGLE_FILLED'
        | 'WASHI_TAPE_1'
        | 'WASHI_TAPE_2'
        | 'WASHI_TAPE_3'
        | 'WASHI_TAPE_4'
        | 'WASHI_TAPE_5'
        | 'WASHI_TAPE_6'
      strokeMiterAngle?: number
    }
  export type MinimalFillsTrait = {
    fills: Paint[]
    styles?: { [key: string]: string }
  }
  export type MinimalStrokesTrait = {
    strokes?: Paint[]
    strokeWeight?: number
    strokeAlign?: 'INSIDE' | 'OUTSIDE' | 'CENTER'
    strokeJoin?: 'MITER' | 'BEVEL' | 'ROUND'
    strokeDashes?: number[]
  }
  export type IndividualStrokesTrait = {
    individualStrokeWeights?: StrokeWeights
  }
  export type CornerTrait = {
    cornerRadius?: number
    cornerSmoothing?: number
    rectangleCornerRadii?: number[]
  }
  export type HasEffectsTrait = {
    effects: Effect[]
  }
  export type HasMaskTrait = {
    isMask?: boolean
    maskType?: 'ALPHA' | 'VECTOR' | 'LUMINANCE'
    isMaskOutline?: boolean
  }
  export type ComponentPropertiesTrait = {
    componentPropertyDefinitions?: { [key: string]: ComponentPropertyDefinition }
  }
  export type TypePropertiesTrait = {
    characters: string
    style: TypeStyle
    characterStyleOverrides: number[]
    layoutVersion?: number
    styleOverrideTable: { [key: string]: TypeStyle }
    lineTypes: ('NONE' | 'ORDERED' | 'UNORDERED')[]
    lineIndentations: number[]
  }
  export type HasTextSublayerTrait = {
    characters: string
  }
  export type TransitionSourceTrait = {
    transitionNodeID?: string
    transitionDuration?: number
    transitionEasing?: EasingType
    interactions?: Interaction[]
  }
  export type DevStatusTrait = {
    devStatus?: {
      type: 'NONE' | 'READY_FOR_DEV' | 'COMPLETED'
      description?: string
    }
  }
  export type AnnotationsTrait = object
  export type FrameTraits = IsLayerTrait &
    HasBlendModeAndOpacityTrait &
    HasChildrenTrait &
    HasLayoutTrait &
    HasFramePropertiesTrait &
    CornerTrait &
    HasGeometryTrait &
    HasExportSettingsTrait &
    HasEffectsTrait &
    HasMaskTrait &
    TransitionSourceTrait &
    IndividualStrokesTrait &
    DevStatusTrait &
    AnnotationsTrait
  export type DefaultShapeTraits = IsLayerTrait &
    HasBlendModeAndOpacityTrait &
    HasLayoutTrait &
    HasGeometryTrait &
    HasExportSettingsTrait &
    HasEffectsTrait &
    HasMaskTrait &
    TransitionSourceTrait
  export type CornerRadiusShapeTraits = DefaultShapeTraits & CornerTrait
  export type RectangularShapeTraits = DefaultShapeTraits &
    CornerTrait &
    IndividualStrokesTrait &
    AnnotationsTrait
  export type Node =
    | BooleanOperationNode
    | ComponentNode
    | ComponentSetNode
    | ConnectorNode
    | EllipseNode
    | EmbedNode
    | FrameNode
    | GroupNode
    | InstanceNode
    | LineNode
    | LinkUnfurlNode
    | RectangleNode
    | RegularPolygonNode
    | SectionNode
    | ShapeWithTextNode
    | SliceNode
    | StarNode
    | StickyNode
    | TableNode
    | TableCellNode
    | TextNode
    | VectorNode
    | WashiTapeNode
    | WidgetNode
    | DocumentNode
    | CanvasNode
  export type DocumentNode = {
    type: 'DOCUMENT'
    children: CanvasNode[]
  } & IsLayerTrait
  export type CanvasNode = {
    type: 'CANVAS'
    children: SubcanvasNode[]
    backgroundColor: RGBA
    prototypeStartNodeID: string | null
    flowStartingPoints: FlowStartingPoint[]
    prototypeDevice: PrototypeDevice
    measurements?: Measurement[]
  } & IsLayerTrait &
    HasExportSettingsTrait
  export type SubcanvasNode =
    | BooleanOperationNode
    | ComponentNode
    | ComponentSetNode
    | ConnectorNode
    | EllipseNode
    | EmbedNode
    | FrameNode
    | GroupNode
    | InstanceNode
    | LineNode
    | LinkUnfurlNode
    | RectangleNode
    | RegularPolygonNode
    | SectionNode
    | ShapeWithTextNode
    | SliceNode
    | StarNode
    | StickyNode
    | TableNode
    | TableCellNode
    | TextNode
    | VectorNode
    | WashiTapeNode
    | WidgetNode
  export type BooleanOperationNode = {
    type: 'BOOLEAN_OPERATION'
    booleanOperation: 'UNION' | 'INTERSECT' | 'SUBTRACT' | 'EXCLUDE'
  } & IsLayerTrait &
    HasBlendModeAndOpacityTrait &
    HasChildrenTrait &
    HasLayoutTrait &
    HasGeometryTrait &
    HasExportSettingsTrait &
    HasEffectsTrait &
    HasMaskTrait &
    TransitionSourceTrait
  export type SectionNode = {
    type: 'SECTION'
    sectionContentsHidden: boolean
  } & IsLayerTrait &
    HasGeometryTrait &
    HasChildrenTrait &
    HasLayoutTrait &
    DevStatusTrait
  export type FrameNode = {
    type: 'FRAME'
  } & FrameTraits
  export type GroupNode = {
    type: 'GROUP'
  } & FrameTraits
  export type ComponentNode = {
    type: 'COMPONENT'
  } & FrameTraits &
    ComponentPropertiesTrait
  export type ComponentSetNode = {
    type: 'COMPONENT_SET'
  } & FrameTraits &
    ComponentPropertiesTrait
  export type VectorNode = {
    type: 'VECTOR'
  } & CornerRadiusShapeTraits &
    AnnotationsTrait
  export type StarNode = {
    type: 'STAR'
  } & CornerRadiusShapeTraits &
    AnnotationsTrait
  export type LineNode = {
    type: 'LINE'
  } & DefaultShapeTraits &
    AnnotationsTrait
  export type EllipseNode = {
    type: 'ELLIPSE'
    arcData: ArcData
  } & DefaultShapeTraits &
    AnnotationsTrait
  export type RegularPolygonNode = {
    type: 'REGULAR_POLYGON'
  } & CornerRadiusShapeTraits &
    AnnotationsTrait
  export type RectangleNode = {
    type: 'RECTANGLE'
  } & RectangularShapeTraits
  export type TextNode = {
    type: 'TEXT'
  } & DefaultShapeTraits &
    TypePropertiesTrait &
    AnnotationsTrait
  export type TableNode = {
    type: 'TABLE'
  } & IsLayerTrait &
    HasChildrenTrait &
    HasLayoutTrait &
    MinimalStrokesTrait &
    HasEffectsTrait &
    HasBlendModeAndOpacityTrait &
    HasExportSettingsTrait
  export type TableCellNode = {
    type: 'TABLE_CELL'
  } & IsLayerTrait &
    MinimalFillsTrait &
    HasLayoutTrait &
    HasTextSublayerTrait
  export type SliceNode = {
    type: 'SLICE'
  } & IsLayerTrait
  export type InstanceNode = {
    type: 'INSTANCE'
    componentId: string
    isExposedInstance?: boolean
    exposedInstances?: string[]
    componentProperties?: { [key: string]: ComponentProperty }
    overrides: Overrides[]
  } & FrameTraits
  export type EmbedNode = {
    type: 'EMBED'
  } & IsLayerTrait &
    HasExportSettingsTrait
  export type LinkUnfurlNode = {
    type: 'LINK_UNFURL'
  } & IsLayerTrait &
    HasExportSettingsTrait
  export type StickyNode = {
    type: 'STICKY'
    authorVisible?: boolean
  } & IsLayerTrait &
    HasLayoutTrait &
    HasBlendModeAndOpacityTrait &
    MinimalFillsTrait &
    HasMaskTrait &
    HasEffectsTrait &
    HasExportSettingsTrait &
    HasTextSublayerTrait
  export type ShapeWithTextNode = {
    type: 'SHAPE_WITH_TEXT'
    shapeType: ShapeType
  } & IsLayerTrait &
    HasLayoutTrait &
    HasBlendModeAndOpacityTrait &
    MinimalFillsTrait &
    HasMaskTrait &
    HasEffectsTrait &
    HasExportSettingsTrait &
    HasTextSublayerTrait &
    CornerTrait &
    MinimalStrokesTrait
  export type ConnectorNode = {
    type: 'CONNECTOR'
    connectorStart: ConnectorEndpoint
    connectorEnd: ConnectorEndpoint
    connectorStartStrokeCap:
      | 'NONE'
      | 'LINE_ARROW'
      | 'TRIANGLE_ARROW'
      | 'DIAMOND_FILLED'
      | 'CIRCLE_FILLED'
      | 'TRIANGLE_FILLED'
    connectorEndStrokeCap:
      | 'NONE'
      | 'LINE_ARROW'
      | 'TRIANGLE_ARROW'
      | 'DIAMOND_FILLED'
      | 'CIRCLE_FILLED'
      | 'TRIANGLE_FILLED'
    connectorLineType: ConnectorLineType
    textBackground?: ConnectorTextBackground
  } & IsLayerTrait &
    HasLayoutTrait &
    HasBlendModeAndOpacityTrait &
    HasEffectsTrait &
    HasExportSettingsTrait &
    HasTextSublayerTrait &
    MinimalStrokesTrait
  export type WashiTapeNode = {
    type: 'WASHI_TAPE'
  } & DefaultShapeTraits
  export type WidgetNode = {
    type: 'WIDGET'
  } & IsLayerTrait &
    HasExportSettingsTrait &
    HasChildrenTrait
  export type RGB = {
    r: number
    g: number
    b: number
  }
  export type RGBA = {
    r: number
    g: number
    b: number
    a: number
  }
  export type FlowStartingPoint = {
    nodeId: string
    name: string
  }
  export type Size = {
    width: number
    height: number
  }
  export type PrototypeDevice = {
    type: 'NONE' | 'PRESET' | 'CUSTOM' | 'PRESENTATION'
    size?: Size
    presetIdentifier?: string
    rotation: 'NONE' | 'CCW_90'
  }
  export type Constraint = {
    type: 'SCALE' | 'WIDTH' | 'HEIGHT'
    value: number
  }
  export type ExportSetting = {
    suffix: string
    format: 'JPG' | 'PNG' | 'SVG' | 'PDF'
    constraint: Constraint
  }
  export type BlendMode =
    | 'PASS_THROUGH'
    | 'NORMAL'
    | 'DARKEN'
    | 'MULTIPLY'
    | 'LINEAR_BURN'
    | 'COLOR_BURN'
    | 'LIGHTEN'
    | 'SCREEN'
    | 'LINEAR_DODGE'
    | 'COLOR_DODGE'
    | 'OVERLAY'
    | 'SOFT_LIGHT'
    | 'HARD_LIGHT'
    | 'DIFFERENCE'
    | 'EXCLUSION'
    | 'HUE'
    | 'SATURATION'
    | 'COLOR'
    | 'LUMINOSITY'
  export type Vector = {
    x: number
    y: number
  }
  export type ColorStop = {
    position: number
    color: RGBA
    boundVariables?: { color?: VariableAlias }
  }
  export type Transform = number[][]
  export type ImageFilters = {
    exposure?: number
    contrast?: number
    saturation?: number
    temperature?: number
    tint?: number
    highlights?: number
    shadows?: number
  }
  export type BasePaint = {
    visible?: boolean
    opacity?: number
    blendMode: BlendMode
  }
  export type SolidPaint = {
    type: 'SOLID'
    color: RGBA
    boundVariables?: { color?: VariableAlias }
  } & BasePaint
  export type GradientPaint = {
    type: 'GRADIENT_LINEAR' | 'GRADIENT_RADIAL' | 'GRADIENT_ANGULAR' | 'GRADIENT_DIAMOND'
    gradientHandlePositions: Vector[]
    gradientStops: ColorStop[]
  } & BasePaint
  export type ImagePaint = {
    type: 'IMAGE'
    scaleMode: 'FILL' | 'FIT' | 'TILE' | 'STRETCH'
    imageRef: string
    imageTransform?: Transform
    scalingFactor?: number
    filters?: ImageFilters
    rotation?: number
    gifRef?: string
  } & BasePaint
  export type Paint = SolidPaint | GradientPaint | ImagePaint
  export type LayoutConstraint = {
    vertical: 'TOP' | 'BOTTOM' | 'CENTER' | 'TOP_BOTTOM' | 'SCALE'
    horizontal: 'LEFT' | 'RIGHT' | 'CENTER' | 'LEFT_RIGHT' | 'SCALE'
  }
  export type Rectangle = {
    x: number
    y: number
    width: number
    height: number
  }
  export type LayoutGrid = {
    pattern: 'COLUMNS' | 'ROWS' | 'GRID'
    sectionSize: number
    visible: boolean
    color: RGBA
    alignment: 'MIN' | 'MAX' | 'STRETCH' | 'CENTER'
    gutterSize: number
    offset: number
    count: number
    boundVariables?: {
      gutterSize?: VariableAlias
      numSections?: VariableAlias
      sectionSize?: VariableAlias
      offset?: VariableAlias
    }
  }
  export type BaseShadowEffect = {
    color: RGBA
    blendMode: BlendMode
    offset: Vector
    radius: number
    spread?: number
    visible: boolean
    boundVariables?: {
      radius?: VariableAlias
      spread?: VariableAlias
      color?: VariableAlias
      offsetX?: VariableAlias
      offsetY?: VariableAlias
    }
  }
  export type DropShadowEffect = {
    type: 'DROP_SHADOW'
    showShadowBehindNode: boolean
  } & BaseShadowEffect
  export type InnerShadowEffect = {
    type?: 'INNER_SHADOW'
  } & BaseShadowEffect
  export type BlurEffect = {
    type: 'LAYER_BLUR' | 'BACKGROUND_BLUR'
    visible: boolean
    radius: number
    boundVariables?: { radius?: VariableAlias }
  }
  export type Effect = DropShadowEffect | InnerShadowEffect | BlurEffect
  export type Style = {
    key: string
    name: string
    description: string
    remote: boolean
    styleType: StyleType
  }
  export type EasingType =
    | 'EASE_IN'
    | 'EASE_OUT'
    | 'EASE_IN_AND_OUT'
    | 'LINEAR'
    | 'EASE_IN_BACK'
    | 'EASE_OUT_BACK'
    | 'EASE_IN_AND_OUT_BACK'
    | 'CUSTOM_CUBIC_BEZIER'
    | 'GENTLE'
    | 'QUICK'
    | 'BOUNCY'
    | 'SLOW'
    | 'CUSTOM_SPRING'
  export type StrokeWeights = {
    top: number
    right: number
    bottom: number
    left: number
  }
  export type PaintOverride = {
    fills?: Paint[]
    inheritFillStyleId?: string
  }
  export type Path = {
    path: string
    windingRule: 'NONZERO' | 'EVENODD'
    overrideID?: number
  }
  export type ArcData = {
    startingAngle: number
    endingAngle: number
    innerRadius: number
  }
  export type Hyperlink = {
    type: 'URL' | 'NODE'
    url?: string
    nodeID?: string
  }
  export type TypeStyle = {
    fontFamily?: string
    fontPostScriptName?: string | null
    fontStyle?: string
    paragraphSpacing?: number
    paragraphIndent?: number
    listSpacing?: number
    italic?: boolean
    fontWeight?: number
    fontSize?: number
    textCase?: 'UPPER' | 'LOWER' | 'TITLE' | 'SMALL_CAPS' | 'SMALL_CAPS_FORCED'
    textDecoration?: 'NONE' | 'STRIKETHROUGH' | 'UNDERLINE'
    textAutoResize?: 'NONE' | 'WIDTH_AND_HEIGHT' | 'HEIGHT' | 'TRUNCATE'
    textTruncation?: 'DISABLED' | 'ENDING'
    maxLines?: number
    textAlignHorizontal?: 'LEFT' | 'RIGHT' | 'CENTER' | 'JUSTIFIED'
    textAlignVertical?: 'TOP' | 'CENTER' | 'BOTTOM'
    letterSpacing?: number
    fills?: Paint[]
    hyperlink?: Hyperlink
    opentypeFlags?: { [key: string]: number }
    lineHeightPx?: number
    lineHeightPercent?: number
    lineHeightPercentFontSize?: number
    lineHeightUnit?: 'PIXELS' | 'FONT_SIZE_%' | 'INTRINSIC_%'
    boundVariables?: {
      fontFamily?: VariableAlias
      fontSize?: VariableAlias
      fontStyle?: VariableAlias
      fontWeight?: VariableAlias
      letterSpacing?: VariableAlias
      lineHeight?: VariableAlias
      paragraphSpacing?: VariableAlias
      paragraphIndent?: VariableAlias
    }
    isOverrideOverTextStyle?: boolean
    semanticWeight?: 'BOLD' | 'NORMAL'
    semanticItalic?: 'ITALIC' | 'NORMAL'
  }
  export type ComponentPropertyType = 'BOOLEAN' | 'INSTANCE_SWAP' | 'TEXT' | 'VARIANT'
  export type InstanceSwapPreferredValue = {
    type: 'COMPONENT' | 'COMPONENT_SET'
    key: string
  }
  export type ComponentPropertyDefinition = {
    type: ComponentPropertyType
    defaultValue: boolean | string
    variantOptions?: string[]
    preferredValues?: InstanceSwapPreferredValue[]
  }
  export type ComponentProperty = {
    type: ComponentPropertyType
    value: boolean | string
    preferredValues?: InstanceSwapPreferredValue[]
    boundVariables?: { value?: VariableAlias }
  }
  export type Overrides = {
    id: string
    overriddenFields: string[]
  }
  export type ShapeType =
    | 'SQUARE'
    | 'ELLIPSE'
    | 'ROUNDED_RECTANGLE'
    | 'DIAMOND'
    | 'TRIANGLE_UP'
    | 'TRIANGLE_DOWN'
    | 'PARALLELOGRAM_RIGHT'
    | 'PARALLELOGRAM_LEFT'
    | 'ENG_DATABASE'
    | 'ENG_QUEUE'
    | 'ENG_FILE'
    | 'ENG_FOLDER'
    | 'TRAPEZOID'
    | 'PREDEFINED_PROCESS'
    | 'SHIELD'
    | 'DOCUMENT_SINGLE'
    | 'DOCUMENT_MULTIPLE'
    | 'MANUAL_INPUT'
    | 'HEXAGON'
    | 'CHEVRON'
    | 'PENTAGON'
    | 'OCTAGON'
    | 'STAR'
    | 'PLUS'
    | 'ARROW_LEFT'
    | 'ARROW_RIGHT'
    | 'SUMMING_JUNCTION'
    | 'OR'
    | 'SPEECH_BUBBLE'
    | 'INTERNAL_STORAGE'
  export type ConnectorEndpoint =
    | {
        endpointNodeId?: string
        position?: Vector
      }
    | {
        endpointNodeId?: string
        magnet?: 'AUTO' | 'TOP' | 'BOTTOM' | 'LEFT' | 'RIGHT' | 'CENTER'
      }
  export type ConnectorLineType = 'STRAIGHT' | 'ELBOWED'
  export type ConnectorTextBackground = CornerTrait & MinimalFillsTrait
  export type Component = {
    key: string
    name: string
    description: string
    componentSetId?: string
    documentationLinks: DocumentationLink[]
    remote: boolean
  }
  export type ComponentSet = {
    key: string
    name: string
    description: string
    documentationLinks?: DocumentationLink[]
    remote?: boolean
  }
  export type DocumentationLink = {
    uri: string
  }
  export type VariableAlias = {
    type: 'VARIABLE_ALIAS'
    id: string
  }
  export type Interaction = {
    trigger: Trigger | null
    actions?: Action[]
  }
  export type Trigger =
    | { type: 'ON_CLICK' | 'ON_HOVER' | 'ON_PRESS' | 'ON_DRAG' }
    | AfterTimeoutTrigger
    | {
        type: 'MOUSE_ENTER' | 'MOUSE_LEAVE' | 'MOUSE_UP' | 'MOUSE_DOWN'
        delay: number
        deprecatedVersion?: boolean
      }
    | OnKeyDownTrigger
    | OnMediaHitTrigger
    | { type: 'ON_MEDIA_END' }
  export type AfterTimeoutTrigger = {
    type: 'AFTER_TIMEOUT'
    timeout: number
  }
  export type OnKeyDownTrigger = {
    type: 'ON_KEY_DOWN'
    device: 'KEYBOARD' | 'XBOX_ONE' | 'PS4' | 'SWITCH_PRO' | 'UNKNOWN_CONTROLLER'
    keyCodes: number[]
  }
  export type OnMediaHitTrigger = {
    type: 'ON_MEDIA_HIT'
    mediaHitTime: number
  }
  export type Action =
    | { type: 'BACK' | 'CLOSE' }
    | OpenURLAction
    | UpdateMediaRuntimeAction
    | SetVariableAction
    | SetVariableModeAction
    | ConditionalAction
    | NodeAction
  export type OpenURLAction = {
    type: 'URL'
    url: string
  }
  export type UpdateMediaRuntimeAction =
    | {
        type: 'UPDATE_MEDIA_RUNTIME'
        destinationId: string | null
        mediaAction: 'PLAY' | 'PAUSE' | 'TOGGLE_PLAY_PAUSE' | 'MUTE' | 'UNMUTE' | 'TOGGLE_MUTE_UNMUTE'
      }
    | {
        type: 'UPDATE_MEDIA_RUNTIME'
        destinationId?: string | null
        mediaAction: 'SKIP_FORWARD' | 'SKIP_BACKWARD'
        amountToSkip: number
      }
    | {
        type: 'UPDATE_MEDIA_RUNTIME'
        destinationId?: string | null
        mediaAction: 'SKIP_TO'
        newTimestamp: number
      }
  export type NodeAction = {
    type: 'NODE'
    destinationId: string | null
    navigation: Navigation
    transition: Transition | null
    preserveScrollPosition?: boolean
    overlayRelativePosition?: Vector
    resetVideoPosition?: boolean
    resetScrollPosition?: boolean
    resetInteractiveComponents?: boolean
  }
  export type Navigation = 'NAVIGATE' | 'SWAP' | 'OVERLAY' | 'SCROLL_TO' | 'CHANGE_TO'
  export type Transition = SimpleTransition | DirectionalTransition
  export type SimpleTransition = {
    type: 'DISSOLVE' | 'SMART_ANIMATE' | 'SCROLL_ANIMATE'
    duration: number
    easing: Easing
  }
  export type DirectionalTransition = {
    type: 'MOVE_IN' | 'MOVE_OUT' | 'PUSH' | 'SLIDE_IN' | 'SLIDE_OUT'
    direction: 'LEFT' | 'RIGHT' | 'TOP' | 'BOTTOM'
    duration: number
    easing: Easing
    matchLayers?: boolean
  }
  export type Easing = {
    type: EasingType
    easingFunctionCubicBezier?: {
      x1: number
      y1: number
      x2: number
      y2: number
    }
    easingFunctionSpring?: {
      mass: number
      stiffness: number
      damping: number
    }
  }
  export type SetVariableAction = {
    type: 'SET_VARIABLE'
    variableId: string | null
    variableValue?: VariableData
  }
  export type SetVariableModeAction = {
    type: 'SET_VARIABLE_MODE'
    variableCollectionId?: string | null
    variableModeId?: string | null
  }
  export type ConditionalAction = {
    type: 'CONDITIONAL'
    conditionalBlocks: ConditionalBlock[]
  }
  export type VariableData = {
    type?: VariableDataType
    resolvedType?: VariableResolvedDataType
    value?: boolean | number | string | RGB | RGBA | VariableAlias | Expression
  }
  export type VariableDataType =
    | 'BOOLEAN'
    | 'FLOAT'
    | 'STRING'
    | 'COLOR'
    | 'VARIABLE_ALIAS'
    | 'EXPRESSION'
  export type VariableResolvedDataType = 'BOOLEAN' | 'FLOAT' | 'STRING' | 'COLOR'
  export type Expression = {
    expressionFunction: ExpressionFunction
    expressionArguments: VariableData[]
  }
  export type ExpressionFunction =
    | 'ADDITION'
    | 'SUBTRACTION'
    | 'MULTIPLICATION'
    | 'DIVISION'
    | 'EQUALS'
    | 'NOT_EQUAL'
    | 'LESS_THAN'
    | 'LESS_THAN_OR_EQUAL'
    | 'GREATER_THAN'
    | 'GREATER_THAN_OR_EQUAL'
    | 'AND'
    | 'OR'
    | 'VAR_MODE_LOOKUP'
    | 'NEGATE'
    | 'NOT'
  export type ConditionalBlock = {
    condition?: VariableData
    actions: Action[]
  }
  export type Measurement = {
    id: string
    start: MeasurementStartEnd
    end: MeasurementStartEnd
    offset: MeasurementOffsetInner | MeasurementOffsetOuter
    freeText?: string
  }
  export type MeasurementStartEnd = {
    nodeId: string
    side: 'TOP' | 'RIGHT' | 'BOTTOM' | 'LEFT'
  }
  export type MeasurementOffsetInner = {
    type: 'INNER'
    relative: number
  }
  export type MeasurementOffsetOuter = {
    type: 'OUTER'
    fixed: number
  }
  export type FrameOffset = {
    node_id: string
    node_offset: Vector
  }
  export type Region = {
    x: number
    y: number
    region_height: number
    region_width: number
    comment_pin_corner?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'
  }
  export type FrameOffsetRegion = {
    node_id: string
    node_offset: Vector
    region_height: number
    region_width: number
    comment_pin_corner?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'
  }
  export type Comment = {
    id: string
    client_meta: Vector | FrameOffset | Region | FrameOffsetRegion
    file_key: string
    parent_id?: string
    user: User
    created_at: string
    resolved_at?: string | null
    message: string
    order_id: string | null
    reactions: Reaction[]
  }
  export type Reaction = {
    user: User
    emoji: Emoji
    created_at: string
  }
  export type Emoji = string
  export type User = {
    id: string
    handle: string
    img_url: string
  }
  export type FrameInfo = {
    nodeId?: string
    name?: string
    backgroundColor?: string
    pageId: string
    pageName: string
  }
  export type PublishedComponent = {
    key: string
    file_key: string
    node_id: string
    thumbnail_url?: string
    name: string
    description: string
    created_at: string
    updated_at: string
    user: User
    containing_frame?: FrameInfo
  }
  export type PublishedComponentSet = {
    key: string
    file_key: string
    node_id: string
    thumbnail_url?: string
    name: string
    description: string
    created_at: string
    updated_at: string
    user: User
    containing_frame?: FrameInfo
  }
  export type StyleType = 'FILL' | 'TEXT' | 'EFFECT' | 'GRID'
  export type PublishedStyle = {
    key: string
    file_key: string
    node_id: string
    style_type: StyleType
    thumbnail_url?: string
    name: string
    description: string
    created_at: string
    updated_at: string
    user: User
    sort_position: string
  }
  export type Project = {
    id: string
    name: string
  }
  export type Version = {
    id: string
    created_at: string
    label: string | null
    description: string | null
    user: User
    thumbnail_url?: string
  }
  export type WebhookV2 = {
    id: string
    event_type: WebhookV2Event
    team_id: string
    status: WebhookV2Status
    client_id: string | null
    passcode: string
    endpoint: string
    description: string | null
  }
  export type WebhookV2Event =
    | 'PING'
    | 'FILE_UPDATE'
    | 'FILE_VERSION_UPDATE'
    | 'FILE_DELETE'
    | 'LIBRARY_PUBLISH'
    | 'FILE_COMMENT'
  export type WebhookV2Status = 'ACTIVE' | 'PAUSED'
  export type WebhookV2Request = {
    webhook_id: string
    request_info: WebhookV2RequestInfo
    response_info: WebhookV2ResponseInfo
    error_msg: string | null
  }
  export type WebhookV2RequestInfo = {
    id: string
    endpoint: string
    payload: object
    sent_at: string
  }
  export type WebhookV2ResponseInfo = object | null
  export type LibraryItemData = {
    key: string
    name: string
  }
  export type CommentFragment = {
    text?: string
    mention?: string
  }
  export type WebhookBasePayload = {
    passcode: string
    timestamp: string
    webhook_id: string
  }
  export type WebhookPingPayload = WebhookBasePayload & { event_type: 'PING' }
  export type WebhookFileUpdatePayload = WebhookBasePayload & {
    event_type: 'FILE_UPDATE'
    file_key: string
    file_name: string
  }
  export type WebhookFileDeletePayload = WebhookBasePayload & {
    event_type: 'FILE_DELETE'
    file_key: string
    file_name: string
    triggered_by: User
  }
  export type WebhookFileVersionUpdatePayload = WebhookBasePayload & {
    event_type: 'FILE_VERSION_UPDATE'
    created_at: string
    description?: string
    file_key: string
    file_name: string
    triggered_by: User
    version_id: string
  }
  export type WebhookLibraryPublishPayload = WebhookBasePayload & {
    event_type: 'LIBRARY_PUBLISH'
    created_components: LibraryItemData[]
    created_styles: LibraryItemData[]
    created_variables: LibraryItemData[]
    modified_components: LibraryItemData[]
    modified_styles: LibraryItemData[]
    modified_variables: LibraryItemData[]
    deleted_components: LibraryItemData[]
    deleted_styles: LibraryItemData[]
    deleted_variables: LibraryItemData[]
    description?: string
    file_key: string
    file_name: string
    library_item: LibraryItemData
    triggered_by: User
  }
  export type WebhookFileCommentPayload = WebhookBasePayload & {
    event_type: 'FILE_COMMENT'
    comment: CommentFragment[]
    comment_id: string
    created_at: string
    file_key: string
    file_name: string
    mentions?: User[]
    triggered_by: User
  }
  export type ActivityLogUserEntity = {
    type: 'user'
    id: string
    name: string
    email: string
  }
  export type ActivityLogFileEntity = {
    type: 'file'
    key: string
    name: string
    editor_type: 'figma' | 'figjam'
    link_access: 'view' | 'edit' | 'org_view' | 'org_edit' | 'inherit'
    proto_link_access: 'view' | 'org_view' | 'inherit'
  }
  export type ActivityLogFileRepoEntity = {
    type: 'file_repo'
    id: string
    name: string
    main_file_key: string
  }
  export type ActivityLogProjectEntity = {
    type: 'project'
    id: string
    name: string
  }
  export type ActivityLogTeamEntity = {
    type: 'team'
    id: string
    name: string
  }
  export type ActivityLogWorkspaceEntity = {
    type: 'workspace'
    id: string
    name: string
  }
  export type ActivityLogOrgEntity = {
    type: 'org'
    id: string
    name: string
  }
  export type ActivityLogPluginEntity = {
    type: 'plugin'
    id: string
    name: string
    editor_type: 'figma' | 'figjam'
  }
  export type ActivityLogWidgetEntity = {
    type: 'widget'
    id: string
    name: string
    editor_type: 'figma' | 'figjam'
  }
  export type ActivityLog = {
    id: string
    timestamp: number
    actor: object | null
    action: {
      type: string
      details: object | null
    }
    entity:
      | ActivityLogUserEntity
      | ActivityLogFileEntity
      | ActivityLogFileRepoEntity
      | ActivityLogProjectEntity
      | ActivityLogTeamEntity
      | ActivityLogWorkspaceEntity
      | ActivityLogOrgEntity
      | ActivityLogPluginEntity
      | ActivityLogWidgetEntity
    context: {
      client_name: string | null
      ip_address: string
      is_figma_support_team_action: boolean
      org_id: string
      team_id: string | null
    }
  }
  export type PaymentStatus = {
    type?: 'UNPAID' | 'PAID' | 'TRIAL'
  }
  export type PaymentInformation = {
    user_id: string
    resource_id: string
    resource_type: 'PLUGIN' | 'WIDGET' | 'COMMUNITY_FILE'
    payment_status: PaymentStatus
    date_of_purchase?: string
  }
  export type VariableScope =
    | 'ALL_SCOPES'
    | 'TEXT_CONTENT'
    | 'CORNER_RADIUS'
    | 'WIDTH_HEIGHT'
    | 'GAP'
    | 'ALL_FILLS'
    | 'FRAME_FILL'
    | 'SHAPE_FILL'
    | 'TEXT_FILL'
    | 'STROKE_COLOR'
    | 'STROKE_FLOAT'
    | 'EFFECT_FLOAT'
    | 'EFFECT_COLOR'
    | 'OPACITY'
    | 'FONT_FAMILY'
    | 'FONT_STYLE'
    | 'FONT_WEIGHT'
    | 'FONT_SIZE'
    | 'LINE_HEIGHT'
    | 'LETTER_SPACING'
    | 'PARAGRAPH_SPACING'
    | 'PARAGRAPH_INDENT'
  export type VariableCodeSyntax = {
    WEB?: string
    ANDROID?: string
    iOS?: string
  }
  export type LocalVariableCollection = {
    id: string
    name: string
    key: string
    modes: {
      modeId: string
      name: string
    }[]
    defaultModeId: string
    remote: boolean
    hiddenFromPublishing: boolean
    variableIds: string[]
  }
  export type LocalVariable = {
    id: string
    name: string
    key: string
    variableCollectionId: string
    resolvedType: 'BOOLEAN' | 'FLOAT' | 'STRING' | 'COLOR'
    valuesByMode: { [key: string]: boolean | number | string | RGBA | VariableAlias }
    remote: boolean
    description: string
    hiddenFromPublishing: boolean
    scopes: VariableScope[]
    codeSyntax: VariableCodeSyntax
    deletedButReferenced?: boolean
  }
  export type PublishedVariableCollection = {
    id: string
    subscribed_id: string
    name: string
    key: string
    updatedAt: string
  }
  export type PublishedVariable = {
    id: string
    subscribed_id: string
    name: string
    key: string
    variableCollectionId: string
    resolvedDataType: 'BOOLEAN' | 'FLOAT' | 'STRING' | 'COLOR'
    updatedAt: string
  }
  export type VariableCollectionCreate = {
    action: 'CREATE'
    id?: string
    name: string
    initialModeId?: string
    hiddenFromPublishing?: boolean
  }
  export type VariableCollectionUpdate = {
    action: 'UPDATE'
    id: string
    name?: string
    hiddenFromPublishing?: boolean
  }
  export type VariableCollectionDelete = {
    action: 'DELETE'
    id: string
  }
  export type VariableCollectionChange =
    | VariableCollectionCreate
    | VariableCollectionUpdate
    | VariableCollectionDelete
  export type VariableModeCreate = {
    action: 'CREATE'
    id?: string
    name: string
    variableCollectionId: string
  }
  export type VariableModeUpdate = {
    action: 'UPDATE'
    id: string
    name?: string
    variableCollectionId: string
  }
  export type VariableModeDelete = {
    action: 'DELETE'
    id: string
  }
  export type VariableModeChange = VariableModeCreate | VariableModeUpdate | VariableModeDelete
  export type VariableCreate = {
    action: 'CREATE'
    id?: string
    name: string
    variableCollectionId: string
    resolvedType: 'BOOLEAN' | 'FLOAT' | 'STRING' | 'COLOR'
    description?: string
    hiddenFromPublishing?: boolean
    scopes?: VariableScope[]
    codeSyntax?: VariableCodeSyntax
  }
  export type VariableUpdate = {
    action: 'UPDATE'
    id: string
    name?: string
    description?: string
    hiddenFromPublishing?: boolean
    scopes?: VariableScope[]
    codeSyntax?: VariableCodeSyntax
  }
  export type VariableDelete = {
    action: 'DELETE'
    id: string
  }
  export type VariableChange = VariableCreate | VariableUpdate | VariableDelete
  export type VariableModeValue = {
    variableId: string
    modeId: string
    value: VariableValue
  }
  export type VariableValue = boolean | number | string | RGB | RGBA | VariableAlias
  export type DevResource = {
    id: string
    name: string
    url: string
    file_key: string
    node_id: string
  }
  export type LibraryAnalyticsComponentActionsByAsset = {
    week: string
    component_key: string
    component_name: string
    component_set_key?: string
    component_set_name?: string
    detachments: number
    insertions: number
  }
  export type LibraryAnalyticsComponentActionsByTeam = {
    week: string
    team_name: string
    workspace_name?: string
    detachments: number
    insertions: number
  }
  export type LibraryAnalyticsComponentUsagesByAsset = {
    component_key: string
    component_name: string
    component_set_key?: string
    component_set_name?: string
    usages: number
    teams_using: number
    files_using: number
  }
  export type LibraryAnalyticsComponentUsagesByFile = {
    file_name: string
    team_name: string
    workspace_name?: string
    usages: number
  }
  export type LibraryAnalyticsStyleActionsByAsset = {
    week: string
    style_key: string
    style_name: string
    style_type: string
    detachments: number
    insertions: number
  }
  export type LibraryAnalyticsStyleActionsByTeam = {
    week: string
    team_name: string
    workspace_name?: string
    detachments: number
    insertions: number
  }
  export type LibraryAnalyticsStyleUsagesByAsset = {
    style_key: string
    style_name: string
    style_type: string
    usages: number
    teams_using: number
    files_using: number
  }
  export type LibraryAnalyticsStyleUsagesByFile = {
    file_name: string
    team_name: string
    workspace_name?: string
    usages: number
  }
  export type LibraryAnalyticsVariableActionsByAsset = {
    week: string
    variable_key: string
    variable_name: string
    variable_type: string
    collection_key: string
    collection_name: string
    detachments: number
    insertions: number
  }
  export type LibraryAnalyticsVariableActionsByTeam = {
    week: string
    team_name: string
    workspace_name?: string
    detachments: number
    insertions: number
  }
  export type LibraryAnalyticsVariableUsagesByAsset = {
    variable_key: string
    variable_name: string
    variable_type: string
    collection_key: string
    collection_name: string
    usages: number
    teams_using: number
    files_using: number
  }
  export type LibraryAnalyticsVariableUsagesByFile = {
    file_name: string
    team_name: string
    workspace_name?: string
    usages: number
  }
  export type ResponsePagination = {
    prev_page?: string
    next_page?: string
  }
  export type ResponseCursor = {
    before?: number
    after?: number
  }
  export type ErrorResponsePayloadWithErrMessage = {
    status: number
    err: string
  }
  export type ErrorResponsePayloadWithErrorBoolean = {
    error: true
    status: number
    message: string
  }
  export type GetFileResponse = {
    name: string
    role: 'owner' | 'editor' | 'viewer'
    lastModified: string
    editorType: 'figma' | 'figjam'
    thumbnailUrl?: string
    version: string
    document: DocumentNode
    components: { [key: string]: Component }
    componentSets: { [key: string]: ComponentSet }
    schemaVersion: number
    styles: { [key: string]: Style }
    linkAccess?: string
    mainFileKey?: string
    branches?: {
      key: string
      name: string
      thumbnail_url: string
      last_modified: string
    }[]
  }
  export type GetFileNodesResponse = {
    name: string
    role: 'owner' | 'editor' | 'viewer'
    lastModified: string
    editorType: 'figma' | 'figjam'
    thumbnailUrl: string
    version: string
    nodes: {
      [key: string]: {
        document: Node
        components: { [key: string]: Component }
        componentSets: { [key: string]: ComponentSet }
        schemaVersion: number
        styles: { [key: string]: Style }
      }
    }
  }
  export type GetImagesResponse = {
    err: null
    images: { [key: string]: string | null }
  }
  export type GetImageFillsResponse = {
    error: false
    status: 200
    meta: {
      images: { [key: string]: string }
    }
  }
  export type GetTeamProjectsResponse = {
    name: string
    projects: Project[]
  }
  export type GetProjectFilesResponse = {
    name: string
    files: {
      key: string
      name: string
      thumbnail_url?: string
      last_modified: string
    }[]
  }
  export type GetFileVersionsResponse = {
    versions: Version[]
    pagination: ResponsePagination
  }
  export type GetCommentsResponse = {
    comments: Comment[]
  }
  export type PostCommentResponse = Comment
  export type DeleteCommentResponse = {
    status: 200
    error: false
  }
  export type GetCommentReactionsResponse = {
    reactions: Reaction[]
    pagination: ResponsePagination
  }
  export type PostCommentReactionResponse = {
    status: 200
    error: false
  }
  export type DeleteCommentReactionResponse = {
    status: 200
    error: false
  }
  export type GetMeResponse = User & {
    email: string
  }
  export type GetTeamComponentsResponse = {
    status: 200
    error: false
    meta: {
      components: PublishedComponent[]
      cursor?: ResponseCursor
    }
  }
  export type GetFileComponentsResponse = {
    status: 200
    error: false
    meta: { components: PublishedComponent[] }
  }
  export type GetComponentResponse = {
    status: 200
    error: false
    meta: PublishedComponent
  }
  export type GetTeamComponentSetsResponse = {
    status: 200
    error: false
    meta: {
      component_sets: PublishedComponentSet[]
      cursor?: ResponseCursor
    }
  }
  export type GetFileComponentSetsResponse = {
    status: 200
    error: false
    meta: { component_sets: PublishedComponentSet[] }
  }
  export type GetComponentSetResponse = {
    status: 200
    error: false
    meta: PublishedComponentSet
  }
  export type GetTeamStylesResponse = {
    status: 200
    error: false
    meta: {
      styles: PublishedStyle[]
      cursor?: ResponseCursor
    }
  }
  export type GetFileStylesResponse = {
    status: 200
    error: false
    meta: { styles: PublishedStyle[] }
  }
  export type GetStyleResponse = {
    status: 200
    error: false
    meta: PublishedStyle
  }
  export type PostWebhookResponse = WebhookV2
  export type GetWebhookResponse = WebhookV2
  export type PutWebhookResponse = WebhookV2
  export type DeleteWebhookResponse = WebhookV2
  export type GetTeamWebhooksResponse = {
    webhooks: WebhookV2[]
  }
  export type GetWebhookRequestsResponse = {
    requests: WebhookV2Request[]
  }
  export type GetActivityLogsResponse = {
    status?: 200
    error?: false
    meta?: {
      activity_logs?: ActivityLog[]
      cursor?: string
      next_page?: boolean
    }
  }
  export type GetPaymentsResponse = {
    status: 200
    error: false
    meta: PaymentInformation
  }
  export type GetLocalVariablesResponse = {
    status: 200
    error: false
    meta: {
      variables: { [key: string]: LocalVariable }
      variableCollections: { [key: string]: LocalVariableCollection }
    }
  }
  export type GetPublishedVariablesResponse = {
    status: 200
    error: false
    meta: {
      variables: { [key: string]: PublishedVariable }
      variableCollections: { [key: string]: PublishedVariableCollection }
    }
  }
  export type PostVariablesResponse = {
    status: 200
    error: false
    meta: {
      tempIdToRealId: { [key: string]: string }
    }
  }
  export type GetDevResourcesResponse = {
    dev_resources: DevResource[]
  }
  export type PostDevResourcesResponse = {
    links_created: DevResource[]
    errors?: {
      file_key?: string | null
      node_id?: string | null
      error: string
    }[]
  }
  export type PutDevResourcesResponse = {
    links_updated?: DevResource[]
    errors?: {
      id?: string
      error: string
    }[]
  }
  export type DeleteDevResourceResponse = void
  export type GetLibraryAnalyticsComponentActionsResponse = {
    rows: LibraryAnalyticsComponentActionsByAsset[] | LibraryAnalyticsComponentActionsByTeam[]
    next_page: boolean
    cursor?: string
  }
  export type GetLibraryAnalyticsComponentUsagesResponse = {
    rows: LibraryAnalyticsComponentUsagesByAsset[] | LibraryAnalyticsComponentUsagesByFile[]
    next_page: boolean
    cursor?: string
  }
  export type GetLibraryAnalyticsStyleActionsResponse = {
    rows: LibraryAnalyticsStyleActionsByAsset[] | LibraryAnalyticsStyleActionsByTeam[]
    next_page: boolean
    cursor?: string
  }
  export type GetLibraryAnalyticsStyleUsagesResponse = {
    rows: LibraryAnalyticsStyleUsagesByAsset[] | LibraryAnalyticsStyleUsagesByFile[]
    next_page: boolean
    cursor?: string
  }
  export type GetLibraryAnalyticsVariableActionsResponse = {
    rows: LibraryAnalyticsVariableActionsByAsset[] | LibraryAnalyticsVariableActionsByTeam[]
    next_page: boolean
    cursor?: string
  }
  export type GetLibraryAnalyticsVariableUsagesResponse = {
    rows: LibraryAnalyticsVariableUsagesByAsset[] | LibraryAnalyticsVariableUsagesByFile[]
    next_page: boolean
    cursor?: string
  }
  export type BadRequestErrorResponseWithErrMessage = ErrorResponsePayloadWithErrMessage & {
    status: 400
  }
  export type BadRequestErrorResponseWithErrorBoolean = ErrorResponsePayloadWithErrorBoolean & {
    status: 400
  }
  export type UnauthorizedErrorResponseWithErrorBoolean = ErrorResponsePayloadWithErrorBoolean & {
    status: 401
  }
  export type ForbiddenErrorResponseWithErrMessage = ErrorResponsePayloadWithErrMessage & {
    status: 403
  }
  export type ForbiddenErrorResponseWithErrorBoolean = ErrorResponsePayloadWithErrorBoolean & {
    status: 403
  }
  export type NotFoundErrorResponseWithErrMessage = ErrorResponsePayloadWithErrMessage & {
    status: 404
  }
  export type NotFoundErrorResponseWithErrorBoolean = ErrorResponsePayloadWithErrorBoolean & {
    status: 404
  }
  export type TooManyRequestsErrorResponseWithErrMessage = ErrorResponsePayloadWithErrMessage & {
    status: 429
  }
  export type TooManyRequestsErrorResponseWithErrorBoolean = ErrorResponsePayloadWithErrorBoolean & {
    status: 429
  }
  export type InternalServerErrorResponseWithErrMessage = ErrorResponsePayloadWithErrMessage & {
    status: 500
  }
  export type InternalServerErrorResponseWithErrorBoolean = ErrorResponsePayloadWithErrorBoolean & {
    status: 500
  }
  export type GetFilePathParams = {
    file_key: string
  }
  export type GetFileQueryParams = {
    version?: string
    ids?: string
    depth?: number
    geometry?: string
    plugin_data?: string
    branch_data?: boolean
  }
  export type GetFileNodesPathParams = {
    file_key: string
  }
  export type GetFileNodesQueryParams = {
    ids: string
    version?: string
    depth?: number
    geometry?: string
    plugin_data?: string
  }
  export type GetImagesPathParams = {
    file_key: string
  }
  export type GetImagesQueryParams = {
    ids: string
    version?: string
    scale?: number
    format?: 'jpg' | 'png' | 'svg' | 'pdf'
    svg_outline_text?: boolean
    svg_include_id?: boolean
    svg_include_node_id?: boolean
    svg_simplify_stroke?: boolean
    contents_only?: boolean
    use_absolute_bounds?: boolean
  }
  export type GetImageFillsPathParams = {
    file_key: string
  }
  export type GetTeamProjectsPathParams = {
    team_id: string
  }
  export type GetProjectFilesPathParams = {
    project_id: string
  }
  export type GetProjectFilesQueryParams = {
    branch_data?: boolean
  }
  export type GetFileVersionsPathParams = {
    file_key: string
  }
  export type GetFileVersionsQueryParams = {
    page_size?: number
    before?: number
    after?: number
  }
  export type GetCommentsPathParams = {
    file_key: string
  }
  export type GetCommentsQueryParams = {
    as_md?: boolean
  }
  export type PostCommentPathParams = {
    file_key: string
  }
  export type PostCommentRequestBody = {
    message: string
    comment_id?: string
    client_meta?: Vector | FrameOffset | Region | FrameOffsetRegion
  }
  export type DeleteCommentPathParams = {
    file_key: string
    comment_id: string
  }
  export type DeleteCommentReactionPathParams = {
    file_key: string
    comment_id: string
  }
  export type DeleteCommentReactionQueryParams = { emoji: Emoji }
  export type GetCommentReactionsPathParams = {
    file_key: string
    comment_id: string
  }
  export type GetCommentReactionsQueryParams = {
    cursor?: string
  }
  export type PostCommentReactionPathParams = {
    file_key: string
    comment_id: string
  }
  export type PostCommentReactionRequestBody = { emoji: Emoji }
  export type GetTeamComponentsPathParams = {
    team_id: string
  }
  export type GetTeamComponentsQueryParams = {
    page_size?: number
    after?: number
    before?: number
  }
  export type GetFileComponentsPathParams = {
    file_key: string
  }
  export type GetComponentPathParams = {
    key: string
  }
  export type GetTeamComponentSetsPathParams = {
    team_id: string
  }
  export type GetTeamComponentSetsQueryParams = {
    page_size?: number
    after?: number
    before?: number
  }
  export type GetFileComponentSetsPathParams = {
    file_key: string
  }
  export type GetComponentSetPathParams = {
    key: string
  }
  export type GetTeamStylesPathParams = {
    team_id: string
  }
  export type GetTeamStylesQueryParams = {
    page_size?: number
    after?: number
    before?: number
  }
  export type GetFileStylesPathParams = {
    file_key: string
  }
  export type GetStylePathParams = {
    key: string
  }
  export type PostWebhookRequestBody = {
    event_type: WebhookV2Event
    team_id: string
    endpoint: string
    passcode: string
    status?: WebhookV2Status
    description?: string
  }
  export type DeleteWebhookPathParams = {
    webhook_id: string
  }
  export type GetWebhookPathParams = {
    webhook_id: string
  }
  export type PutWebhookPathParams = {
    webhook_id: string
  }
  export type PutWebhookRequestBody = {
    event_type: WebhookV2Event
    endpoint: string
    passcode: string
    status?: WebhookV2Status
    description?: string
  }
  export type GetTeamWebhooksPathParams = {
    team_id: string
  }
  export type GetWebhookRequestsPathParams = {
    webhook_id: string
  }
  export type GetActivityLogsQueryParams = {
    events?: string
    start_time?: number
    end_time?: number
    limit?: number
    order?: 'asc' | 'desc'
  }
  export type GetPaymentsQueryParams = {
    plugin_payment_token?: string
    user_id?: number
    community_file_id?: number
    plugin_id?: number
    widget_id?: number
  }
  export type GetLocalVariablesPathParams = {
    file_key: string
  }
  export type GetPublishedVariablesPathParams = {
    file_key: string
  }
  export type PostVariablesPathParams = {
    file_key: string
  }
  export type PostVariablesRequestBody = {
    variableCollections?: VariableCollectionChange[]
    variableModes?: VariableModeChange[]
    variables?: VariableChange[]
    variableModeValues?: VariableModeValue[]
  }
  export type GetDevResourcesPathParams = {
    file_key: string
  }
  export type GetDevResourcesQueryParams = {
    node_ids?: string
  }
  export type PostDevResourcesRequestBody = {
    dev_resources: {
      name: string
      url: string
      file_key: string
      node_id: string
    }[]
  }
  export type PutDevResourcesRequestBody = {
    dev_resources: {
      id: string
      name?: string
      url?: string
    }[]
  }
  export type DeleteDevResourcePathParams = {
    file_key: string
    dev_resource_id: string
  }
  export type GetLibraryAnalyticsComponentActionsPathParams = {
    file_key: string
  }
  export type GetLibraryAnalyticsComponentActionsQueryParams = {
    cursor?: string
    group_by: 'component' | 'team'
    start_date?: string
    end_date?: string
  }
  export type GetLibraryAnalyticsComponentUsagesPathParams = {
    file_key: string
  }
  export type GetLibraryAnalyticsComponentUsagesQueryParams = {
    cursor?: string
    group_by: 'component' | 'file'
  }
  export type GetLibraryAnalyticsStyleActionsPathParams = {
    file_key: string
  }
  export type GetLibraryAnalyticsStyleActionsQueryParams = {
    cursor?: string
    group_by: 'style' | 'team'
    start_date?: string
    end_date?: string
  }
  export type GetLibraryAnalyticsStyleUsagesPathParams = {
    file_key: string
  }
  export type GetLibraryAnalyticsStyleUsagesQueryParams = {
    cursor?: string
    group_by: 'style' | 'file'
  }
  export type GetLibraryAnalyticsVariableActionsPathParams = {
    file_key: string
  }
  export type GetLibraryAnalyticsVariableActionsQueryParams = {
    cursor?: string
    group_by: 'variable' | 'team'
    start_date?: string
    end_date?: string
  }
  export type GetLibraryAnalyticsVariableUsagesPathParams = {
    file_key: string
  }
  export type GetLibraryAnalyticsVariableUsagesQueryParams = {
    cursor?: string
    group_by: 'variable' | 'file'
  }
</file>

<file path="packages/backend/src/index.ts">
export { flutterMain } from "./flutter/flutterMain";
export { htmlMain } from "./html/htmlMain";
export { tailwindMain } from "./tailwind/tailwindMain";
export { swiftuiMain } from "./swiftui/swiftuiMain";
export { generateTailwindv4FromFigma } from "./api/tailwindv4Api";
export { run } from "./code";
export * from "./messaging";
</file>

<file path="packages/plugin-ui/src/components/ExpandIcon.tsx">
import React from "react";
const ExpandIcon = (props: { size: number }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width={props.size}
    height={props.size}
    fill="currentColor"
    viewBox="0 0 256 256"
  >
    <path d="M224,128a8,8,0,0,1-8,8H40a8,8,0,0,1,0-16H216A8,8,0,0,1,224,128ZM101.66,53.66,120,35.31V96a8,8,0,0,0,16,0V35.31l18.34,18.35a8,8,0,0,0,11.32-11.32l-32-32a8,8,0,0,0-11.32,0l-32,32a8,8,0,0,0,11.32,11.32Zm52.68,148.68L136,220.69V160a8,8,0,0,0-16,0v60.69l-18.34-18.35a8,8,0,0,0-11.32,11.32l32,32a8,8,0,0,0,11.32,0l32-32a8,8,0,0,0-11.32-11.32Z"></path>
  </svg>
);
export default ExpandIcon;
</file>

<file path="packages/plugin-ui/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="packages/backend/src/common/commonFormatAttributes.ts">
import { lowercaseFirstLetter } from "./lowercaseFirstLetter";
export const getClassLabel = (isJSX: boolean = false) =>
  isJSX ? "className" : "class";
export const joinStyles = (styles: string[], isJSX: boolean) =>
  styles.map((s) => s.trim()).join(isJSX ? ", " : "; ");
export const formatStyleAttribute = (
  styles: string[],
  isJSX: boolean,
): string => {
  const trimmedStyles = joinStyles(styles, isJSX);
  if (trimmedStyles === "") return "";
  return ` style=${isJSX ? `{{${trimmedStyles}}}` : `"${trimmedStyles}"`}`;
};
export const formatDataAttribute = (label: string, value?: string) =>
  ` data-${lowercaseFirstLetter(label).replace(" ", "-")}${value === undefined ? `` : `="${value}"`}`;
export const formatClassAttribute = (
  classes: string[],
  isJSX: boolean,
): string =>
  classes.length === 0 ? "" : ` ${getClassLabel(isJSX)}="${classes.join(" ")}"`;
</file>

<file path="packages/backend/src/flutter/builderImpl/flutterAutoLayout.ts">
export const getMainAxisAlignment = (
  node: InferredAutoLayoutResult,
): string => {
  switch (node.primaryAxisAlignItems) {
    case undefined:
    case "MIN":
      return "MainAxisAlignment.start";
    case "CENTER":
      return "MainAxisAlignment.center";
    case "MAX":
      return "MainAxisAlignment.end";
    case "SPACE_BETWEEN":
      return "MainAxisAlignment.spaceBetween";
  }
};
export const getCrossAxisAlignment = (
  node: InferredAutoLayoutResult,
): string => {
  switch (node.counterAxisAlignItems) {
    case undefined:
    case "MIN":
      return "CrossAxisAlignment.start";
    case "CENTER":
      return "CrossAxisAlignment.center";
    case "MAX":
      return "CrossAxisAlignment.end";
    case "BASELINE":
      return "CrossAxisAlignment.baseline";
  }
};
export const getWrapAlignment = (
  node: InferredAutoLayoutResult,
): string => {
  switch (node.primaryAxisAlignItems) {
    case undefined:
    case "MIN":
      return "WrapAlignment.start";
    case "CENTER":
      return "WrapAlignment.center";
    case "MAX":
      return "WrapAlignment.end";
    case "SPACE_BETWEEN":
      return "WrapAlignment.spaceBetween";
  }
};
export const getWrapRunAlignment = (
  node: InferredAutoLayoutResult,
): string => {
  if (node.counterAxisAlignContent == "SPACE_BETWEEN") {
    return "WrapAlignment.spaceBetween";
  }
  switch (node.counterAxisAlignItems) {
    case undefined:
    case "MIN":
      return "WrapAlignment.start";
    case "CENTER":
    case "BASELINE":
      return "WrapAlignment.center";
    case "MAX":
      return "WrapAlignment.end";
  }
};
const getFlex = (
  node: SceneNode,
  autoLayout: InferredAutoLayoutResult,
): string =>
  node.parent &&
  "layoutMode" in node.parent &&
  node.parent.layoutMode === autoLayout.layoutMode
    ? "MainAxisSize.max"
    : "MainAxisSize.min";
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiColor.ts">
import { retrieveTopFill } from "../../common/retrieveFill";
import { gradientAngle } from "../../common/color";
import { nearestValue } from "../../tailwind/conversionTables";
import { numberToFixedString } from "../../common/numToAutoFixed";
export const swiftUISolidColor = (fill: Paint): string => {
  if (fill && fill.type === "SOLID") {
    return swiftuiColor(fill.color, fill.opacity ?? 1.0);
  } else if (
    fill &&
    (fill.type === "GRADIENT_LINEAR" ||
      fill.type === "GRADIENT_ANGULAR" ||
      fill.type === "GRADIENT_RADIAL")
  ) {
    if (fill.gradientStops.length > 0) {
      return swiftuiColor(fill.gradientStops[0].color, fill.opacity ?? 1.0);
    }
  }
  return "";
};
/**
 * Retrieve the SwiftUI solid color when existent, otherwise ""
 * @param node SceneNode containing the property to examine
 * @param propertyPath Property path to extract fills from (e.g., 'fills', 'strokes') or direct fills array
 */
export const swiftuiSolidColor = (
  node: SceneNode,
  propertyPath: string | keyof SceneNode,
): string => {
  let fills: ReadonlyArray<Paint> | PluginAPI["mixed"];
  fills = node[propertyPath as keyof SceneNode] as
    | ReadonlyArray<Paint>
    | PluginAPI["mixed"];
  return swiftuiSolidColorFromDirectFills(fills);
};
export const swiftuiSolidColorFromDirectFills = (
  fills: ReadonlyArray<Paint> | PluginAPI["mixed"],
): string => {
  const fill = retrieveTopFill(fills);
  if (fill && fill.type === "SOLID") {
    const opacity = fill.opacity ?? 1.0;
    return swiftuiColor(fill.color, opacity);
  } else if (fill?.type === "GRADIENT_LINEAR") {
    return swiftuiRGBAColor(fill.gradientStops[0].color);
  } else if (fill?.type === "IMAGE") {
    return swiftuiColor(
      {
        r: 0.5,
        g: 0.23,
        b: 0.27,
      },
      0.5,
    );
  }
  return "";
};
/**
 * Generate a SwiftUI gradient from a GradientPaint object
 * @param fill The gradient fill object from Figma
 * @returns SwiftUI gradient code as a string
 */
export const swiftuiGradient = (fill: GradientPaint): string => {
  if (fill.type !== "GRADIENT_LINEAR") {
    return ""; // Only handling linear gradients here for simplicity
  }
  const angle = gradientAngle(fill);
  const direction = gradientDirection(angle);
  const colors = fill.gradientStops
    .map((d) => swiftuiColor(d.color, d.color.a))
    .join(", ");
  return `LinearGradient(gradient: Gradient(colors: [${colors}]), ${direction})`;
};
const gradientDirection = (angle: number): string => {
  switch (nearestValue(angle, [-180, -135, -90, -45, 0, 45, 90, 135, 180])) {
    case 0:
      return "startPoint: .leading, endPoint: .trailing";
    case 45:
      return "startPoint: .topLeading, endPoint: .bottomTrailing";
    case 90:
      return "startPoint: .top, endPoint: .bottom";
    case 135:
      return "startPoint: .topTrailing, endPoint: .bottomLeading";
    case -45:
      return "startPoint: .bottomLeading, endPoint: .topTrailing";
    case -90:
      return "startPoint: .bottom, endPoint: .top";
    case -135:
      return "startPoint: .bottomTrailing, endPoint: .topLeading";
    default:
      return "startPoint: .trailing, endPoint: .leading";
  }
};
export const swiftuiRGBAColor = (color: RGBA) => swiftuiColor(color, color.a);
export const swiftuiColor = (color: RGB, opacity: number): string => {
  if (color.r + color.g + color.b === 0 && opacity === 1) {
    return ".black";
  }
  if (color.r + color.g + color.b === 3 && opacity === 1) {
    return ".white";
  }
  const r = `red: ${numberToFixedString(color.r)}`;
  const g = `green: ${numberToFixedString(color.g)}`;
  const b = `blue: ${numberToFixedString(color.b)}`;
  const opacityAttr =
    opacity !== 1.0 ? `.opacity(${numberToFixedString(opacity)})` : "";
  return `Color(${r}, ${g}, ${b})${opacityAttr}`;
};
</file>

<file path="packages/backend/src/swiftui/builderImpl/swiftuiSize.ts">
import { nodeSize } from "../../common/nodeWidthHeight";
import { numberToFixedString } from "../../common/numToAutoFixed";
export const swiftuiSize = (
  node: SceneNode,
): { width: string; height: string; constraints: string[] } => {
  const size = nodeSize(node);
  const constraintProps: string[] = [];
  let width = "";
  let height = "";
  // Handle width and height
  if (typeof size.width === "number") {
    width = `width: ${numberToFixedString(size.width)}`;
  }
  if (typeof size.height === "number") {
    height = `height: ${numberToFixedString(size.height)}`;
  }
  if (node.minWidth !== undefined && node.minWidth !== null) {
    constraintProps.push(`minWidth: ${numberToFixedString(node.minWidth)}`);
  }
  if (node.maxWidth !== undefined && node.maxWidth !== null) {
    constraintProps.push(`maxWidth: ${numberToFixedString(node.maxWidth)}`);
  }
  if (node.minHeight !== undefined && node.minHeight !== null) {
    constraintProps.push(`minHeight: ${numberToFixedString(node.minHeight)}`);
  }
  if (node.maxHeight !== undefined && node.maxHeight !== null) {
    constraintProps.push(`maxHeight: ${numberToFixedString(node.maxHeight)}`);
  }
  return {
    width,
    height,
    constraints: constraintProps,
  };
};
</file>

<file path="packages/backend/src/swiftui/swiftuiTextBuilder.ts">
import { numberToFixedString } from "../common/numToAutoFixed";
import {
  commonLetterSpacing,
  commonLineHeight,
} from "../common/commonTextHeightSpacing";
import { SwiftuiDefaultBuilder } from "./swiftuiDefaultBuilder";
import { swiftuiWeightMatcher } from "./builderImpl/swiftuiTextWeight";
import { swiftuiSize } from "./builderImpl/swiftuiSize";
import { SwiftUIElement } from "./builderImpl/swiftuiParser";
import { parseTextAsCode } from "../flutter/flutterTextBuilder";
import { swiftuiSolidColorFromDirectFills } from "./builderImpl/swiftuiColor";
import { StyledTextSegmentSubset } from "types";
export class SwiftuiTextBuilder extends SwiftuiDefaultBuilder {
  node?: TextNode;
  modifiers: string[] = [];
  constructor(kind: string = "Text") {
    super(kind);
  }
  reset(): void {
    this.modifiers = [];
  }
  textAutoSize(node: TextNode): this {
    this.modifiers.push(this.wrapTextAutoResize(node));
    return this;
  }
  textDecoration(textDecoration: TextDecoration): string | null {
    switch (textDecoration) {
      case "UNDERLINE":
        return "underline";
      case "STRIKETHROUGH":
        return "strikethrough";
      case "NONE":
        return null;
    }
  }
  textColor(fills: Paint[]): string {
    const fillColor = swiftuiSolidColorFromDirectFills(fills);
    if (fillColor) {
      return fillColor;
    }
    return "";
  }
  textStyle(style: string): string | null {
    // https://developer.apple.com/documentation/swiftui/text/italic()
    if (style.toLowerCase().match("italic")) {
      return "italic";
    }
    return null;
  }
  fontWeight(fontWeight: number): string {
    if (fontWeight !== 400) {
      const weight = swiftuiWeightMatcher(fontWeight);
      return `.weight(${weight})`;
    }
    return "";
  }
  textStyle2 = (node: TextNode): this => {
    // todo might be a good idea to calculate the width based on the font size and check if view is really multi-line
    if (node.textAutoResize !== "WIDTH_AND_HEIGHT") {
      if (node.textAlignHorizontal === "CENTER") {
        this.modifiers.push(".multilineTextAlignment(.center)");
      } else if (node.textAlignHorizontal === "RIGHT") {
        this.modifiers.push(".multilineTextAlignment(.trailing)");
      }
    }
    return this;
  };
  createText(node: TextNode): this {
    this.node = node;
    let alignHorizontal =
      node.textAlignHorizontal?.toString()?.toLowerCase() ?? "left";
    alignHorizontal =
      alignHorizontal === "justified" ? "justify" : alignHorizontal;
    const segments = this.getTextSegments(node, node.characters);
    if (segments) {
      this.element = segments;
    } else {
      this.element = new SwiftUIElement("Text()");
    }
    return this;
  }
  getTextSegments(node: TextNode, characters: string): SwiftUIElement | null {
    const segments = (node as any)
      .styledTextSegments as StyledTextSegmentSubset[];
    if (!segments) {
      return null;
    }
    const segment = segments[0];
    const fontSize = numberToFixedString(segment.fontSize);
    const fontFamily = segment.fontName.family;
    const fontWeight = this.fontWeight(segment.fontWeight);
    const lineHeight = this.lineHeight(segment.lineHeight, segment.fontSize);
    const letterSpacing = this.letterSpacing(
      segment.letterSpacing,
      segment.fontSize,
    );
    let updatedText = parseTextAsCode(characters);
    if (segment.textCase === "LOWER") {
      updatedText = characters.toLowerCase();
    } else if (segment.textCase === "UPPER") {
      updatedText = characters.toUpperCase();
    }
    const element = new SwiftUIElement(
      `Text(${parseTextAsCode(`"${characters}"`)})`,
    )
      .addModifier([
        "font",
        `Font.custom("${fontFamily}", size: ${fontSize})${
          fontWeight ? `${fontWeight}` : ""
        }`,
      ])
      .addModifier(["tracking", letterSpacing])
      .addModifier(["lineSpacing", lineHeight])
      .addModifier([this.textDecoration(segment.textDecoration), ""])
      .addModifier([this.textStyle(segment.fontName.style), ""])
      .addModifier(["foregroundColor", this.textColor(segment.fills)]);
    const blurMod = this.textBlur();
    if (blurMod !== "") {
      element.addModifier([blurMod, ""]);
    }
    const shadowMod = this.textShadow();
    if (shadowMod !== "") {
      element.addModifier([shadowMod, ""]);
    }
    return element;
    // });
  }
  letterSpacing = (
    letterSpacing: LetterSpacing,
    fontSize: number,
  ): string | null => {
    const value = commonLetterSpacing(letterSpacing, fontSize);
    if (value > 0) {
      return numberToFixedString(value);
    }
    return null;
  };
  // the difference between kerning and tracking is that tracking spaces everything, kerning keeps lignatures,
  // Figma spaces everything, so we are going to use tracking.
  lineHeight = (lineHeight: LineHeight, fontSize: number): string | null => {
    const value = commonLineHeight(lineHeight, fontSize);
    if (value > 0) {
      return numberToFixedString(value);
    }
    return null;
  };
  wrapTextAutoResize = (node: TextNode): string => {
    const { width, height, constraints } = swiftuiSize(node);
    let comp: string[] = [];
    switch (node.textAutoResize) {
      case "WIDTH_AND_HEIGHT":
        break;
      case "HEIGHT":
        comp.push(width);
        break;
      case "NONE":
      case "TRUNCATE":
        comp.push(width, height);
        break;
    }
    comp.push(...constraints);
    if (comp.length > 0) {
      const align = this.textAlignment(node);
      return `.frame(${comp.join(", ")}${align})`;
    }
    return "";
  };
  // SwiftUI has two alignments for Text, when it is a single line and when it is multiline. This one is for single line.
  textAlignment = (node: TextNode): string => {
    let hAlign = "";
    if (node.textAlignHorizontal === "LEFT") {
      hAlign = "leading";
    } else if (node.textAlignHorizontal === "RIGHT") {
      hAlign = "trailing";
    }
    let vAlign = "";
    if (node.textAlignVertical === "TOP") {
      vAlign = "top";
    } else if (node.textAlignVertical === "BOTTOM") {
      vAlign = "bottom";
    }
    if (hAlign && !vAlign) {
      return `, alignment: .${hAlign}`;
    } else if (!hAlign && vAlign) {
      return `, alignment: .${vAlign}`;
    } else if (hAlign && vAlign) {
      const hAlignUpper = hAlign.charAt(0).toUpperCase() + hAlign.slice(1);
      return `, alignment: .${vAlign}${hAlignUpper}`;
    }
    return "";
  };
  textBlur = (): string => {
    if (this.node && this.node.effects) {
      const blurEffect = this.node.effects.find(
        (effect) =>
          effect.type === "LAYER_BLUR" &&
          effect.visible !== false &&
          effect.radius > 0,
      );
      if (blurEffect) {
        return `.blur(radius: ${blurEffect.radius})`;
      }
    }
    return "";
  };
  textShadow = (): string => {
    if (this.node && this.node.effects) {
      const dropShadow = this.node.effects.find(
        (effect) => effect.type === "DROP_SHADOW" && effect.visible !== false,
      );
      if (dropShadow) {
        const ds = dropShadow as DropShadowEffect;
        const offsetX = Math.round(ds.offset.x);
        const offsetY = Math.round(ds.offset.y);
        const blurRadius = Math.round(ds.radius);
        return `.shadow(color: Color(red: ${ds.color.r.toFixed(
          2,
        )}, green: ${ds.color.g.toFixed(2)}, blue: ${ds.color.b.toFixed(
          2,
        )}, opacity: ${ds.color.a.toFixed(
          2,
        )}), radius: ${blurRadius}, x: ${offsetX}, y: ${offsetY})`;
      }
    }
    return "";
  };
}
</file>

<file path="packages/backend/src/tailwind/builderImpl/tailwindAutoLayout.ts">
import { pxToLayoutSize } from "../conversionTables";
const getFlexDirection = (node: InferredAutoLayoutResult): string =>
  node.layoutMode === "HORIZONTAL" ? "" : "flex-col";
const getJustifyContent = (node: InferredAutoLayoutResult): string => {
  switch (node.primaryAxisAlignItems) {
    case undefined:
    case "MIN":
      return "justify-start";
    case "CENTER":
      return "justify-center";
    case "MAX":
      return "justify-end";
    case "SPACE_BETWEEN":
      return "justify-between";
  }
};
const getAlignItems = (node: InferredAutoLayoutResult): string => {
  switch (node.counterAxisAlignItems) {
    case undefined:
    case "MIN":
      return "items-start";
    case "CENTER":
      return "items-center";
    case "MAX":
      return "items-end";
    case "BASELINE":
      return "items-baseline";
  }
};
const getGap = (node: InferredAutoLayoutResult): string =>
  node.itemSpacing > 0 && node.primaryAxisAlignItems !== "SPACE_BETWEEN"
    ? `gap-${pxToLayoutSize(node.itemSpacing)}`
    : "";
const getFlexWrap = (node: InferredAutoLayoutResult): string =>
  node.layoutWrap === "WRAP" ? "flex-wrap" : "";
const getAlignContent = (node: InferredAutoLayoutResult): string => {
  if (node.layoutWrap !== "WRAP") return "";
  switch (node.counterAxisAlignItems) {
    case undefined:
    case "MIN":
      return "content-start";
    case "CENTER":
      return "content-center";
    case "MAX":
      return "content-end";
    case "BASELINE":
      return "content-baseline";
    default:
      return "content-normal";
  }
};
const getFlex = (
  node: SceneNode,
  autoLayout: InferredAutoLayoutResult,
): string =>
  node.parent &&
  "layoutMode" in node.parent &&
  node.parent.layoutMode === autoLayout.layoutMode
    ? "flex"
    : "inline-flex";
export const tailwindAutoLayoutProps = (
  node: SceneNode,
  autoLayout: InferredAutoLayoutResult,
): string => {
  const classes = [
    getFlex(node, autoLayout),
    getFlexDirection(autoLayout),
    getJustifyContent(autoLayout),
    getAlignItems(autoLayout),
    getGap(autoLayout),
    getFlexWrap(autoLayout),
    getAlignContent(autoLayout),
  ].filter(Boolean);
  return classes.join(" ");
};
</file>

<file path="packages/plugin-ui/src/components/TailwindSettings.tsx">
import { ChevronDown, ChevronRight, HelpCircle, Check } from "lucide-react";
import { useState, useRef, useEffect } from "react";
import { PluginSettings } from "types";
import FormField from "./CustomPrefixInput";
interface InputGroupProps {
  label: string;
  children: React.ReactNode;
}
const InputGroup: React.FC<InputGroupProps> = ({ label, children }) => (
  <div className="mb-2">
    <div className="flex items-center gap-1.5 mb-1.5">
      <label className="text-xs font-medium text-gray-700 dark:text-gray-300">
        {label}
      </label>
      {}
    </div>
    {children}
  </div>
);
interface InputWithTextProps {
  value: string | number;
  onChange: (value: number) => void;
  placeholder?: string;
  suffix?: string;
  min?: number;
  max?: number;
}
const InputWithText: React.FC<InputWithTextProps> = ({
  value,
  onChange,
  placeholder,
  suffix,
  min = 1,
  max = 100,
}) => {
  const [inputValue, setInputValue] = useState(String(value));
  const [isFocused, setIsFocused] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);
  // Update internal state when value changes (from parent)
  useEffect(() => {
    setInputValue(String(value));
    setHasChanges(false);
  }, [value]);
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputValue(newValue);
    // Check for non-numeric characters
    if (/[^0-9]/.test(newValue)) {
      setHasError(true);
      setErrorMessage("Only numbers are allowed");
      setHasChanges(newValue !== String(value));
      return;
    }
    const numValue = parseInt(newValue, 10);
    if (isNaN(numValue)) {
      setHasError(true);
      setErrorMessage("Please enter a valid number");
    } else if (numValue < min) {
      setHasError(true);
      setErrorMessage(`Minimum value is ${min}`);
    } else if (numValue > max) {
      setHasError(true);
      setErrorMessage(`Maximum value is ${max}`);
    } else {
      setHasError(false);
      setErrorMessage("");
    }
    setHasChanges(newValue !== String(value));
  };
  const applyChanges = () => {
    if (hasError) return;
    const numValue = parseInt(inputValue, 10);
    if (!isNaN(numValue) && numValue >= min && numValue <= max) {
      onChange(numValue);
      // Show success indicator briefly
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 1500);
      setHasChanges(false);
    }
  };
  const handleBlur = () => {
    setIsFocused(false);
  };
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      e.preventDefault();
      applyChanges();
      inputRef.current?.blur();
    }
  };
  return (
    <div className="flex flex-col w-full">
      {showSuccess && (
        <span className="text-xs text-green-500 flex items-center gap-1 animate-fade-in-out ml-auto mb-1">
          <Check className="w-3 h-3" /> Applied
        </span>
      )}
      <div className="flex items-start gap-2">
        <div className="flex-1 flex flex-col">
          <div className="flex items-center">
            <input
              ref={inputRef}
              type="text"
              value={inputValue}
              onChange={handleChange}
              onFocus={() => setIsFocused(true)}
              onBlur={handleBlur}
              onKeyDown={handleKeyDown}
              placeholder={placeholder}
              className={`p-1.5 px-2.5 w-full transition-all focus:outline-hidden ${
                suffix ? "rounded-l-md" : "rounded-md"
              } ${
                hasError
                  ? "border border-red-300 dark:border-red-700 bg-red-50 dark:bg-red-900/20"
                  : isFocused
                    ? "border border-green-400 dark:border-green-600 ring-1 ring-green-300 dark:ring-green-800 bg-white dark:bg-neutral-800"
                    : "border border-gray-300 dark:border-gray-600 bg-white dark:bg-neutral-800 hover:border-gray-400 dark:hover:border-gray-500"
              }`}
            />
            {suffix && (
              <span
                className="py-1.5 px-2.5 text-sm border border-l-0 border-gray-300 dark:border-gray-600
                bg-gray-100 dark:bg-gray-700 rounded-r-md text-gray-700 dark:text-gray-300"
              >
                {suffix}
              </span>
            )}
          </div>
          {hasError && (
            <p className="text-xs text-red-500 mt-1">{errorMessage}</p>
          )}
        </div>
        {hasChanges && (
          <button
            onClick={applyChanges}
            disabled={hasError}
            className={`px-3 py-1.5 rounded-md text-sm font-medium transition-colors ${
              hasError
                ? "bg-gray-200 text-gray-500 dark:bg-gray-800 dark:text-gray-600 cursor-not-allowed"
                : "bg-green-100 text-green-700 hover:bg-green-200 dark:bg-green-900/30 dark:text-green-400 dark:hover:bg-green-900/50"
            }`}
          >
            Done
          </button>
        )}
      </div>
    </div>
  );
};
interface TailwindSettingsProps {
  settings: PluginSettings | null;
  onPreferenceChanged: (
    key: keyof PluginSettings,
    value: boolean | string | number,
  ) => void;
}
export const TailwindSettings: React.FC<TailwindSettingsProps> = ({
  settings,
  onPreferenceChanged,
}) => {
  if (!settings) return null;
  const handleCustomPrefixChange = (newValue: string) => {
    onPreferenceChanged("customTailwindPrefix", newValue);
  };
  const handleBaseFontSizeChange = (value: number) => {
    onPreferenceChanged("baseFontSize", value);
  };
  return (
    <div className="mt-2">
      <p className="text-xs font-medium text-neutral-700 dark:text-neutral-300 mb-1">
        Advanced Settings
      </p>
      {}
      <div className="ml-2 pl-2 border-l border-neutral-200 dark:border-neutral-700">
        {}
        <div className="mb-3">
          <FormField
            label="Custom Class Prefix"
            initialValue={settings.customTailwindPrefix || ""}
            onValueChange={(d) => {
              handleCustomPrefixChange(d as any);
            }}
            placeholder="e.g., tw-"
            helpText="Add a prefix to all generated Tailwind classes. Useful for avoiding conflicts with existing CSS. Default is empty."
            type="text"
            showPreview={true}
          />
          <p className="text-xs text-neutral-500 mt-1">
            Add a custom prefix to all Tailwind classes (e.g. "tw-")
          </p>
        </div>
        {}
        <div className="mb-3">
          <FormField
            label="Base Font Size"
            initialValue={settings.baseFontSize || 16}
            onValueChange={(d) => {
              handleBaseFontSizeChange(d as any);
            }}
            placeholder="16"
            suffix="px"
            type="number"
            min={1}
            max={100}
          />
          <p className="text-xs text-neutral-500 mt-1">
            Use this value to calculate rem values (default: 16px)
          </p>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="packages/plugin-ui/tsconfig.json">
{
  "extends": "tsconfig/react-library.json",
  "include": ["src"],
  "exclude": ["dist", "build", "node_modules"]
}
</file>

<file path="manifest.json">
{
  "name": "Figma to Code [HTML, Tailwind, Flutter, SwiftUI]",
  "id": "842128343887142055",
  "api": "1.0.0",
  "main": "apps/plugin/dist/code.js",
  "ui": "apps/plugin/dist/index.html",
  "editorType": ["figma", "dev"],
  "capabilities": ["inspect", "codegen", "vscode"],
  "permissions": [],
  "documentAccess": "dynamic-page",
  "networkAccess": {
    "allowedDomains": ["https://placehold.co"]
  },
  "codegenLanguages": [
    { "label": "HTML", "value": "html" },
    { "label": "React (JSX)", "value": "html_jsx" },
    { "label": "Svelte", "value": "html_svelte" },
    { "label": "Styled Components", "value": "html_styled_components" },
    { "label": "Tailwind", "value": "tailwind" },
    { "label": "Tailwind (JSX)", "value": "tailwind_jsx" },
    { "label": "Flutter", "value": "flutter" },
    { "label": "SwiftUI", "value": "swiftUI" }
  ]
}
</file>

<file path="package.json">
{
  "name": "figma-to-code",
  "private": true,
  "packageManager": "pnpm@9.14.4",
  "scripts": {
    "build": "turbo run build",
    "build:watch": "turbo run build:watch",
    "dev": "turbo run dev --concurrency 20",
    "lint": "turbo run lint",
    "format": "prettier --write \"**/*.{ts,tsx,css,md}\""
  },
  "devDependencies": {
    "eslint": "^9.23.0",
    "eslint-config-custom": "workspace:*",
    "prettier": "^3.5.3",
    "turbo": "^2.4.4",
    "typescript": "^5.8.2"
  }
}
</file>

<file path="README.md">
<!-- <p align="center"><img src="assets/icon_256.png" alt="Figma to Code" height="128px"></p> -->

[![Figma to Code](assets/git_preview.png)](https://www.figma.com/community/plugin/842128343887142055)

# Figma to Code

<p align="center">
<a href="https://github.com/bernaferrari/FigmaToCode/actions/"><img src="https://github.com/bernaferrari/FigmaToCode/workflows/CI/badge.svg"/></a>
<a href="https://codecov.io/gh/bernaferrari/FigmaToCode"><img src="https://codecov.io/gh/bernaferrari/FigmaToCode/branch/master/graph/badge.svg" /></a>
<a href="http://twitter.com/bernaferrari">
<img src="https://img.shields.io/badge/Twitter-@bernaferrari-brightgreen.svg?style=flat" alt="Twitter"/></a>
</p><p align="center">
<a href="https://www.figma.com/community/plugin/842128343887142055"><img src="assets/badge.png" height="60"/></a>
</p>

Converting Figma designs into usable code can be a challenge, often requiring time-consuming manual work. Figma to Code simplifies that process. This plugin generates responsive layouts in `HTML`, `React (JSX)`, `Svelte`, `styled-components`, `Tailwind`, `Flutter`, and `SwiftUI` directly from your designs. Your feedback and ideas are always welcome.

![Gif showing the conversion](assets/lossy_gif.gif)

## How it works

The plugin uses a sophisticated multi-step process to transform your Figma designs into clean, optimized code:

1. **Node Conversion**: First, the plugin converts Figma's native nodes into JSON representations, preserving all necessary properties while adding optimizations and parent references.

2. **Intermediate Representation**: The JSON nodes are then transformed into `AltNodes` - a custom virtual representation that can be manipulated without affecting your original design.

3. **Layout Optimization**: The plugin analyzes and optimizes layouts, detecting patterns like auto-layouts, responsive constraints and color variables.

4. **Code Generation**: Finally, the optimized structure is transformed into the target framework's code, with special handling for each framework's unique patterns and best practices. If a feature is unsupported, the plugin will provide a warning.

![Conversion Workflow](assets/workflow.png)

This intermediate representation approach allows for sophisticated transformations and optimizations before any code is generated, resulting in cleaner, more maintainable output.

## Hard cases

Converting visual designs to code inevitably encounters complex edge cases. Here are some challenges the plugin handles:

1. **Complex Layouts**: When working with mixed positioning (absolute + auto-layout), the plugin has to make intelligent decisions about how to structure the resulting code. It detects parent-child relationships and z-index ordering to produce the most accurate representation.

2. **Color Variables**: The plugin detects and processes color variables, allowing for theme-consistent output.

3. **Gradients and Effects**: Different frameworks handle gradients and effects in unique ways, requiring specialized conversion logic.

![Conversion Workflow](assets/examples.png)

**Tip**: Instead of selecting the whole page, you can also select individual items. This can be useful for both debugging and componentization. For example: you can use the plugin to generate the code of a single element and then replicate it using a for-loop.

### Todo

- Vectors (possible to enable in HTML and Tailwind)
- Images (possible to enable to inline them in HTML and Tailwind)
- Line/Star/Polygon

## How to build the project

### Package Manager

The project is configured for [pnpm](https://pnpm.io/). To install, see the [installation notes for pnpm](https://pnpm.io/installation).

### Monorepo

The plugin is organized as a monorepo. There are several packages:

- `packages/backend` - Contains the business logic that reads the Figma API and converts nodes
- `packages/plugin-ui` - Contains the common UI for the plugin
- `packages/eslint-config-custom` - Config file for ESLint
- `packages/tsconfig` - Collection of TSConfig files used throughout the project

- `apps/plugin` - This is the actual plugin assembled from the parts in `backend` & `plugin-ui`. Within this folder it's divided between:
  - `plugin-src` - loads from `backend` and compiles to `code.js`
  - `ui-src` - loads the common `plugin-ui` and compiles to `index.html`
- `apps/debug` - This is a debug mode plugin that is a more convenient way to see all the UI elements.

### Development Workflow

The project uses [Turborepo](https://turbo.build/) for managing the monorepo, and each package is compiled using [esbuild](https://esbuild.github.io/) for fast development cycles. Only modified files are recompiled when changes are made, making the development process more efficient.

#### Running the Project

You have two main options for development:

1. **Root development mode** (includes debug UI):

   ```bash
   pnpm dev
   ```

   This runs the plugin in dev mode and also starts a Next.js server for the debug UI. You can access the debug UI at `http://localhost:3000`.

2. **Plugin-only development mode**:

   ```bash
   cd apps/plugin
   pnpm dev
   ```

   This focuses only on the plugin without the Next.js debug UI. Use this when you're making changes specifically to the plugin.

#### Where to Make Changes

Most of your development work will happen in these directories:

- `packages/backend` - For plugin backend
- `packages/plugin-ui` - For plugin UI
- `apps/plugin/` - The main plugin result that combines the backend and UI and is called by Figma.

You'll rarely need to modify files directly in the `apps/` directory, as they mostly contain build configuration.

#### Commands

`pnpm run ...`

- `dev` - runs the app in dev mode. This can be run in the Figma editor.
- `build` - builds the project for production
- `build:watch` - builds and watches for changes
- `lint` - runs ESLint
- `format` - formats with prettier (warning: may edit files!)

#### Debug mode

When running the `dev` task, you can open `http://localhost:3000` to see the debug version of the UI.

<img width="600" alt="Screenshot 2024-12-13 at 16 26 43" src="https://github.com/user-attachments/assets/427fb066-70e1-47bd-8718-51f7f4d83e35" />

## Issues

The Figma file for this README and icon is also open and welcome to changes! [Check it here.](https://www.figma.com/file/8buWpm6Mpq4yK9MhbkcdJB/Figma-to-Code)

I took decisions thinking about how it would benefit the majority of people, but I can (and probably will!) be wrong many times. Found a bug? Have an idea for an improvement? Feel free to [add an issue](../../issues) or email me. Pull requests are also more than welcome.
</file>

<file path="packages/backend/src/common/color.ts">
import { GradientPaint } from "../api_types";
import { numberToFixedString } from "./numToAutoFixed";
export const rgbTo6hex = (color: RGB | RGBA): string => {
  const hex =
    ((color.r * 255) | (1 << 8)).toString(16).slice(1) +
    ((color.g * 255) | (1 << 8)).toString(16).slice(1) +
    ((color.b * 255) | (1 << 8)).toString(16).slice(1);
  return hex;
};
export const rgbTo8hex = (color: RGB, alpha: number): string => {
  const hex =
    ((alpha * 255) | (1 << 8)).toString(16).slice(1) +
    ((color.r * 255) | (1 << 8)).toString(16).slice(1) +
    ((color.g * 255) | (1 << 8)).toString(16).slice(1) +
    ((color.b * 255) | (1 << 8)).toString(16).slice(1);
  return hex;
};
export const rgbToCssColor = (color: RGB | RGBA, alpha: number = 1): string => {
  if (color.r === 1 && color.g === 1 && color.b === 1 && alpha === 1) {
    return "white";
  }
  if (color.r === 0 && color.g === 0 && color.b === 0 && alpha === 1) {
    return "black";
  }
  if (alpha === 1) {
    const r = Math.round(color.r * 255);
    const g = Math.round(color.g * 255);
    const b = Math.round(color.b * 255);
    const toHex = (num: number): string => num.toString(16).padStart(2, "0");
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
  }
  const r = numberToFixedString(color.r * 255);
  const g = numberToFixedString(color.g * 255);
  const b = numberToFixedString(color.b * 255);
  const a = numberToFixedString(alpha);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
};
export const gradientAngle = (fill: GradientPaint): number => {
  const [start, end] = fill.gradientHandlePositions;
  return calculateAngle(start, end);
};
export const calculateAngle = (
  start: { x: number; y: number },
  end: { x: number; y: number },
): number => {
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  let angle = Math.atan2(dy, dx) * (180 / Math.PI);
  return (angle + 360) % 360;
};
export const decomposeRelativeTransform = (
  t1: [number, number, number],
  t2: [number, number, number],
): {
  translation: [number, number];
  rotation: number;
  scale: [number, number];
  skew: [number, number];
} => {
  const a: number = t1[0];
  const b: number = t1[1];
  const c: number = t1[2];
  const d: number = t2[0];
  const e: number = t2[1];
  const f: number = t2[2];
  const delta = a * d - b * c;
  const result: {
    translation: [number, number];
    rotation: number;
    scale: [number, number];
    skew: [number, number];
  } = {
    translation: [e, f],
    rotation: 0,
    scale: [0, 0],
    skew: [0, 0],
  };
  if (a !== 0 || b !== 0) {
    const r = Math.sqrt(a * a + b * b);
    result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
    result.scale = [r, delta / r];
    result.skew = [Math.atan((a * c + b * d) / (r * r)), 0];
  }
  return result;
};
export const isBlack = (color: RGB, opacity: number = 1): boolean =>
  color.r === 0 && color.g === 0 && color.b === 0 && opacity === 1;
export const isWhite = (color: RGB, opacity: number = 1): boolean =>
  color.r === 1 && color.g === 1 && color.b === 1 && opacity === 1;
export const processGradientStops = (
  stops: ReadonlyArray<ColorStop>,
  opacity: number = 1,
  colorFormatter: (color: RGB | RGBA, alpha: number) => string,
): string => {
  return stops
    .map((stop) => {
      const color = colorFormatter(stop.color, stop.color.a * opacity);
      const position = `${(stop.position * 100).toFixed(0)}%`;
      return `${color} ${position}`;
    })
    .join(", ");
};
</file>

<file path="packages/backend/src/common/exportAsyncProxy.ts">
import { postConversionStart } from "../messaging";
let isRunning = false;
export const exportAsyncProxy = async <
  T extends string | Uint8Array = Uint8Array ,
>(
  node: SceneNode,
  settings: ExportSettings | ExportSettingsSVGString ,
): Promise<T> => {
  if (isRunning === false) {
    isRunning = true;
    postConversionStart();
    await new Promise((resolve) => setTimeout(resolve, 30));
  }
  const figmaNode = (await figma.getNodeByIdAsync(node.id)) as ExportMixin;
  if (figmaNode.exportAsync === undefined) {
    throw new TypeError(
      "Something went wrong. This node doesn't have an exportAsync() function. Maybe check the type before calling this function.",
    );
  }
  let result;
  if (settings.format === "SVG_STRING") {
    result = await figmaNode.exportAsync(settings as ExportSettingsSVGString);
  } else {
    result = await figmaNode.exportAsync(settings as ExportSettings);
  }
  isRunning = false;
  return result as T;
};
</file>

<file path="packages/backend/src/flutter/builderImpl/flutterSize.ts">
import { nodeSize } from "../../common/nodeWidthHeight";
import { numberToFixedString } from "../../common/numToAutoFixed";
export const flutterSizeWH = (node: SceneNode): string => {
  const fSize = flutterSize(node);
  const size = fSize.width + fSize.height;
  return size;
};
export const flutterSize = (
  node: SceneNode,
): {
  width: string;
  height: string;
  isExpanded: boolean;
  constraints: Record<string, string>;
} => {
  const size = nodeSize(node);
  let isExpanded: boolean = false;
  const nodeParent = node.parent;
  let propWidth = "";
  if (typeof size.width === "number") {
    propWidth = numberToFixedString(size.width);
  } else if (size.width === "fill") {
    if (
      nodeParent &&
      "layoutMode" in nodeParent &&
      nodeParent.layoutMode === "HORIZONTAL"
    ) {
      isExpanded = true;
    } else {
      propWidth = `double.infinity`;
    }
  }
  let propHeight = "";
  if (typeof size.height === "number") {
    propHeight = numberToFixedString(size.height);
  } else if (size.height === "fill") {
    if (
      nodeParent &&
      "layoutMode" in nodeParent &&
      nodeParent.layoutMode === "VERTICAL"
    ) {
      isExpanded = true;
    } else {
      propHeight = `double.infinity`;
    }
  }
  const constraints: Record<string, string> = {};
  if (node.minWidth !== undefined && node.minWidth !== null) {
    constraints.minWidth = numberToFixedString(node.minWidth);
  }
  if (node.maxWidth !== undefined && node.maxWidth !== null) {
    constraints.maxWidth = numberToFixedString(node.maxWidth);
  }
  if (node.minHeight !== undefined && node.minHeight !== null) {
    constraints.minHeight = numberToFixedString(node.minHeight);
  }
  if (node.maxHeight !== undefined && node.maxHeight !== null) {
    constraints.maxHeight = numberToFixedString(node.maxHeight);
  }
  return { width: propWidth, height: propHeight, isExpanded, constraints };
};
</file>

<file path="packages/backend/src/flutter/flutterTextBuilder.ts">
import {
  generateWidgetCode,
  skipDefaultProperty,
  numberToFixedString,
} from "./../common/numToAutoFixed";
import { FlutterDefaultBuilder } from "./flutterDefaultBuilder";
import {
  flutterColorFromDirectFills,
  flutterColorFromFills,
} from "./builderImpl/flutterColor";
import { flutterSize } from "./builderImpl/flutterSize";
import {
  commonLetterSpacing,
  commonLineHeight,
} from "../common/commonTextHeightSpacing";
import { StyledTextSegmentSubset } from "types/src/types";
export class FlutterTextBuilder extends FlutterDefaultBuilder {
  node?: TextNode;
  constructor(optChild: string = "") {
    super(optChild);
  }
  reset(): void {
    this.child = "";
  }
  createText(node: TextNode): this {
    this.node = node;
    let alignHorizontal =
      node.textAlignHorizontal?.toString()?.toLowerCase() ?? "left";
    alignHorizontal =
      alignHorizontal === "justified" ? "justify" : alignHorizontal;
    const basicTextStyle = {
      textAlign:
        alignHorizontal !== "left" ? `TextAlign.${alignHorizontal}` : "",
    };
    const segments = this.getTextSegments(node);
    if (segments.length === 1) {
      this.child = generateWidgetCode(
        "Text",
        {
          ...basicTextStyle,
          style: segments[0].style,
        },
        [`'${segments[0].text}'`],
      );
    } else {
      this.child = generateWidgetCode("Text.rich", basicTextStyle, [
        generateWidgetCode("TextSpan", {
          children: segments.map((segment) =>
            generateWidgetCode("TextSpan", {
              text: `'${segment.text}'`,
              style: segment.style,
            }),
          ),
        }),
      ]);
    }
    return this;
  }
  getTextSegments(node: TextNode): {
    style: string;
    text: string;
    openTypeFeatures: { [key: string]: boolean };
  }[] {
    const segments = (node as any)
      .styledTextSegments as StyledTextSegmentSubset[];
    if (!segments) {
      return [];
    }
    return segments.map((segment) => {
      const color = flutterColorFromDirectFills(segment.fills);
      const fontSize = `${numberToFixedString(segment.fontSize)}`;
      const fontStyle = this.fontStyle(segment.fontName);
      const fontFamily = `'${segment.fontName.family}'`;
      const fontWeight = `FontWeight.w${segment.fontWeight}`;
      const lineHeight = this.lineHeight(segment.lineHeight, segment.fontSize);
      const letterSpacing = this.letterSpacing(
        segment.letterSpacing,
        segment.fontSize,
      );
      const styleProperties: { [key: string]: string } = {
        color: color,
        fontSize: fontSize,
        fontStyle: fontStyle,
        fontFamily: fontFamily,
        fontWeight: fontWeight,
        textDecoration: skipDefaultProperty(
          this.getFlutterTextDecoration(segment.textDecoration),
          "TextDecoration.none",
        ),
        height: lineHeight,
        letterSpacing: letterSpacing,
      };
      if (
        (segment.openTypeFeatures as unknown as { SUBS: boolean }).SUBS === true
      ) {
        styleProperties.fontFeatures = `[FontFeature.enable("subs")]`;
      } else if (
        (segment.openTypeFeatures as unknown as { SUPS: boolean }).SUPS === true
      ) {
        styleProperties.fontFeatures = `[FontFeature.enable("sups")]`;
      }
      const shadow = this.textShadow();
      if (shadow) {
        styleProperties.shadows = shadow;
      }
      const style = generateWidgetCode("TextStyle", styleProperties);
      let text = segment.characters;
      if (segment.textCase === "LOWER") {
        text = text.toLowerCase();
      } else if (segment.textCase === "UPPER") {
        text = text.toUpperCase();
      }
      return {
        style: style,
        text: parseTextAsCode(text).replace(/\$/g, "\\$"),
        openTypeFeatures: segment.openTypeFeatures,
      };
    });
  }
  getFlutterTextDecoration(decoration: TextDecoration): string {
    switch (decoration) {
      case "UNDERLINE":
        return "TextDecoration.underline";
      case "STRIKETHROUGH":
        return "TextDecoration.lineThrough";
      default:
        return "TextDecoration.none";
    }
  }
  lineHeight(lineHeight: LineHeight, fontSize: number): string {
    switch (lineHeight.unit) {
      case "AUTO":
        return "";
      case "PIXELS":
        return numberToFixedString(lineHeight.value / fontSize);
      case "PERCENT":
        return numberToFixedString(lineHeight.value / 100);
    }
  }
  letterSpacing(letterSpacing: LetterSpacing, fontSize: number): string {
    const value = commonLetterSpacing(letterSpacing, fontSize);
    if (value) {
      return numberToFixedString(value);
    }
    return "";
  }
  textAutoSize(node: TextNode): this {
    let result = this.child;
    // Get constraints for the node
    const constraints: Record<string, string> = {};
    if (node.minWidth !== undefined && node.minWidth !== null) {
      constraints.minWidth = numberToFixedString(node.minWidth);
    }
    if (node.maxWidth !== undefined && node.maxWidth !== null) {
      constraints.maxWidth = numberToFixedString(node.maxWidth);
    }
    if (node.minHeight !== undefined && node.minHeight !== null) {
      constraints.minHeight = numberToFixedString(node.minHeight);
    }
    if (node.maxHeight !== undefined && node.maxHeight !== null) {
      constraints.maxHeight = numberToFixedString(node.maxHeight);
    }
    const hasConstraints = Object.keys(constraints).length > 0;
    if (hasConstraints) {
      result = generateWidgetCode("ConstrainedBox", {
        constraints: generateWidgetCode("BoxConstraints", constraints),
        child: result,
      });
    }
    switch (node.textAutoResize) {
      case "WIDTH_AND_HEIGHT":
        break;
      case "HEIGHT":
        result = generateWidgetCode("SizedBox", {
          width: node.width,
          child: result,
        });
        break;
      case "NONE":
      case "TRUNCATE":
        result = generateWidgetCode("SizedBox", {
          width: node.width,
          height: node.height,
          child: result,
        });
        break;
    }
    result = wrapTextWithLayerBlur(node, result);
    this.child = result;
    return this;
  }
  fontStyle = (fontName: FontName): string => {
    const lowercaseStyle = fontName.style.toLowerCase();
    if (lowercaseStyle.match("italic")) {
      return "FontStyle.italic";
    }
    return "";
  };
  /**
   * New method to handle text shadow.
   * Checks if a drop shadow effect is applied to the node and
   * returns Flutter code for the TextStyle "shadows" property.
   */
  textShadow(): string {
    if (this.node && (this.node as TextNode).effects) {
      const effects = (this.node as TextNode).effects;
      const dropShadow = effects.find(
        (effect) => effect.type === "DROP_SHADOW" && effect.visible !== false,
      );
      if (dropShadow) {
        const ds = dropShadow as DropShadowEffect;
        const offsetX = Math.round(ds.offset.x);
        const offsetY = Math.round(ds.offset.y);
        const blurRadius = Math.round(ds.radius);
        const r = Math.round(ds.color.r * 255);
        const g = Math.round(ds.color.g * 255);
        const b = Math.round(ds.color.b * 255);
        const hex = ((1 << 24) + (r << 16) + (g << 8) + b)
          .toString(16)
          .slice(1)
          .toUpperCase();
        return `[Shadow(offset: Offset(${offsetX}, ${offsetY}), blurRadius: ${blurRadius}, color: Color(0xFF${hex}).withOpacity(${ds.color.a.toFixed(
          2,
        )}))]`;
      }
    }
    return "";
  }
}
export const wrapTextWithLayerBlur = (
  node: TextNode,
  child: string,
): string => {
  if (node.effects) {
    const blurEffect = node.effects.find(
      (effect) =>
        effect.type === "LAYER_BLUR" &&
        effect.visible !== false &&
        effect.radius > 0,
    );
    if (blurEffect) {
      return generateWidgetCode("ImageFiltered", {
        imageFilter: `ImageFilter.blur(sigmaX: ${blurEffect.radius}, sigmaY: ${blurEffect.radius})`,
        child: child,
      });
    }
  }
  return child;
};
export const parseTextAsCode = (originalText: string) =>
  originalText.replace(/\n/g, "\\n");
</file>

<file path="packages/backend/src/html/builderImpl/htmlBlend.ts">
import { roundToNearestHundreth } from "./../../common/numToAutoFixed";
import { addWarning } from "../../common/commonConversionWarnings";
import { numberToFixedString } from "../../common/numToAutoFixed";
import { formatWithJSX } from "../../common/parseJSX";
export const htmlOpacity = (
  node: MinimalBlendMixin,
  isJsx: boolean,
): string => {
  if (node.opacity !== undefined && node.opacity !== 1) {
    if (isJsx) {
      return `opacity: ${numberToFixedString(node.opacity)}`;
    } else {
      return `opacity: ${numberToFixedString(node.opacity)}`;
    }
  }
  return "";
};
export const htmlBlendMode = (
  node: MinimalBlendMixin,
  isJsx: boolean,
): string => {
  if (node.blendMode !== "NORMAL" && node.blendMode !== "PASS_THROUGH") {
    let blendMode = "";
    switch (node.blendMode) {
      case "MULTIPLY":
        blendMode = "multiply";
        break;
      case "SCREEN":
        blendMode = "screen";
        break;
      case "OVERLAY":
        blendMode = "overlay";
        break;
      case "DARKEN":
        blendMode = "darken";
        break;
      case "LIGHTEN":
        blendMode = "lighten";
        break;
      case "COLOR_DODGE":
        blendMode = "color-dodge";
        break;
      case "COLOR_BURN":
        blendMode = "color-burn";
        break;
      case "HARD_LIGHT":
        blendMode = "hard-light";
        break;
      case "SOFT_LIGHT":
        blendMode = "soft-light";
        break;
      case "DIFFERENCE":
        blendMode = "difference";
        break;
      case "EXCLUSION":
        blendMode = "exclusion";
        break;
      case "HUE":
        blendMode = "hue";
        break;
      case "SATURATION":
        blendMode = "saturation";
        break;
      case "COLOR":
        blendMode = "color";
        break;
      case "LUMINOSITY":
        blendMode = "luminosity";
        break;
    }
    if (blendMode) {
      return formatWithJSX("mix-blend-mode", isJsx, blendMode);
    }
  }
  return "";
};
/**
 * https://tailwindcss.com/docs/visibility/
 * example: invisible
 */
export const htmlVisibility = (
  node: SceneNodeMixin,
  isJsx: boolean,
): string => {
  // [when testing] node.visible can be undefined
  // When something is invisible in Figma, it isn't gone. Groups can make use of it.
  // Therefore, instead of changing the visibility (which causes bugs in nested divs),
  // this plugin is going to ignore color and stroke
  if (node.visible !== undefined && !node.visible) {
    return formatWithJSX("visibility", isJsx, "hidden");
  }
  return "";
};
/**
 * https://tailwindcss.com/docs/rotate/
 * default is [-180, -90, -45, 0, 45, 90, 180], but '0' will be ignored:
 * if rotation was changed, let it be perceived. Therefore, 1 => 45
 */
export const htmlRotation = (node: LayoutMixin, isJsx: boolean): string[] => {
  const rotation =
    -Math.round((node.rotation || 0) + (node.cumulativeRotation || 0)) || 0;
  if (rotation !== 0) {
    return [
      formatWithJSX(
        "transform",
        isJsx,
        `rotate(${numberToFixedString(rotation)}deg)`,
      ),
      formatWithJSX("transform-origin", isJsx, "top left"),
    ];
  }
  return [];
};
</file>

<file path="packages/backend/src/html/builderImpl/htmlBorderRadius.ts">
import { getCommonRadius } from "../../common/commonRadius";
import { formatWithJSX } from "../../common/parseJSX";
export const htmlBorderRadius = (node: SceneNode, isJsx: boolean): string[] => {
  let comp: string[] = [];
  if (
    "children" in node &&
    node.children.length > 0 &&
    "clipsContent" in node &&
    node.clipsContent === true
  ) {
    comp.push(formatWithJSX("overflow", isJsx, "hidden"));
  }
  if (node.type === "ELLIPSE") {
    comp.push(formatWithJSX("border-radius", isJsx, 9999));
    return comp;
  }
  const radius = getCommonRadius(node);
  let singleCorner: number = 0;
  if ("all" in radius) {
    if (radius.all === 0) {
      return comp;
    }
    singleCorner = radius.all;
    comp.push(formatWithJSX("border-radius", isJsx, radius.all));
  } else {
    const cornerValues = [
      radius.topLeft,
      radius.topRight,
      radius.bottomRight,
      radius.bottomLeft,
    ];
    const cornerProperties = [
      "border-top-left-radius",
      "border-top-right-radius",
      "border-bottom-right-radius",
      "border-bottom-left-radius",
    ];
    for (let i = 0; i < 4; i++) {
      if (cornerValues[i] > 0) {
        comp.push(formatWithJSX(cornerProperties[i], isJsx, cornerValues[i]));
      }
    }
  }
  return comp;
};
</file>

<file path="packages/backend/src/tailwind/builderImpl/tailwindBlend.ts">
import { Paint } from "../../api_types";
import { numberToFixedString } from "../../common/numToAutoFixed";
import { exactValue, nearestOpacity } from "../conversionTables";
export const tailwindOpacity = (node: MinimalBlendMixin): string => {
  if (node.opacity !== undefined && node.opacity !== 1) {
    return `opacity-${nearestOpacity(node.opacity)}`;
  }
  return "";
};
// https://tailwindcss.com/docs/mix-blend-mode
export const tailwindBlendMode = (node: MinimalBlendMixin): string => {
  if (node.blendMode !== "NORMAL" && node.blendMode !== "PASS_THROUGH") {
    switch (node.blendMode) {
      case "MULTIPLY":
        return "mix-blend-multiply";
      case "SCREEN":
        return "mix-blend-screen";
      case "OVERLAY":
        return "mix-blend-overlay";
      case "DARKEN":
        return "mix-blend-darken";
      case "LIGHTEN":
        return "mix-blend-lighten";
      case "COLOR_DODGE":
        return "mix-blend-color-dodge";
      case "COLOR_BURN":
        return "mix-blend-color-burn";
      case "HARD_LIGHT":
        return "mix-blend-hard-light";
      case "SOFT_LIGHT":
        return "mix-blend-soft-light";
      case "DIFFERENCE":
        return "mix-blend-difference";
      case "EXCLUSION":
        return "mix-blend-exclusion";
      case "HUE":
        return "mix-blend-hue";
      case "SATURATION":
        return "mix-blend-saturation";
      case "COLOR":
        return "mix-blend-color";
      case "LUMINOSITY":
        return "mix-blend-luminosity";
    }
    return "";
  }
  return "";
};
/**
 * Convert a Figma background blend mode to a Tailwind bg-blend-* class
 *
 * @param paintArray The array of paint fills that may have blend modes
 * @returns Tailwind background blend mode class if applicable
 */
export const tailwindBackgroundBlendMode = (
  paintArray: ReadonlyArray<Paint>,
): string => {
  if (
    paintArray.length === 0 ||
    paintArray.every(
      (d) => d.blendMode === "NORMAL" || d.blendMode === "PASS_THROUGH",
    )
  ) {
    return "";
  }
  // Get the top fill's blend mode (in Figma, the last item is the top one)
  const topFill = paintArray[paintArray.length - 1];
  if (topFill.blendMode === "NORMAL" || topFill.blendMode === "PASS_THROUGH") {
    return "";
  }
  const blendMode =
    topFill.blendMode?.toLowerCase()?.replaceAll("_", "-") || "normal";
  return `bg-blend-${blendMode}`;
};
export const tailwindVisibility = (node: SceneNodeMixin): string => {
  if (node.visible !== undefined && !node.visible) {
    return "invisible";
  }
  return "";
};
/**
 * https://tailwindcss.com/docs/rotate/
 * default is [-180, -90, -45, 0, 45, 90, 180], but '0' will be ignored:
 * if rotation was changed, let it be perceived. Therefore, 1 => 45
 */
export const tailwindRotation = (node: LayoutMixin): string => {
  // that's how you convert angles to clockwise radians: angle * -pi/180
  // using 3.14159 as Pi for enough precision and to avoid importing math lib.
  if (node.rotation !== undefined && Math.round(node.rotation) !== 0) {
    const allowedValues = [
      -180, -90, -45, -12, -6, -3, -2, -1, 1, 2, 3, 6, 12, 45, 90, 180,
    ];
    let nearest = exactValue(-node.rotation, allowedValues);
    if (nearest) {
      let minusIfNegative = "";
      if (nearest < 0) {
        minusIfNegative = "-";
        nearest = -nearest;
      }
      return `origin-top-left ${minusIfNegative}rotate-${nearest}`;
    } else {
      return `origin-top-left rotate-[${numberToFixedString(-node.rotation)}deg]`;
    }
  }
  return "";
};
</file>

<file path="packages/backend/src/tailwind/tailwindConfig.ts">
const layoutSize = {
  "0": "0",
  1: "px",
  2: "0.5",
  4: "1",
  6: "1.5",
  8: "2",
  10: "2.5",
  12: "3",
  14: "3.5",
  16: "4",
  20: "5",
  24: "6",
  28: "7",
  32: "8",
  36: "9",
  40: "10",
  44: "11",
  48: "12",
  56: "14",
  64: "16",
  80: "20",
  96: "24",
  112: "28",
  128: "32",
  144: "36",
  160: "40",
  176: "44",
  192: "48",
  208: "52",
  224: "56",
  240: "60",
  256: "64",
  288: "72",
  320: "80",
  384: "96",
};
const borderRadius = {
  0: "none",
  0.125: "sm",
  0.25: "",
  0.375: "md",
  0.5: "lg",
  0.75: "xl",
  1.0: "2xl",
  1.5: "3xl",
  10: "full",
};
const borderRadiusV4 = {
  0: "none",
  0.125: "xs",
  0.25: "sm",
  0.375: "md",
  0.5: "lg",
  0.75: "xl",
  1.0: "2xl",
  1.5: "3xl",
  10: "full",
};
const fontSize = {
  0.75: "xs",
  0.875: "sm",
  1: "base",
  1.125: "lg",
  1.25: "xl",
  1.5: "2xl",
  1.875: "3xl",
  2.25: "4xl",
  3: "5xl",
  3.75: "6xl",
  4.5: "7xl",
  6: "8xl",
  8: "9xl",
};
const lineHeight = {
  0.75: "3",
  1: "none",
  1.25: "tight",
  1.375: "snug",
  1.5: "normal",
  1.625: "relaxed",
  2: "loose",
  1.75: "7",
  2.25: "9",
  2.5: "10",
};
const letterSpacing = {
  "-0.05": "tighter",
  "-0.025": "tight",
  0.025: "wide",
  0.05: "wider",
  0.1: "widest",
};
const blur = {
  0: "none",
  4: "sm",
  8: "blur",
  12: "md",
  16: "lg",
  24: "xl",
  40: "2xl",
  64: "3xl",
};
const blurV4 = {
  0: "none",
  4: "xs",
  8: "sm",
  12: "md",
  16: "lg",
  24: "xl",
  40: "2xl",
  64: "3xl",
};
const opacity = [0, 5, 10, 20, 25, 30, 40, 50, 60, 70, 75, 80, 90, 95];
const color: Record<string, string> = {
  "#000000": "black",
  "#ffffff": "white",
  "#f8fafc": "slate-50",
  "#f1f5f9": "slate-100",
  "#e2e8f0": "slate-200",
  "#cbd5e1": "slate-300",
  "#94a3b8": "slate-400",
  "#64748b": "slate-500",
  "#475569": "slate-600",
  "#334155": "slate-700",
  "#1e293b": "slate-800",
  "#0f172a": "slate-900",
  "#020617": "slate-950",
  "#f9fafb": "gray-50",
  "#f3f4f6": "gray-100",
  "#e5e7eb": "gray-200",
  "#d1d5db": "gray-300",
  "#9ca3af": "gray-400",
  "#6b7280": "gray-500",
  "#4b5563": "gray-600",
  "#374151": "gray-700",
  "#1f2937": "gray-800",
  "#111827": "gray-900",
  "#030712": "gray-950",
  "#f4f4f5": "zinc-100",
  "#e4e4e7": "zinc-200",
  "#d4d4d8": "zinc-300",
  "#a1a1aa": "zinc-400",
  "#71717a": "zinc-500",
  "#52525b": "zinc-600",
  "#3f3f46": "zinc-700",
  "#27272a": "zinc-800",
  "#18181b": "zinc-900",
  "#09090b": "zinc-950",
  "#fafafa": "neutral-50",
  "#f5f5f5": "neutral-100",
  "#e5e5e5": "neutral-200",
  "#d4d4d4": "neutral-300",
  "#a3a3a3": "neutral-400",
  "#737373": "neutral-500",
  "#525252": "neutral-600",
  "#404040": "neutral-700",
  "#262626": "neutral-800",
  "#171717": "neutral-900",
  "#0a0a0a": "neutral-950",
  "#fafaf9": "stone-50",
  "#f5f5f4": "stone-100",
  "#e7e5e4": "stone-200",
  "#d6d3d1": "stone-300",
  "#a8a29e": "stone-400",
  "#78716c": "stone-500",
  "#57534e": "stone-600",
  "#44403c": "stone-700",
  "#292524": "stone-800",
  "#1c1917": "stone-900",
  "#0c0a09": "stone-950",
  "#fef2f2": "red-50",
  "#fee2e2": "red-100",
  "#fecaca": "red-200",
  "#fca5a5": "red-300",
  "#f87171": "red-400",
  "#ef4444": "red-500",
  "#dc2626": "red-600",
  "#b91c1c": "red-700",
  "#991b1b": "red-800",
  "#7f1d1d": "red-900",
  "#450a0a": "red-950",
  "#fff7ed": "orange-50",
  "#ffedd5": "orange-100",
  "#fed7aa": "orange-200",
  "#fdba74": "orange-300",
  "#fb923c": "orange-400",
  "#f97316": "orange-500",
  "#ea580c": "orange-600",
  "#c2410c": "orange-700",
  "#9a3412": "orange-800",
  "#7c2d12": "orange-900",
  "#431407": "orange-950",
  "#fffbeb": "amber-50",
  "#fef3c7": "amber-100",
  "#fde68a": "amber-200",
  "#fcd34d": "amber-300",
  "#fbbf24": "amber-400",
  "#f59e0b": "amber-500",
  "#d97706": "amber-600",
  "#b45309": "amber-700",
  "#92400e": "amber-800",
  "#78350f": "amber-900",
  "#451a03": "amber-950",
  "#fefce8": "yellow-50",
  "#fef9c3": "yellow-100",
  "#fef08a": "yellow-200",
  "#fde047": "yellow-300",
  "#facc15": "yellow-400",
  "#eab308": "yellow-500",
  "#ca8a04": "yellow-600",
  "#a16207": "yellow-700",
  "#854d0e": "yellow-800",
  "#713f12": "yellow-900",
  "#422006": "yellow-950",
  "#f7fee7": "lime-50",
  "#ecfccb": "lime-100",
  "#d9f99d": "lime-200",
  "#bef264": "lime-300",
  "#a3e635": "lime-400",
  "#84cc16": "lime-500",
  "#65a30d": "lime-600",
  "#4d7c0f": "lime-700",
  "#3f6212": "lime-800",
  "#365314": "lime-900",
  "#1a2e05": "lime-950",
  "#f0fdf4": "green-50",
  "#dcfce7": "green-100",
  "#bbf7d0": "green-200",
  "#86efac": "green-300",
  "#4ade80": "green-400",
  "#22c55e": "green-500",
  "#16a34a": "green-600",
  "#15803d": "green-700",
  "#166534": "green-800",
  "#14532d": "green-900",
  "#052e16": "green-950",
  "#ecfdf5": "emerald-50",
  "#d1fae5": "emerald-100",
  "#a7f3d0": "emerald-200",
  "#6ee7b7": "emerald-300",
  "#34d399": "emerald-400",
  "#10b981": "emerald-500",
  "#059669": "emerald-600",
  "#047857": "emerald-700",
  "#065f46": "emerald-800",
  "#064e3b": "emerald-900",
  "#022c22": "emerald-950",
  "#f0fdfa": "teal-50",
  "#ccfbf1": "teal-100",
  "#99f6e4": "teal-200",
  "#5eead4": "teal-300",
  "#2dd4bf": "teal-400",
  "#14b8a6": "teal-500",
  "#0d9488": "teal-600",
  "#0f766e": "teal-700",
  "#115e59": "teal-800",
  "#134e4a": "teal-900",
  "#042f2e": "teal-950",
  "#ecfeff": "cyan-50",
  "#cffafe": "cyan-100",
  "#a5f3fc": "cyan-200",
  "#67e8f9": "cyan-300",
  "#22d3ee": "cyan-400",
  "#06b6d4": "cyan-500",
  "#0891b2": "cyan-600",
  "#0e7490": "cyan-700",
  "#155e75": "cyan-800",
  "#164e63": "cyan-900",
  "#083344": "cyan-950",
  "#f0f9ff": "sky-50",
  "#e0f2fe": "sky-100",
  "#bae6fd": "sky-200",
  "#7dd3fc": "sky-300",
  "#38bdf8": "sky-400",
  "#0ea5e9": "sky-500",
  "#0284c7": "sky-600",
  "#0369a1": "sky-700",
  "#075985": "sky-800",
  "#0c4a6e": "sky-900",
  "#082f49": "sky-950",
  "#eff6ff": "blue-50",
  "#dbeafe": "blue-100",
  "#bfdbfe": "blue-200",
  "#93c5fd": "blue-300",
  "#60a5fa": "blue-400",
  "#3b82f6": "blue-500",
  "#2563eb": "blue-600",
  "#1d4ed8": "blue-700",
  "#1e40af": "blue-800",
  "#1e3a8a": "blue-900",
  "#172554": "blue-950",
  "#eef2ff": "indigo-50",
  "#e0e7ff": "indigo-100",
  "#c7d2fe": "indigo-200",
  "#a5b4fc": "indigo-300",
  "#818cf8": "indigo-400",
  "#6366f1": "indigo-500",
  "#4f46e5": "indigo-600",
  "#4338ca": "indigo-700",
  "#3730a3": "indigo-800",
  "#312e81": "indigo-900",
  "#1e1b4b": "indigo-950",
  "#f5f3ff": "violet-50",
  "#ede9fe": "violet-100",
  "#ddd6fe": "violet-200",
  "#c4b5fd": "violet-300",
  "#a78bfa": "violet-400",
  "#8b5cf6": "violet-500",
  "#7c3aed": "violet-600",
  "#6d28d9": "violet-700",
  "#5b21b6": "violet-800",
  "#4c1d95": "violet-900",
  "#2e1065": "violet-950",
  "#faf5ff": "purple-50",
  "#f3e8ff": "purple-100",
  "#e9d5ff": "purple-200",
  "#d8b4fe": "purple-300",
  "#c084fc": "purple-400",
  "#a855f7": "purple-500",
  "#9333ea": "purple-600",
  "#7e22ce": "purple-700",
  "#6b21a8": "purple-800",
  "#581c87": "purple-900",
  "#3b0764": "purple-950",
  "#fdf4ff": "fuchsia-50",
  "#fae8ff": "fuchsia-100",
  "#f5d0fe": "fuchsia-200",
  "#f0abfc": "fuchsia-300",
  "#e879f9": "fuchsia-400",
  "#d946ef": "fuchsia-500",
  "#c026d3": "fuchsia-600",
  "#a21caf": "fuchsia-700",
  "#86198f": "fuchsia-800",
  "#701a75": "fuchsia-900",
  "#4a044e": "fuchsia-950",
  "#fdf2f8": "pink-50",
  "#fce7f3": "pink-100",
  "#fbcfe8": "pink-200",
  "#f9a8d4": "pink-300",
  "#f472b6": "pink-400",
  "#ec4899": "pink-500",
  "#db2777": "pink-600",
  "#be185d": "pink-700",
  "#9d174d": "pink-800",
  "#831843": "pink-900",
  "#500724": "pink-950",
  "#fff1f2": "rose-50",
  "#ffe4e6": "rose-100",
  "#fecdd3": "rose-200",
  "#fda4af": "rose-300",
  "#fb7185": "rose-400",
  "#f43f5e": "rose-500",
  "#e11d48": "rose-600",
  "#be123c": "rose-700",
  "#9f1239": "rose-800",
  "#881337": "rose-900",
  "#4c0519": "rose-950",
};
const fontWeight: Record<number, string> = {
  100: "thin",
  200: "extralight",
  300: "light",
  400: "normal",
  500: "medium",
  600: "semibold",
  700: "bold",
  800: "extrabold",
  900: "black",
};
const fontFamily = {
  sans: [
    "ui-sans-serif",
    "system-ui",
    "sans-serif",
    "Apple Color Emoji",
    "Segoe UI Emoji",
    "Segoe UI Symbol",
    "Noto Color Emoji",
  ],
  serif: [
    "ui-serif",
    "Georgia",
    "Cambria",
    "Times New Roman",
    "Times",
    "serif",
  ],
  mono: [
    "ui-monospace",
    "SFMono-Regular",
    "Menlo",
    "Monaco",
    "Consolas",
    "Liberation Mono",
    "Courier New",
    "monospace",
  ],
};
const border = {
  0: "0",
  1: "1",
  2: "2",
  4: "4",
  8: "8",
};
const outline = {
  0: "0",
  1: "1",
  2: "2",
  4: "4",
  8: "8",
};
const shadowV4 = {
  sm: "xs",
  DEFAULT: "sm",
  md: "md",
  lg: "lg",
  xl: "xl",
  "2xl": "2xl",
};
export const config = {
  layoutSize,
  borderRadius,
  borderRadiusV4,
  fontSize,
  lineHeight,
  letterSpacing,
  blur,
  blurV4,
  shadowV4,
  opacity,
  color,
  fontWeight,
  fontFamily,
  border,
  outline,
};
</file>

<file path="packages/eslint-config-custom/package.json">
{
  "name": "eslint-config-custom",
  "version": "0.0.0",
  "main": "index.js",
  "license": "MIT",
  "dependencies": {
    "eslint-config-next": "^15.2.4",
    "eslint-config-prettier": "^10.1.1",
    "eslint-config-turbo": "^2.4.4",
    "eslint-plugin-react": "7.37.4"
  },
  "publishConfig": {
    "access": "public"
  }
}
</file>

<file path="packages/plugin-ui/src/components/Loading.tsx">
import React from "react";
import { Code } from "lucide-react";
interface LoadingProps {}
const Loading = (_props: LoadingProps) => (
  <div className="flex items-center justify-center w-full h-full p-4 bg-white dark:bg-neutral-900 text-neutral-800 dark:text-white animate-fadeIn">
    <div className="flex flex-col items-center max-w-sm">
      {}
      <div className="relative w-16 h-16 mb-5">
        <div className="absolute inset-0 bg-linear-to-br from-green-400 to-emerald-600 rounded-xl opacity-20 animate-pulse"></div>
        <div className="absolute inset-0 flex items-center justify-center">
          <Code size={32} className="text-green-500 dark:text-green-400" />
        </div>
        {}
        <svg className="absolute inset-0 w-full h-full animate-spin-slow" viewBox="0 0 100 100">
          <circle
            cx="50" cy="50" r="45"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            className="text-green-500/20 dark:text-green-500/30"
          />
          <circle
            cx="50" cy="50" r="45"
            fill="none"
            stroke="currentColor"
            strokeWidth="4"
            strokeLinecap="round"
            className="text-green-500 dark:text-green-400"
            strokeDasharray="60 200"
            strokeDashoffset="0"
          />
        </svg>
      </div>
      {}
      <h2 className="text-xl font-semibold mb-2 text-center">
        Converting Design
      </h2>
      <p className="text-sm text-neutral-500 dark:text-neutral-400 text-center max-w-xs">
        Please wait while your design is being converted to code. This may take a moment for complex designs.
      </p>
      {}
      <div className="w-64 h-1 bg-neutral-200 dark:bg-neutral-700 rounded-full overflow-hidden mt-5">
        <div className="h-full bg-green-500 dark:bg-green-400 rounded-full animate-progress"></div>
      </div>
    </div>
  </div>
);
export default Loading;
</file>

<file path="apps/plugin/ui-src/App.tsx">
import { useEffect, useState } from "react";
import { PluginUI } from "plugin-ui";
import {
  Framework,
  PluginSettings,
  ConversionMessage,
  Message,
  HTMLPreview,
  LinearGradientConversion,
  SolidColorConversion,
  ErrorMessage,
  SettingsChangedMessage,
  Warning,
} from "types";
import { postUISettingsChangingMessage } from "./messaging";
import copy from "copy-to-clipboard";
interface AppState {
  code: string;
  selectedFramework: Framework;
  isLoading: boolean;
  htmlPreview: HTMLPreview;
  settings: PluginSettings | null;
  colors: SolidColorConversion[];
  gradients: LinearGradientConversion[];
  warnings: Warning[];
}
const emptyPreview = { size: { width: 0, height: 0 }, content: "" };
export default function App() {
  const [state, setState] = useState<AppState>({
    code: "",
    selectedFramework: "HTML",
    isLoading: false,
    htmlPreview: emptyPreview,
    settings: null,
    colors: [],
    gradients: [],
    warnings: [],
  });
  const rootStyles = getComputedStyle(document.documentElement);
  const figmaColorBgValue = rootStyles
    .getPropertyValue("--figma-color-bg")
    .trim();
  useEffect(() => {
    window.onmessage = (event: MessageEvent) => {
      const untypedMessage = event.data.pluginMessage as Message;
      console.log("[ui] message received:", untypedMessage);
      switch (untypedMessage.type) {
        case "conversionStart":
          setState((prevState) => ({
            ...prevState,
            code: "",
            isLoading: true,
          }));
          break;
        case "code":
          const conversionMessage = untypedMessage as ConversionMessage;
          setState((prevState) => ({
            ...prevState,
            ...conversionMessage,
            selectedFramework: conversionMessage.settings.framework,
            isLoading: false,
          }));
          break;
        case "pluginSettingChanged":
          const settingsMessage = untypedMessage as SettingsChangedMessage;
          setState((prevState) => ({
            ...prevState,
            settings: settingsMessage.settings,
            selectedFramework: settingsMessage.settings.framework,
          }));
          break;
        case "empty":
          setState((prevState) => ({
            ...prevState,
            code: "",
            htmlPreview: emptyPreview,
            warnings: [],
            colors: [],
            gradients: [],
            isLoading: false,
          }));
          break;
        case "error":
          const errorMessage = untypedMessage as ErrorMessage;
          setState((prevState) => ({
            ...prevState,
            colors: [],
            gradients: [],
            code: `Error :(\n// ${errorMessage.error}`,
            isLoading: false,
          }));
          break;
        case "selection-json":
          const json = event.data.pluginMessage.data;
          copy(JSON.stringify(json, null, 2));
        default:
          break;
      }
    };
    return () => {
      window.onmessage = null;
    };
  }, []);
  const handleFrameworkChange = (updatedFramework: Framework) => {
    if (updatedFramework !== state.selectedFramework) {
      setState((prevState) => ({
        ...prevState,
        selectedFramework: updatedFramework,
      }));
      postUISettingsChangingMessage("framework", updatedFramework, {
        targetOrigin: "*",
      });
    }
  };
  const handlePreferencesChange = (
    key: keyof PluginSettings,
    value: boolean | string | number,
  ) => {
    if (state.settings && state.settings[key] === value) {
    } else {
      postUISettingsChangingMessage(key, value, { targetOrigin: "*" });
    }
  };
  const darkMode = figmaColorBgValue !== "#ffffff";
  return (
    <div className={`${darkMode ? "dark" : ""}`}>
      <PluginUI
        isLoading={state.isLoading}
        code={state.code}
        warnings={state.warnings}
        selectedFramework={state.selectedFramework}
        setSelectedFramework={handleFrameworkChange}
        onPreferenceChanged={handlePreferencesChange}
        htmlPreview={state.htmlPreview}
        settings={state.settings}
        colors={state.colors}
        gradients={state.gradients}
      />
    </div>
  );
}
</file>

<file path="packages/backend/src/common/retrieveUI/retrieveColors.ts">
import { rgbTo6hex } from "../color";
import {
  swiftuiColor,
  swiftuiGradient,
} from "../../swiftui/builderImpl/swiftuiColor";
import {
  tailwindColor,
  tailwindGradient,
} from "../../tailwind/builderImpl/tailwindColor";
import {
  flutterColor,
  flutterGradient,
} from "../../flutter/builderImpl/flutterColor";
import {
  htmlColorFromFill,
  htmlGradientFromFills,
} from "../../html/builderImpl/htmlColor";
import { calculateContrastRatio } from "./commonUI";
import {
  LinearGradientConversion,
  SolidColorConversion,
  Framework,
} from "types";
import { processColorVariables } from "../../altNodes/jsonNodeConversion";
export const retrieveGenericSolidUIColors = async (
  framework: Framework,
): Promise<Array<SolidColorConversion>> => {
  const selectionColors = figma.getSelectionColors();
  if (!selectionColors || selectionColors.paints.length === 0) return [];
  const colors: Array<SolidColorConversion> = [];
  await Promise.all(
    selectionColors.paints.map(async (d) => {
      const paint = { ...d } as Paint;
      await processColorVariables(paint as any);
      const fill = await convertSolidColor(paint, framework);
      if (fill) {
        const exists = colors.find(
          (col) => col.exportValue === fill.exportValue,
        );
        if (!exists) {
          colors.push(fill);
        }
      }
    }),
  );
  return colors.sort((a, b) => a.hex.localeCompare(b.hex));
};
const convertSolidColor = async (
  fill: Paint,
  framework: Framework,
): Promise<SolidColorConversion | null> => {
  const black = { r: 0, g: 0, b: 0 };
  const white = { r: 1, g: 1, b: 1 };
  if (fill.type !== "SOLID") return null;
  const opacity = fill.opacity ?? 1.0;
  const output = {
    hex: rgbTo6hex(fill.color).toUpperCase(),
    colorName: "",
    exportValue: "",
    contrastBlack: calculateContrastRatio(fill.color, black),
    contrastWhite: calculateContrastRatio(fill.color, white),
  };
  if (framework === "Flutter") {
    output.exportValue = flutterColor(fill.color, opacity);
  } else if (framework === "HTML") {
    output.exportValue = htmlColorFromFill(fill as any);
  } else if (framework === "Tailwind") {
    output.exportValue = tailwindColor(fill as any, true).exportValue;
  } else if (framework === "SwiftUI") {
    output.exportValue = swiftuiColor(fill.color, opacity);
  }
  return output;
};
export const retrieveGenericLinearGradients = async (
  framework: Framework,
): Promise<Array<LinearGradientConversion>> => {
  const selectionColors = figma.getSelectionColors();
  const colorStr: Array<LinearGradientConversion> = [];
  if (!selectionColors || selectionColors.paints.length === 0) return [];
  await Promise.all(
    selectionColors.paints.map(async (paint) => {
      if (paint.type === "GRADIENT_LINEAR") {
        let fill = { ...paint };
        const t = fill.gradientTransform;
        fill.gradientHandlePositions = [
          { x: t[0][2], y: t[1][2] },
          { x: t[0][0] + t[0][2], y: t[1][0] + t[1][2] },
        ];
        if (fill.gradientStops) {
          for (const stop of fill.gradientStops) {
            if (stop.boundVariables?.color) {
              try {
                const variableId = stop.boundVariables.color.id;
                const variable = figma.variables.getVariableById(variableId);
                if (variable) {
                  (stop as any).variableColorName = variable.name
                    .replace(/\s+/g, "-")
                    .toLowerCase();
                }
              } catch (e) {
                console.error(
                  "Error retrieving variable for gradient stop:",
                  e,
                );
              }
            }
          }
        }
        let exportValue = "";
        switch (framework) {
          case "Flutter":
            exportValue = flutterGradient(fill);
            break;
          case "HTML":
            exportValue = htmlGradientFromFills(fill);
            break;
          case "Tailwind":
            exportValue = tailwindGradient(fill);
            break;
          case "SwiftUI":
            exportValue = swiftuiGradient(fill);
            break;
        }
        colorStr.push({
          cssPreview: htmlGradientFromFills(fill),
          exportValue,
        });
      }
    }),
  );
  return colorStr;
};
</file>

<file path="packages/backend/src/common/nodeWidthHeight.ts">
import { Size } from "types";
export const nodeSize = (node: SceneNode): Size => {
  if ("layoutSizingHorizontal" in node && "layoutSizingVertical" in node) {
    const width =
      node.layoutSizingHorizontal === "FILL"
        ? "fill"
        : node.layoutSizingHorizontal === "HUG"
          ? null
          : node.width;
    const height =
      node.layoutSizingVertical === "FILL"
        ? "fill"
        : node.layoutSizingVertical === "HUG"
          ? null
          : node.height;
    return { width, height };
  }
  return { width: node.width, height: node.height };
};
</file>

<file path="packages/backend/src/flutter/flutterContainer.ts">
import { flutterBorder } from "./builderImpl/flutterBorder";
import { flutterSize } from "./builderImpl/flutterSize";
import { flutterPadding } from "./builderImpl/flutterPadding";
import { flutterShadow } from "./builderImpl/flutterShadow";
import {
  flutterBoxDecorationColor,
  flutterColorFromFills,
} from "./builderImpl/flutterColor";
import {
  generateWidgetCode,
  skipDefaultProperty,
} from "../common/numToAutoFixed";
import { numberToFixedString } from "../common/numToAutoFixed";
import { getCommonRadius } from "../common/commonRadius";
import { commonStroke } from "../common/commonStroke";
import { generateRotationMatrix } from "./builderImpl/flutterBlend";
export const flutterContainer = (node: SceneNode, child: string): string => {
  if (node.width < 0 || node.height < 0) {
    return child;
  }
  const propBoxDecoration = getDecoration(node);
  const { width, height, isExpanded, constraints } = flutterSize(node);
  const clipBehavior =
    "clipsContent" in node && node.clipsContent === true
      ? "Clip.antiAlias"
      : "";
  // todo Image & multiple fills
  // [propPadding] will be "padding: const EdgeInsets.symmetric(...)" or ""
  let propPadding = "";
  if ("paddingLeft" in node) {
    propPadding = flutterPadding(node);
  }
  let result: string;
  const hasConstraints = constraints && Object.keys(constraints).length > 0;
  const properties: Record<string, string> = {};
  if ("rotation" in node) {
    const matrix = generateRotationMatrix(node);
    if (matrix) {
      properties.transform = matrix;
    }
  }
  if (width || height || propBoxDecoration || clipBehavior) {
    properties.width = skipDefaultProperty(width, "0");
    properties.height = skipDefaultProperty(height, "0");
    properties.padding = propPadding;
    properties.clipBehavior = clipBehavior;
    const parsedDecoration = skipDefaultProperty(
      propBoxDecoration,
      "BoxDecoration()",
    );
    properties.decoration = clipBehavior ? propBoxDecoration : parsedDecoration;
    const isEmptyProps = hasEmptyProps(properties);
    if (isEmptyProps) {
      result = child;
    } else {
      properties.child = child;
      result = generateWidgetCode("Container", {
        ...properties,
      });
    }
  } else if (propPadding) {
    result = generateWidgetCode("Padding", {
      padding: propPadding,
      child: child,
    });
  } else {
    result = child;
  }
  if (hasConstraints) {
    result = generateWidgetCode("ConstrainedBox", {
      constraints: generateWidgetCode("BoxConstraints", constraints),
      child: result,
    });
  }
  if (isExpanded) {
    result = generateWidgetCode("Expanded", {
      child: result,
    });
  }
  return result;
};
const hasEmptyProps = (props: Record<string, string>): boolean => {
  let isEmpty = true;
  for (const key in props) {
    const value = props[key];
    const defValue = value.length > 0 ? "0" : "";
    isEmpty = isEmpty && skipDefaultProperty(value, defValue).length == 0;
  }
  return isEmpty;
}
const getDecoration = (node: SceneNode): string => {
  if (!("fills" in node)) {
    return "";
  }
  const propBoxShadow = flutterShadow(node);
  const decorationBackground = flutterBoxDecorationColor(node, "fills");
  let shapeDecorationBorder = "";
  if (node.type === "STAR") {
    shapeDecorationBorder = generateStarBorder(node);
  } else if (node.type === "POLYGON") {
    shapeDecorationBorder = generatePolygonBorder(node);
  } else if (node.type === "ELLIPSE") {
    shapeDecorationBorder = generateOvalBorder(node);
  } else if ("strokeWeight" in node && node.strokeWeight !== figma.mixed) {
    shapeDecorationBorder = skipDefaultProperty(
      generateRoundedRectangleBorder(node),
      "RoundedRectangleBorder()",
    );
  }
  if (shapeDecorationBorder) {
    return generateWidgetCode("ShapeDecoration", {
      ...decorationBackground,
      shape: shapeDecorationBorder,
      shadows: propBoxShadow,
    });
  }
  return generateWidgetCode("BoxDecoration", {
    ...decorationBackground,
    borderRadius: generateBorderRadius(node),
    border: flutterBorder(node),
    boxShadow: propBoxShadow,
  });
};
const generateRoundedRectangleBorder = (
  node: SceneNode & MinimalStrokesMixin,
): string => {
  return generateWidgetCode("RoundedRectangleBorder", {
    side: generateBorderSideCode(node),
    borderRadius: generateBorderRadius(node),
  });
};
const generateBorderSideCode = (
  node: SceneNode & MinimalStrokesMixin,
): string => {
  const strokeWidth = getSingleStrokeWidth(node);
  return skipDefaultProperty(
    generateWidgetCode("BorderSide", {
      width: skipDefaultProperty(strokeWidth, 0),
      strokeAlign: skipDefaultProperty(
        getStrokeAlign(node, strokeWidth),
        "BorderSide.strokeAlignInside",
      ),
      color: skipDefaultProperty(
        flutterColorFromFills(node, "strokes"),
        "Colors.black",
      ),
    }),
    "BorderSide()",
  );
};
const getSingleStrokeWidth = (node: SceneNode) => {
  if (
    "strokes" in node &&
    (node.strokes.length === 0 ||
      node.strokes.every((d) => d.visible === false))
  ) {
    return 0;
  }
  const stroke = commonStroke(node);
  if (stroke === null) {
    return 0;
  }
  if ("all" in stroke) {
    return stroke.all;
  }
  return Math.max(stroke?.bottom, stroke?.top, stroke?.left, stroke?.right);
};
const generateStarBorder = (node: StarNode): string => {
  const points = node.pointCount;
  const innerRadiusRatio = node.innerRadius;
  const cornerRadius = node.cornerRadius;
  const pointRounding = cornerRadius === figma.mixed ? 0 : cornerRadius;
  const valleyRounding = 0;
  const rotation = 0;
  const squash = 0;
  return generateWidgetCode("StarBorder", {
    side: generateBorderSideCode(node),
    points: numberToFixedString(points),
    innerRadiusRatio: numberToFixedString(innerRadiusRatio),
    pointRounding: numberToFixedString(pointRounding),
    valleyRounding: numberToFixedString(valleyRounding),
    rotation: numberToFixedString(rotation),
    squash: numberToFixedString(squash),
  });
};
export const getStrokeAlign = (
  node: MinimalStrokesMixin,
  strokeWeight: number,
): string => {
  if (strokeWeight === 0) {
    return "";
  }
  switch (node.strokeAlign) {
    case "CENTER":
      return "BorderSide.strokeAlignCenter";
    case "OUTSIDE":
      return "BorderSide.strokeAlignOutside";
    case "INSIDE":
      return "BorderSide.strokeAlignInside";
    default:
      return "";
  }
};
const generateOvalBorder = (node: EllipseNode): string => {
  return generateWidgetCode("OvalBorder", {
    side: generateBorderSideCode(node),
  });
};
const generatePolygonBorder = (node: PolygonNode): string => {
  const points = node.pointCount;
  return generateWidgetCode("StarBorder.polygon", {
    side: generateBorderSideCode(node),
    sides: numberToFixedString(points),
    borderRadius: generateBorderRadius(node),
  });
};
const generateBorderRadius = (node: SceneNode): string => {
  const radius = getCommonRadius(node);
  if ("all" in radius) {
    if (radius.all === 0) {
      return "";
    }
    return `BorderRadius.circular(${numberToFixedString(radius.all)})`;
  }
  return generateWidgetCode("BorderRadius.only", {
    topLeft: skipDefaultProperty(
      `Radius.circular(${numberToFixedString(radius.topLeft)})`,
      "Radius.circular(0)",
    ),
    topRight: skipDefaultProperty(
      `Radius.circular(${numberToFixedString(radius.topRight)})`,
      "Radius.circular(0)",
    ),
    bottomLeft: skipDefaultProperty(
      `Radius.circular(${numberToFixedString(radius.bottomLeft)})`,
      "Radius.circular(0)",
    ),
    bottomRight: skipDefaultProperty(
      `Radius.circular(${numberToFixedString(radius.bottomRight)})`,
      "Radius.circular(0)",
    ),
  });
};
</file>

<file path="packages/backend/src/flutter/flutterDefaultBuilder.ts">
import {
  flutterVisibility,
  flutterOpacity,
  flutterRotation,
} from "./builderImpl/flutterBlend";
import { flutterContainer } from "./flutterContainer";
import {
  commonIsAbsolutePosition,
  getCommonPositionValue,
} from "../common/commonPosition";
import { generateWidgetCode } from "../common/numToAutoFixed";
export class FlutterDefaultBuilder {
  child: string;
  rotationApplied: boolean = false;
  constructor(optChild: string) {
    this.child = optChild;
  }
  createContainer(node: SceneNode): this {
    this.child = flutterContainer(node, this.child);
    this.rotationApplied = true;
    return this;
  }
  blendAttr(node: SceneNode): this {
    if ("rotation" in node && !this.rotationApplied) {
      this.child = flutterRotation(node, this.child);
    }
    if ("visible" in node) {
      this.child = flutterVisibility(node, this.child);
    } else if ("opacity" in node) {
      this.child = flutterOpacity(node, this.child);
    }
    return this;
  }
  position(node: SceneNode): this {
    if (commonIsAbsolutePosition(node)) {
      const { x, y } = getCommonPositionValue(node);
      this.child = generateWidgetCode("Positioned", {
        left: x,
        top: y,
        child: this.child,
      });
    }
    return this;
  }
}
</file>

<file path="packages/backend/src/swiftui/swiftuiDefaultBuilder.ts">
import { numberToFixedString } from "./../common/numToAutoFixed";
import { swiftuiBlur, swiftuiShadow } from "./builderImpl/swiftuiEffects";
import {
  swiftuiBorder,
  swiftuiCornerRadius,
} from "./builderImpl/swiftuiBorder";
import { swiftuiPadding } from "./builderImpl/swiftuiPadding";
import { swiftuiSize } from "./builderImpl/swiftuiSize";
import {
  swiftuiVisibility,
  swiftuiOpacity,
  swiftuiRotation,
  swiftuiBlendMode,
} from "./builderImpl/swiftuiBlend";
import {
  commonIsAbsolutePosition,
  getCommonPositionValue,
} from "../common/commonPosition";
import { SwiftUIElement } from "./builderImpl/swiftuiParser";
import { SwiftUIModifier } from "types";
import { swiftuiSolidColor } from "./builderImpl/swiftuiColor";
export class SwiftuiDefaultBuilder {
  element: SwiftUIElement;
  constructor(kind: string = "") {
    this.element = new SwiftUIElement(kind);
  }
  pushModifier(...args: (SwiftUIModifier | null)[]): void {
    args.forEach((modifier) => {
      if (modifier) {
        this.element.addModifier(modifier);
      }
    });
  }
  commonPositionStyles(node: SceneNode): this {
    this.position(node);
    if ("layoutAlign" in node && "opacity" in node) {
      this.blend(node);
    }
    return this;
  }
  blend(node: SceneNode & LayoutMixin & MinimalBlendMixin): this {
    this.pushModifier(
      swiftuiVisibility(node),
      swiftuiRotation(node),
      swiftuiOpacity(node),
      swiftuiBlendMode(node),
    );
    return this;
  }
  topLeftToCenterOffset(
    x: number,
    y: number,
    node: SceneNode,
    parent: (BaseNode & ChildrenMixin) | null,
  ): { centerX: number; centerY: number } {
    if (!parent || !("width" in parent)) {
      return { centerX: 0, centerY: 0 };
    }
    const centerX = x + node.width / 2;
    const centerY = y + node.height / 2;
    const centerBasedX = centerX - parent.width / 2;
    const centerBasedY = centerY - parent.height / 2;
    return { centerX: centerBasedX, centerY: centerBasedY };
  }
  position(node: SceneNode): this {
    if (commonIsAbsolutePosition(node)) {
      const { x, y } = getCommonPositionValue(node);
      const { centerX, centerY } = this.topLeftToCenterOffset(
        x,
        y,
        node,
        node.parent,
      );
      this.pushModifier([
        `offset`,
        `x: ${numberToFixedString(centerX)}, y: ${numberToFixedString(centerY)}`,
      ]);
    }
    return this;
  }
  shapeBorder(node: SceneNode): this {
    const borders = swiftuiBorder(node);
    if (borders) {
      borders.forEach((border) => {
        this.element.addModifierMixed("overlay", border);
      });
    }
    return this;
  }
  shapeBackground(node: SceneNode): this {
    if ("fills" in node) {
      const background = swiftuiSolidColor(node, "fills");
      if (background) {
        this.pushModifier([`background`, background]);
      }
    }
    return this;
  }
  shapeForeground(node: SceneNode): this {
    if (!("children" in node) || node.children.length === 0) {
      this.pushModifier([`foregroundColor`, ".clear"]);
    }
    return this;
  }
  cornerRadius(node: SceneNode): this {
    const corner = swiftuiCornerRadius(node);
    if (corner) {
      this.pushModifier([`cornerRadius`, corner]);
    }
    return this;
  }
  effects(node: SceneNode): this {
    if (node.type === "GROUP") {
      return this;
    }
    this.pushModifier(swiftuiBlur(node), swiftuiShadow(node));
    return this;
  }
  size(node: SceneNode): this {
    const { width, height, constraints } = swiftuiSize(node);
    if (width || height) {
      this.pushModifier([`frame`, [width, height].filter(Boolean).join(", ")]);
    }
    if (constraints.length > 0) {
      this.pushModifier([`frame`, constraints.join(", ")]);
    }
    return this;
  }
  autoLayoutPadding(node: SceneNode): this {
    if ("paddingLeft" in node) {
      this.pushModifier(swiftuiPadding(node));
    }
    return this;
  }
  build(indentLevel: number = 0): string {
    return this.element.toString(indentLevel);
  }
}
</file>

<file path="packages/backend/src/tailwind/tailwindTextBuilder.ts">
import {
  commonLetterSpacing,
  commonLineHeight,
} from "../common/commonTextHeightSpacing";
import { tailwindColorFromFills } from "./builderImpl/tailwindColor";
import {
  pxToFontSize,
  pxToLetterSpacing,
  pxToLineHeight,
  pxToBlur,
} from "./conversionTables";
import { TailwindDefaultBuilder } from "./tailwindDefaultBuilder";
import { config } from "./tailwindConfig";
import { StyledTextSegmentSubset } from "types";
export class TailwindTextBuilder extends TailwindDefaultBuilder {
  getTextSegments(node: TextNode): {
    style: string;
    text: string;
    openTypeFeatures: { [key: string]: boolean };
  }[] {
    const segments = (node as any)
      .styledTextSegments as StyledTextSegmentSubset[];
    if (!segments) {
      return [];
    }
    return segments.map((segment) => {
      const color = this.getTailwindColorFromFills(segment.fills);
      const textDecoration = this.textDecoration(segment.textDecoration);
      const textTransform = this.textTransform(segment.textCase);
      const lineHeightStyle = this.lineHeight(
        segment.lineHeight,
        segment.fontSize,
      );
      const letterSpacingStyle = this.letterSpacing(
        segment.letterSpacing,
        segment.fontSize,
      );
      const blurStyle = this.layerBlur();
      const shadowStyle = this.textShadow();
      const styleClasses = [
        color,
        this.fontSize(segment.fontSize),
        this.fontWeight(segment.fontWeight),
        this.fontFamily(segment.fontName),
        textDecoration,
        textTransform,
        lineHeightStyle,
        letterSpacingStyle,
        blurStyle,
        shadowStyle,
      ]
        .filter(Boolean)
        .join(" ");
      const charsWithLineBreak = segment.characters.split("\n").join("<br/>");
      return {
        style: styleClasses,
        text: charsWithLineBreak,
        openTypeFeatures: segment.openTypeFeatures,
      };
    });
  }
  getTailwindColorFromFills = (
    fills: ReadonlyArray<Paint> | PluginAPI["mixed"],
  ) => {
    return tailwindColorFromFills(fills, "text");
  };
  fontSize = (fontSize: number) => {
    return `text-${pxToFontSize(fontSize)}`;
  };
  fontWeight = (fontWeight: number): string => {
    const weight = config.fontWeight[fontWeight];
    return weight ? `font-${weight}` : "";
  };
  indentStyle = (indentation: number) => {
    // Convert indentation to the appropriate Tailwind CSS class.
    // This can be based on your project's configuration and spacing scale.
    // For example, suppose your project uses the default Tailwind CSS spacing scale:
    return `pl-${Math.round(indentation)}`;
  };
  fontFamily = (fontName: FontName): string => {
    if (config.fontFamily.sans.includes(fontName.family)) {
      return "font-sans";
    }
    if (config.fontFamily.serif.includes(fontName.family)) {
      return "font-serif";
    }
    if (config.fontFamily.mono.includes(fontName.family)) {
      return "font-mono";
    }
    const underscoreFontName = fontName.family.replace(/\s/g, "_");
    return "font-['" + underscoreFontName + "']";
  };
  fontStyle(node: TextNode): this {
    if (node.fontName !== figma.mixed) {
      const lowercaseStyle = node.fontName.style.toLowerCase();
      if (lowercaseStyle.match("italic")) {
        this.addAttributes("italic");
      }
      if (lowercaseStyle.match("regular")) {
        return this;
      }
      const value = node.fontName.style
        .replaceAll("italic", "")
        .replaceAll(" ", "")
        .toLowerCase();
      this.addAttributes(`font-${value}`);
    }
    return this;
  }
  /**
   * https://tailwindcss.com/docs/letter-spacing/
   * example: tracking-widest
   */
  letterSpacing(letterSpacing: LetterSpacing, fontSize: number): string {
    const letterSpacingProp = commonLetterSpacing(letterSpacing, fontSize);
    if (letterSpacingProp > 0) {
      const value = pxToLetterSpacing(letterSpacingProp);
      return `tracking-${value}`;
    }
    return "";
  }
  /**
   * https://tailwindcss.com/docs/line-height/
   * example: leading-3
   */
  lineHeight(lineHeight: LineHeight, fontSize: number): string {
    const lineHeightProp = commonLineHeight(lineHeight, fontSize);
    if (lineHeightProp > 0) {
      const value = pxToLineHeight(lineHeightProp);
      return `leading-${value}`;
    }
    return "";
  }
  /**
   * https://tailwindcss.com/docs/text-align/
   * example: text-justify
   */
  textAlignHorizontal(): this {
    // if alignHorizontal is LEFT, don't do anything because that is native
    const node = this.node as TextNode;
    // only undefined in testing
    if (node.textAlignHorizontal && node.textAlignHorizontal !== "LEFT") {
      switch (node.textAlignHorizontal) {
        case "CENTER":
          this.addAttributes(`text-center`);
          break;
        case "RIGHT":
          this.addAttributes(`text-right`);
          break;
        case "JUSTIFIED":
          this.addAttributes(`text-justify`);
          break;
        default:
          break;
      }
    }
    return this;
  }
  textAlignVertical(): this {
    const node = this.node as TextNode;
    switch (node.textAlignVertical) {
      case "TOP":
        this.addAttributes("justify-start");
        break;
      case "CENTER":
        this.addAttributes("justify-center");
        break;
      case "BOTTOM":
        this.addAttributes("justify-end");
        break;
      default:
        break;
    }
    return this;
  }
  textTransform(textCase: TextCase): string {
    switch (textCase) {
      case "UPPER":
        return "uppercase";
      case "LOWER":
        return "lowercase";
      case "TITLE":
        return "capitalize";
      case "ORIGINAL":
      case "SMALL_CAPS":
      case "SMALL_CAPS_FORCED":
      default:
        return "";
    }
  }
  /**
   * https://tailwindcss.com/docs/text-decoration/
   * example: underline
   */
  textDecoration(textDecoration: TextDecoration): string {
    switch (textDecoration) {
      case "STRIKETHROUGH":
        return "line-through";
      case "UNDERLINE":
        return "underline";
      case "NONE":
        return "";
    }
  }
  /**
   * https://v3.tailwindcss.com/docs/blur
   */
  layerBlur = (): string => {
    if (this.node && (this.node as TextNode).effects) {
      const effects = (this.node as TextNode).effects;
      const blurEffect = effects.find(
        (effect) => effect.type === "LAYER_BLUR" && effect.visible !== false,
      );
      if (blurEffect && blurEffect.radius && blurEffect.radius > 0) {
        const blurSuffix = pxToBlur(blurEffect.radius);
        if (blurSuffix) {
          return `blur-${blurSuffix}`;
        }
      }
    }
    return "";
  };
  /**
   * New method to handle text shadow.
   * When a drop shadow is applied to a text element,
   * this method returns an arbitrary Tailwind utility class
   * in the following format:
   *
   * [text-shadow:_0px_4px_4px_rgb(0_0_0_/_0.50)]
   */
  textShadow = (): string => {
    if (this.node && (this.node as TextNode).effects) {
      const effects = (this.node as TextNode).effects;
      const dropShadow = effects.find(
        (effect) => effect.type === "DROP_SHADOW" && effect.visible !== false,
      );
      if (dropShadow) {
        const ds = dropShadow as DropShadowEffect;
        const offsetX = Math.round(ds.offset.x);
        const offsetY = Math.round(ds.offset.y);
        const blurRadius = Math.round(ds.radius);
        const r = Math.round(ds.color.r * 255);
        const g = Math.round(ds.color.g * 255);
        const b = Math.round(ds.color.b * 255);
        const aFixed = ds.color.a.toFixed(2);
        return `[text-shadow:_${offsetX}px_${offsetY}px_${blurRadius}px_rgb(${r}_${g}_${b}_/_${aFixed})]`;
      }
    }
    return "";
  };
  reset(): void {
    this.attributes = [];
  }
}
</file>

<file path="packages/plugin-ui/src/components/ColorsPanel.tsx">
import { useState } from "react";
import { SolidColorConversion } from "types";
const ColorsPanel = (props: {
  colors: SolidColorConversion[];
  onColorClick: (color: string) => void;
}) => {
  const [isPressed, setIsPressed] = useState(-1);
  const handleButtonClick = (value: string, idx: number) => {
    setIsPressed(idx);
    setTimeout(() => setIsPressed(-1), 250);
    props.onColorClick(value);
  };
  const formatColorValue = (value: string) => {
    if (value.includes("var(--")) {
      const varMatch = value.match(/var\(--([\w-]+)/);
      return varMatch ? `--${varMatch[1]}` : value;
    }
    return value;
  };
  return (
    <div className="bg-card border w-full rounded-lg p-4 flex flex-col gap-2">
      <div className="p-0 pb-2">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-foreground flex items-center gap-2">
            Color Palette
          </h2>
          <span className="text-xs bg-muted dark:bg-muted px-2 py-1 rounded-xl text-muted-foreground">
            {props.colors.length} color{props.colors.length > 1 ? "s" : ""}
          </span>
        </div>
      </div>
      <div className="grid grid-cols-3 gap-2">
        {props.colors.map((color, idx) => (
          <button
            key={"button" + idx}
            className={`w-full h-16 rounded-lg text-sm font-semibold shadow-sm transition-all duration-300 ${
              isPressed === idx
                ? "ring-4 ring-primary ring-opacity-50 animate-pulse"
                : "ring-0"
            }`}
            style={{ backgroundColor: color.hex }}
            onClick={() => {
              handleButtonClick(color.exportValue, idx);
            }}
            title={color.exportValue}
          >
            <div className="flex flex-col h-full justify-center items-center">
              <span
                className={`text-xs font-semibold ${
                  color.contrastWhite > color.contrastBlack
                    ? "text-white"
                    : "text-black"
                }`}
              >
                {color.colorName ? color.colorName : `#${color.hex}`}
              </span>
              {color.exportValue !== `#${color.hex}` && (
                <span
                  className={`text-[10px] opacity-70 max-w-full truncate px-1 ${
                    color.contrastWhite > color.contrastBlack
                      ? "text-white"
                      : "text-black"
                  }`}
                >
                  {formatColorValue(color.exportValue)}
                </span>
              )}
            </div>
          </button>
        ))}
      </div>
    </div>
  );
};
export default ColorsPanel;
</file>

<file path="packages/plugin-ui/src/components/CopyButton.tsx">
"use client";
import { useState, useEffect } from "react";
import { Copy, Check } from "lucide-react";
import copy from "copy-to-clipboard";
import { cn } from "../lib/utils";
interface CopyButtonProps {
  value: string;
  className?: string;
  showLabel?: boolean;
  successDuration?: number;
  onMouseEnter?: () => void;
  onMouseLeave?: () => void;
}
export function CopyButton({
  value,
  className,
  showLabel = true,
  successDuration = 750,
  onMouseEnter,
  onMouseLeave,
}: CopyButtonProps) {
  const [isCopied, setIsCopied] = useState(false);
  useEffect(() => {
    if (isCopied) {
      const timer = setTimeout(() => {
        setIsCopied(false);
      }, successDuration);
      return () => clearTimeout(timer);
    }
  }, [isCopied, successDuration]);
  const handleCopy = async () => {
    try {
      copy(value);
      setIsCopied(true);
    } catch (error) {
      console.error("Failed to copy text: ", error);
    }
  };
  return (
    <button
      onClick={handleCopy}
      onMouseEnter={onMouseEnter}
      onMouseLeave={onMouseLeave}
      className={cn(
        `inline-flex items-center justify-center px-3 py-1.5 text-sm font-medium rounded-md transition-all duration-300`,
        isCopied
          ? "bg-primary text-primary-foreground"
          : "bg-neutral-100 dark:bg-neutral-700 dark:hover:bg-muted-foreground/30 text-foreground",
        className,
        `relative`,
      )}
      aria-label={isCopied ? "Copied!" : "Copy to clipboard"}
    >
      <div className="relative h-4 w-4 mr-1.5">
        <span
          className={`absolute inset-0 transition-all duration-200 ${
            isCopied
              ? "opacity-0 scale-75 rotate-[-10deg]"
              : "opacity-100 scale-100 rotate-0"
          }`}
        >
          <Copy className="h-4 w-4 text-foreground" />
        </span>
        <span
          className={`absolute inset-0 transition-all duration-200 ${
            isCopied
              ? "opacity-100 scale-100 rotate-0"
              : "opacity-0 scale-75 rotate-[10deg]"
          }`}
        >
          <Check className="h-4 w-4 text-primary-foreground" />
        </span>
      </div>
      {showLabel && (
        <span className="font-medium">{isCopied ? "Copied" : "Copy"}</span>
      )}
      {isCopied && (
        <span
          className="absolute inset-0 rounded-md animate-pulse bg-primary/10"
          aria-hidden="true"
        />
      )}
    </button>
  );
}
</file>

<file path="packages/plugin-ui/src/components/CustomPrefixInput.tsx">
import React, { useState, useRef, useEffect } from "react";
import { HelpCircle, Check } from "lucide-react";
interface FormFieldProps {
  label: string;
  initialValue: string | number;
  onValueChange: (value: string | number) => void;
  placeholder?: string;
  helpText?: string;
  type?: "text" | "number";
  min?: number;
  max?: number;
  suffix?: string;
  disallowedPattern?: RegExp;
  disallowedMessage?: string;
  showPreview?: boolean;
  previewExamples?: string[];
  previewTransform?: (value: string, example: string) => React.ReactNode;
}
const FormField = React.memo(
  ({
    label,
    initialValue,
    onValueChange,
    placeholder,
    helpText,
    type = "text",
    min,
    max,
    suffix,
    disallowedPattern = /\s/,
    disallowedMessage = "Input cannot contain spaces",
    showPreview = false,
    previewExamples = ["flex"],
    previewTransform,
  }: FormFieldProps) => {
    const [inputValue, setInputValue] = useState(String(initialValue));
    const [isFocused, setIsFocused] = useState(false);
    const [hasChanges, setHasChanges] = useState(false);
    const [showSuccess, setShowSuccess] = useState(false);
    const [hasError, setHasError] = useState(false);
    const [errorMessage, setErrorMessage] = useState("");
    const inputRef = useRef<HTMLInputElement>(null);
    // Update internal state when initialValue changes (from parent)
    useEffect(() => {
      setInputValue(String(initialValue));
      setHasChanges(false);
      setHasError(false);
      setErrorMessage("");
    }, [initialValue]);
    const validateInput = (value: string): boolean => {
      // Text validation
      if (type === "text") {
        if (disallowedPattern && disallowedPattern.test(value)) {
          setHasError(true);
          setErrorMessage(disallowedMessage);
          return false;
        }
        setHasError(false);
        setErrorMessage("");
        return true;
      }
      // Number validation
      if (type === "number") {
        if (/[^0-9]/.test(value)) {
          setHasError(true);
          setErrorMessage("Only numbers are allowed");
          return false;
        }
        const numValue = parseInt(value, 10);
        if (isNaN(numValue)) {
          setHasError(true);
          setErrorMessage("Please enter a valid number");
          return false;
        }
        if (min !== undefined && numValue < min) {
          setHasError(true);
          setErrorMessage(`Minimum value is ${min}`);
          return false;
        }
        if (max !== undefined && numValue > max) {
          setHasError(true);
          setErrorMessage(`Maximum value is ${max}`);
          return false;
        }
        setHasError(false);
        setErrorMessage("");
        return true;
      }
      return true;
    };
    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const newValue = e.target.value;
      setInputValue(newValue);
      validateInput(newValue);
      setHasChanges(newValue !== String(initialValue));
    };
    const applyChanges = () => {
      if (hasError) return;
      if (type === "number") {
        const numValue = parseInt(inputValue, 10);
        if (!isNaN(numValue)) {
          onValueChange(numValue);
        }
      } else {
        onValueChange(inputValue);
      }
      setHasChanges(false);
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 1500);
    };
    const handleBlur = () => {
      setIsFocused(false);
    };
    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
      if (e.key === "Enter") {
        e.preventDefault();
        applyChanges();
        inputRef.current?.blur();
      }
    };
    const defaultPreviewTransform = (value: string, example: string) => (
      <div className="flex items-center gap-1.5">
        <div className="py-0.5 px-1.5 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-sm text-xs font-mono">
          <span className="text-green-500 dark:text-green-400">{value}</span>
          <span className="text-blue-500 dark:text-blue-400">{example}</span>
        </div>
        <span className="text-xs text-gray-400 dark:text-gray-500"></span>
        <div className="py-0.5 px-1.5 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-sm text-xs font-mono text-blue-500 dark:text-blue-400">
          {example}
        </div>
      </div>
    );
    const renderPreview = previewTransform || defaultPreviewTransform;
    return (
      <div className="mt-2 mb-1">
        <div className="flex items-center gap-1.5 mb-1.5">
          <label className="text-xs font-medium text-gray-700 dark:text-gray-300">
            {label}
          </label>
          {helpText && (
            <div className="relative group">
              <HelpCircle className="w-3 h-3 text-gray-400" />
              <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-1.5 w-56 p-2 bg-white dark:bg-gray-800 shadow-lg rounded-sm border border-gray-200 dark:border-gray-700 text-xs hidden group-hover:block z-10">
                {helpText}
                <div className="absolute top-full left-1/2 transform -translate-x-1/2 -mt-1 border-l-4 border-r-4 border-t-4 border-l-transparent border-r-transparent border-t-white dark:border-t-gray-800"></div>
              </div>
            </div>
          )}
          {showSuccess && (
            <span className="text-xs text-green-500 flex items-center gap-1 animate-fade-in-out">
              <Check className="w-3 h-3" /> Applied
            </span>
          )}
        </div>
        <div className="flex w-full items-start gap-2">
          <div className="flex-1 flex flex-col">
            <div className="flex items-center">
              <input
                ref={inputRef}
                type="text"
                value={inputValue}
                onChange={handleChange}
                onFocus={() => setIsFocused(true)}
                onBlur={handleBlur}
                onKeyDown={handleKeyDown}
                placeholder={placeholder}
                className={`p-1.5 px-2.5 text-sm w-full transition-all focus:outline-hidden ${
                  suffix ? "rounded-l-md" : "rounded-md"
                } ${
                  hasError
                    ? "border border-red-300 dark:border-red-700 bg-red-50 dark:bg-red-900/20"
                    : isFocused
                      ? "border border-green-400 dark:border-green-600 ring-1 ring-green-300 dark:ring-green-800 bg-white dark:bg-neutral-800"
                      : "border border-gray-300 dark:border-gray-600 bg-white dark:bg-neutral-800 hover:border-gray-400 dark:hover:border-gray-500"
                }`}
              />
              {suffix && (
                <span
                  className="py-1.5 px-2.5 text-sm border border-l-0 border-gray-300 dark:border-gray-600
                bg-gray-100 dark:bg-gray-700 rounded-r-md text-gray-700 dark:text-gray-300"
                >
                  {suffix}
                </span>
              )}
            </div>
            {hasError && (
              <p className="text-xs text-red-500 mt-1">{errorMessage}</p>
            )}
          </div>
          {hasChanges && (
            <button
              onClick={applyChanges}
              disabled={hasError}
              className={`px-3 py-1.5 rounded-md text-sm font-medium transition-colors ${
                hasError
                  ? "bg-gray-200 text-gray-500 dark:bg-gray-800 dark:text-gray-600 cursor-not-allowed"
                  : "bg-green-100 text-green-700 hover:bg-green-200 dark:bg-green-900/30 dark:text-green-400 dark:hover:bg-green-900/50"
              }`}
            >
              Done
            </button>
          )}
        </div>
        {showPreview && inputValue && !hasError && (
          <div className="flex flex-col w-full mt-2.5 rounded-md bg-gray-50 dark:bg-gray-800/50 p-2.5 border border-gray-200 dark:border-gray-700">
            <p className="text-xs text-gray-500 dark:text-gray-400 mb-2">
              Preview{hasChanges ? " (not applied yet)" : ""}:
            </p>
            <div className="flex flex-wrap gap-1.5">
              {previewExamples.map((example) => (
                <React.Fragment key={example}>
                  {renderPreview(inputValue, example)}
                </React.Fragment>
              ))}
            </div>
            {hasChanges && (
              <p className="text-xs text-amber-500 dark:text-amber-400 mt-2 italic">
                Press Enter or click Done to apply changes
              </p>
            )}
          </div>
        )}
      </div>
    );
  },
);
FormField.displayName = "FormField";
export default FormField;
</file>

<file path="packages/plugin-ui/src/components/EmptyState.tsx">
import React from "react";
import { Code, MousePointer, Eye, Copy } from "lucide-react";
const EmptyState = () => {
  return (
    <div className="flex flex-col items-center justify-center p-8 bg-card/50 border border-dashed border-neutral-300 dark:border-neutral-600 rounded-lg text-center">
      {}
      <div className="w-16 h-16 bg-linear-to-br from-neutral-100 to-neutral-200 dark:from-neutral-700 dark:to-neutral-800 rounded-full flex items-center justify-center mb-5 shadow-2xs">
        <div className="relative">
          <Code size={24} className="text-neutral-500 dark:text-neutral-400" />
          <svg
            className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-neutral-400 dark:text-neutral-500"
            width="36"
            height="36"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="1.5"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <circle cx="12" cy="12" r="10" />
            <line x1="8" y1="12" x2="16" y2="12" />
          </svg>
        </div>
      </div>
      {}
      <h3 className="text-lg font-medium text-neutral-800 dark:text-neutral-200 mb-2">
        No Layer Selected
      </h3>
      <p className="text-neutral-500 dark:text-neutral-400 max-w-xs mb-8">
        Select a layer from your Figma design to view the generated code.
      </p>
      {}
      <div className="w-full max-w-xs">
        <div className="relative">
          {}
          <div className="absolute top-4 left-0 w-full h-0.5 bg-neutral-200 dark:bg-neutral-700"></div>
          {}
          <ol className="relative flex justify-between">
            {}
            <li className="flex flex-col items-center">
              <div className="relative z-10">
                <div className="absolute -inset-1.5 rounded-full bg-green-100 dark:bg-green-900/20 animate-pulse-slow"></div>
                <div className="relative flex items-center justify-center w-8 h-8 bg-green-500 dark:bg-green-600 rounded-full text-white">
                  <MousePointer size={15} />
                </div>
              </div>
              <div className="mt-3 text-center">
                <div className="font-medium text-sm text-green-600 dark:text-green-500">
                  Select
                </div>
                <p className="mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                  Choose a layer
                </p>
              </div>
            </li>
            {}
            <li className="flex flex-col items-center">
              <div className="z-10 flex items-center justify-center w-8 h-8 bg-white dark:bg-neutral-800 border-2 border-neutral-300 dark:border-neutral-600 rounded-full text-neutral-400 dark:text-neutral-500">
                <Eye size={15} />
              </div>
              <div className="mt-3 text-center">
                <div className="font-medium text-sm text-neutral-600 dark:text-neutral-400">
                  View
                </div>
                <p className="mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                  See the code
                </p>
              </div>
            </li>
            {}
            <li className="flex flex-col items-center">
              <div className="z-10 flex items-center justify-center w-8 h-8 bg-white dark:bg-neutral-800 border-2 border-neutral-300 dark:border-neutral-600 rounded-full text-neutral-400 dark:text-neutral-500">
                <Copy size={15} />
              </div>
              <div className="mt-3 text-center">
                <div className="font-medium text-sm text-neutral-600 dark:text-neutral-400">
                  Copy
                </div>
                <p className="mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                  Use anywhere
                </p>
              </div>
            </li>
          </ol>
        </div>
      </div>
    </div>
  );
};
export default EmptyState;
</file>

<file path="packages/plugin-ui/src/components/FrameworkTabs.tsx">
import React from "react";
type Option = {
  value: string;
  label: string;
};
interface FrameworkTabsProps {
  options: Option[];
  selectedValue: string;
  onChange: (value: string) => void;
}
const FrameworkTabs: React.FC<FrameworkTabsProps> = ({
  options,
  selectedValue,
  onChange,
}) => {
  return (
    <div className="flex flex-wrap gap-1 my-2">
      <div className="flex flex-wrap bg-muted p-1 rounded-lg gap-1 w-fit">
        {options.map((option) => {
          const isSelected = option.value === selectedValue;
          return (
            <button
              key={option.value}
              onClick={() => onChange(option.value)}
              className={`py-1.5 px-3 rounded-md text-xs font-medium transition-all duration-200 ${
                isSelected
                  ? "bg-blue-500 dark:bg-blue-500 text-primary-foreground shadow-2xs"
                  : "hover:bg-muted-foreground/10 text-muted-foreground"
              }`}
            >
              {option.label}
            </button>
          );
        })}
      </div>
    </div>
  );
};
export default FrameworkTabs;
</file>

<file path="packages/plugin-ui/src/components/GradientsPanel.tsx">
import React from "react";
import { useState } from "react";
const GradientsPanel = (props: {
  gradients: {
    cssPreview: string;
    exportValue: string;
  }[];
  onColorClick: (color: string) => void;
}) => {
  const [isPressed, setIsPressed] = useState(-1);
  const handleButtonClick = (value: string, idx: number) => {
    setIsPressed(idx);
    setTimeout(() => setIsPressed(-1), 250);
    props.onColorClick(value);
  };
  return (
    <div className="bg-card border w-full rounded-lg p-4 flex flex-col gap-2">
      <div className="p-0 pb-2">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold text-neutral-800 dark:text-neutral-100 flex items-center gap-2">
            {}
            Gradients
          </h2>
          <span className="text-xs bg-neutral-100 dark:bg-neutral-700 px-2 py-1 rounded-full text-neutral-500 dark:text-neutral-400">
            {props.gradients.length} gradient
            {props.gradients.length > 1 ? "s" : ""}
          </span>
        </div>
      </div>
      <div className="grid grid-cols-3 gap-2">
        {props.gradients.map((gradient, idx) => (
          <button
            key={"button" + idx}
            className={`w-full h-16 rounded-lg text-sm shadow-sm transition-all duration-300 ${
              isPressed === idx
                ? "ring-4 ring-green-300 ring-opacity-50 animate-pulse"
                : "ring-0"
            }`}
            style={{ background: gradient.cssPreview }}
            onClick={() => {
              handleButtonClick(gradient.exportValue, idx);
            }}
          ></button>
        ))}
      </div>
    </div>
  );
};
export default GradientsPanel;
</file>

<file path="packages/plugin-ui/src/components/WarningsPanel.tsx">
import React, { useState } from "react";
import {
  AlertTriangle,
  ChevronDown,
  ChevronUp,
  XCircle,
  AlertOctagon,
  ExternalLink,
  Info,
} from "lucide-react";
import { Warning } from "types";
interface WarningsPanelProps {
  warnings: Warning[];
}
const categorizeWarnings = (warnings: Warning[]) => {
  const critical = warnings.filter(
    (w) =>
      w.toString().toLowerCase().includes("error") ||
      w.toString().toLowerCase().includes("critical") ||
      w.toString().toLowerCase().includes("missing"),
  );
  const standard = warnings.filter((w) => !critical.includes(w));
  return { critical, standard };
};
const WarningsPanel: React.FC<WarningsPanelProps> = ({ warnings }) => {
  const [isCollapsed, setIsCollapsed] = useState(false);
  const [activeTab, setActiveTab] = useState<"all" | "critical" | "standard">(
    "all",
  );
  const { critical, standard } = categorizeWarnings(warnings);
  if (warnings.length === 0) return null;
  const displayedWarnings =
    activeTab === "all"
      ? warnings
      : activeTab === "critical"
        ? critical
        : standard;
  return (
    <div className="bg-white dark:bg-neutral-800 border border-amber-200 dark:border-amber-700 rounded-md shadow-2xs overflow-hidden w-full">
      {}
      <div
        className="flex items-center justify-between py-2 px-3 border-b border-amber-100 dark:border-amber-800/50 bg-amber-50 dark:bg-amber-900/20 cursor-pointer hover:bg-amber-100/70 dark:hover:bg-amber-900/30 transition-colors"
        onClick={() => setIsCollapsed(!isCollapsed)}
      >
        <div className="flex items-center gap-2">
          <div className="text-amber-500 dark:text-amber-400">
            <AlertTriangle size={16} />
          </div>
          <div className="flex items-center gap-2">
            <h3 className="font-medium text-amber-900 dark:text-amber-200 text-sm">
              {warnings.length} {warnings.length === 1 ? "Warning" : "Warnings"}
            </h3>
            {critical.length > 0 && (
              <span className="px-1.5 py-0.5 bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-full text-xs">
                {critical.length} critical
              </span>
            )}
          </div>
        </div>
        <button
          className="p-1 hover:bg-amber-200/70 dark:hover:bg-amber-800/50 rounded-sm text-amber-700 dark:text-amber-300 transition-colors"
          aria-label={isCollapsed ? "Expand warnings" : "Collapse warnings"}
        >
          {isCollapsed ? <ChevronDown size={16} /> : <ChevronUp size={16} />}
        </button>
      </div>
      {}
      {!isCollapsed && (
        <div className="p-2.5">
          {}
          {critical.length > 0 && standard.length > 0 && (
            <div className="flex mb-2 bg-neutral-100 dark:bg-neutral-800 p-0.5 rounded-sm">
              <button
                className={`px-2 py-1 text-xs font-medium rounded transition-colors flex-1 ${
                  activeTab === "all"
                    ? "bg-white dark:bg-neutral-700 shadow-2xs"
                    : "text-neutral-600 dark:text-neutral-300 hover:bg-white/50 dark:hover:bg-neutral-700/50"
                }`}
                onClick={() => setActiveTab("all")}
              >
                All ({warnings.length})
              </button>
              <button
                className={`px-2 py-1 text-xs font-medium rounded transition-colors flex-1 flex items-center justify-center gap-1 ${
                  activeTab === "critical"
                    ? "bg-white dark:bg-neutral-700 shadow-2xs text-red-600 dark:text-red-400"
                    : "text-neutral-600 dark:text-neutral-300 hover:bg-white/50 dark:hover:bg-neutral-700/50"
                }`}
                onClick={() => setActiveTab("critical")}
              >
                <AlertOctagon size={12} />
                <span>Critical ({critical.length})</span>
              </button>
              <button
                className={`px-2 py-1 text-xs font-medium rounded transition-colors flex-1 flex items-center justify-center gap-1 ${
                  activeTab === "standard"
                    ? "bg-white dark:bg-neutral-700 shadow-2xs text-amber-600 dark:text-amber-400"
                    : "text-neutral-600 dark:text-neutral-300 hover:bg-white/50 dark:hover:bg-neutral-700/50"
                }`}
                onClick={() => setActiveTab("standard")}
              >
                <Info size={12} />
                <span>Other ({standard.length})</span>
              </button>
            </div>
          )}
          {}
          <div className="space-y-1.5 max-h-[200px] overflow-y-auto pb-0.5">
            {displayedWarnings.map((message, index) => {
              const isCritical = critical.includes(message);
              return (
                <div
                  key={index}
                  className={`rounded border ${
                    isCritical
                      ? "border-red-200 dark:border-red-800/30"
                      : "border-amber-200 dark:border-amber-800/30"
                  } overflow-hidden animate-fadeIn`}
                >
                  <div
                    className={`flex items-start gap-2 py-1.5 px-2 ${
                      isCritical
                        ? "bg-red-50/50 dark:bg-red-900/5"
                        : "bg-amber-50/50 dark:bg-amber-900/5"
                    }`}
                  >
                    <div
                      className={`mt-0.5 shrink-0 ${
                        isCritical
                          ? "text-red-500 dark:text-red-400"
                          : "text-amber-500 dark:text-amber-400"
                      }`}
                    >
                      {isCritical ? (
                        <AlertOctagon size={12} />
                      ) : (
                        <XCircle size={12} />
                      )}
                    </div>
                    <div className="flex-1">
                      <p
                        className={`text-xs ${isCritical ? "text-red-700 dark:text-red-300" : "text-amber-700 dark:text-amber-300"}`}
                      >
                        {message.toString()}
                      </p>
                      {}
                      {isCritical && (
                        <div className="mt-1 bg-white/70 dark:bg-black/20 rounded-sm py-1 px-2 text-neutral-600 dark:text-neutral-400 border-l border-red-300 dark:border-red-500 text-xs">
                          <span className="font-medium">Tip: </span>
                          {suggestFixForWarning(message.toString())}
                        </div>
                      )}
                    </div>
                    {}
                    {shouldShowActionButtons(message.toString()) && (
                      <a
                        href={getDocsLinkForWarning(message.toString())}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="shrink-0 flex items-center text-xs text-blue-600 dark:text-blue-400 hover:underline mt-0.5"
                      >
                        <span>Info</span>
                        <ExternalLink size={10} className="ml-0.5" />
                      </a>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
          {}
          {displayedWarnings.length > 0 && (
            <div className="mt-2 py-1 px-1 text-xs text-neutral-500 dark:text-neutral-400 bg-neutral-50 dark:bg-neutral-800/50 rounded-sm border-neutral-200 dark:border-neutral-700 flex items-center gap-1.5">
              {}
              <span>
                Addressing warnings can improve the quality of the generated
                code.
              </span>
            </div>
          )}
        </div>
      )}
    </div>
  );
};
const suggestFixForWarning = (warning: string): string => {
  if (warning.toLowerCase().includes("missing")) {
    return "Add the required properties to your component or select a parent element that includes all necessary children.";
  }
  if (warning.toLowerCase().includes("unsupported")) {
    return "Consider using a different element type or simplifying the design for better conversion results.";
  }
  return "Check your design elements and ensure they follow the recommended structure for code conversion.";
};
const shouldShowActionButtons = (warning: string): boolean => {
  return (
    warning.toLowerCase().includes("unsupported") ||
    warning.toLowerCase().includes("missing")
  );
};
const getDocsLinkForWarning = (warning: string): string => {
  if (warning.toLowerCase().includes("unsupported")) {
    return "https://github.com/bernaferrari/figma-to-code/wiki/Supported-Elements";
  }
  return "https://github.com/bernaferrari/figma-to-code/wiki";
};
export default WarningsPanel;
</file>

<file path="packages/types/package.json">
{
  "name": "types",
  "version": "0.0.0",
  "private": true,
  "license": "GPT-3",
  "sideEffects": false,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "files": [
    "dist/**"
  ],
  "scripts": {
    "lint": "eslint \"src/**/*.ts*\""
  },
  "dependencies": {
    "@figma/plugin-typings": "^1.109.0",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "tsconfig": "workspace:*"
  },
  "devDependencies": {
    "eslint": "^9.23.0",
    "eslint-config-custom": "workspace:*",
    "typescript": "^5.8.2"
  }
}
</file>

<file path="packages/backend/src/altNodes/altNodeUtils.ts">
import { AltNode } from "types";
import { curry } from "../common/curry";
import { exportAsyncProxy } from "../common/exportAsyncProxy";
import { addWarning } from "../common/commonConversionWarnings";
export const overrideReadonlyProperty = curry(
  <T, K extends keyof T>(prop: K, value: any, obj: T): T =>
    Object.defineProperty(obj, prop, {
      value: value,
      writable: true,
      configurable: true,
    }),
);
export const assignParent = overrideReadonlyProperty("parent");
export const assignChildren = overrideReadonlyProperty("children");
export const assignType = overrideReadonlyProperty("type");
export const assignRectangleType = assignType("RECTANGLE");
export function isNotEmpty<TValue>(
  value: TValue | null | undefined,
): value is TValue {
  return value !== null && value !== undefined;
}
export const isTypeOrGroupOfTypes = curry(
  (matchTypes: NodeType[], node: SceneNode): boolean => {
    if (matchTypes.includes(node.type)) return true;
    if ("children" in node) {
      for (let i = 0; i < node.children.length; i++) {
        const childNode = node.children[i];
        const result = isTypeOrGroupOfTypes(matchTypes, childNode);
        if (!result) {
          return false;
        }
      }
      return node.children.length > 0;
    }
    return false;
  },
);
export const isSVGNode = (node: SceneNode) => {
  const altNode = node as AltNode<typeof node>;
  return altNode.canBeFlattened;
};
export const renderAndAttachSVG = async (node: any) => {
  if (node.canBeFlattened) {
    if (node.svg) {
      return node;
    }
    try {
      const svg = (await exportAsyncProxy<string>(node, {
        format: "SVG_STRING",
      })) as string;
      node.svg = svg;
    } catch (error) {
      addWarning(`Failed rendering SVG for ${node.name}`);
      console.error(`Error rendering SVG for ${node.type}:${node.id}`);
      console.error(error);
    }
  }
  return node;
};
</file>

<file path="packages/backend/src/flutter/builderImpl/flutterColor.ts">
import { StarNode } from "./../../api_types";
import { rgbTo8hex } from "../../common/color";
import { addWarning } from "../../common/commonConversionWarnings";
import {
  generateWidgetCode,
  numberToFixedString,
} from "../../common/numToAutoFixed";
import { retrieveTopFill } from "../../common/retrieveFill";
import { getPlaceholderImage } from "../../common/images";
import { GradientPaint, ImagePaint, Paint } from "../../api_types";
export const flutterColorFromFills = (
  node: SceneNode,
  propertyPath: string,
): string => {
  let fills: ReadonlyArray<Paint> = node[
    propertyPath as keyof SceneNode
  ] as ReadonlyArray<Paint>;
  return flutterColorFromDirectFills(fills);
};
export const flutterColorFromDirectFills = (
  fills: ReadonlyArray<Paint>,
): string => {
  const fill = retrieveTopFill(fills);
  if (fill && fill.type === "SOLID") {
    return flutterColor(
      fill.color,
      fill.opacity ?? 1.0,
      (fill as any).variableColorName,
    );
  } else if (
    fill &&
    (fill.type === "GRADIENT_LINEAR" ||
      fill.type === "GRADIENT_ANGULAR" ||
      fill.type === "GRADIENT_RADIAL")
  ) {
    if (fill.gradientStops.length > 0) {
      const stop = fill.gradientStops[0];
      return flutterColor(
        stop.color,
        fill.opacity ?? 1.0,
        (stop as any).variableColorName,
      );
    }
  }
  return "";
};
/**
 * Get box decoration properties for a Flutter node
 */
export const flutterBoxDecorationColor = (
  node: SceneNode,
  propertyPath: string,
): Record<string, string> => {
  let fills: ReadonlyArray<Paint>;
  fills = node[propertyPath as keyof SceneNode] as ReadonlyArray<Paint>;
  const fill = retrieveTopFill(fills);
  if (fill && fill.type === "SOLID") {
    const opacity = fill.opacity ?? 1.0;
    return {
      color: flutterColor(fill.color, opacity, (fill as any).variableColorName),
    };
  } else if (
    fill?.type === "GRADIENT_LINEAR" ||
    fill?.type === "GRADIENT_RADIAL" ||
    fill?.type === "GRADIENT_ANGULAR"
  ) {
    return { gradient: flutterGradient(fill) };
  } else if (fill?.type === "IMAGE") {
    return { image: flutterDecorationImage(node, fill) };
  }
  return {};
};
export const flutterDecorationImage = (node: SceneNode, fill: ImagePaint) => {
  addWarning("Image fills are replaced with placeholders");
  return generateWidgetCode("DecorationImage", {
    image: `NetworkImage("${getPlaceholderImage(node.width, node.height)}")`,
    fit: fitToBoxFit(fill),
  });
};
const fitToBoxFit = (fill: ImagePaint): string => {
  switch (fill.scaleMode) {
    case "FILL":
      return "BoxFit.cover";
    case "FIT":
      return "BoxFit.contain";
    case "STRETCH":
      return "BoxFit.fill";
    case "TILE":
      return "BoxFit.none";
    default:
      return "BoxFit.cover";
  }
};
export const flutterGradient = (fill: GradientPaint): string => {
  switch (fill.type) {
    case "GRADIENT_LINEAR":
      return flutterLinearGradient(fill);
    case "GRADIENT_RADIAL":
      return flutterRadialGradient(fill);
    case "GRADIENT_ANGULAR":
      return flutterAngularGradient(fill);
    default:
      addWarning("Diamond dradients are not supported in Flutter");
      return "";
  }
};
/**
 * Generate a Flutter LinearGradient widget
 * @param fill The linear gradient fill
 * @returns LinearGradient widget code
 */
const flutterLinearGradient = (fill: GradientPaint): string => {
  const [start, end] = fill.gradientHandlePositions;
  const colors = fill.gradientStops
    .map((d) => flutterColor(d.color, d.color.a, (d as any).variableColorName))
    .join(", ");
  return generateWidgetCode("LinearGradient", {
    begin: `Alignment(${start.x.toFixed(2)}, ${start.y.toFixed(2)})`,
    end: `Alignment(${end.x.toFixed(2)}, ${end.y.toFixed(2)})`,
    colors: `[${colors}]`,
  });
};
const flutterRadialGradient = (fill: GradientPaint): string => {
  const [center, h1, h2] = (fill as any).gradientHandlePositions;
  const radius1 = Math.sqrt((h1.x - center.x) ** 2 + (h1.y - center.y) ** 2);
  const radius2 = Math.sqrt((h2.x - center.x) ** 2 + (h2.y - center.y) ** 2);
  const radius = Math.max(radius1, radius2);
  const colors = fill.gradientStops
    .map((d) => flutterColor(d.color, d.color.a, (d as any).variableColorName))
    .join(", ");
  return generateWidgetCode("RadialGradient", {
    center: `Alignment(${center.x.toFixed(2)}, ${center.y.toFixed(2)})`,
    radius: radius.toFixed(2),
    colors: `[${colors}]`,
  });
};
const figmaToFlutterAlignment = (x: number, y: number): string => {
  const alignmentX = x * 2 - 1;
  const alignmentY = y * 2 - 1;
  return `Alignment(${numberToFixedString(alignmentX)}, ${numberToFixedString(alignmentY)})`;
};
export const flutterAngularGradient = (fill: GradientPaint): string => {
  const [center, _, startDirection] = fill.gradientHandlePositions;
  const centerAlignment = figmaToFlutterAlignment(center.x, center.y);
  const dx = startDirection.x - center.x;
  const dy = startDirection.y - center.y;
  const startAngle = -(90 * Math.PI) / 180 + Math.atan2(dy, dx);
  const colors = fill.gradientStops
    .map((stop) => flutterColor(stop.color, stop.color.a))
    .join(", ");
  const stops = fill.gradientStops
    .map((stop) => numberToFixedString(stop.position))
    .join(", ");
  return generateWidgetCode("SweepGradient", {
    center: centerAlignment,
    startAngle: numberToFixedString(startAngle),
    endAngle: numberToFixedString(startAngle + 2 * Math.PI),
    colors: `[${colors}]`,
    stops: `[${stops}]`,
    transform: `GradientRotation(${numberToFixedString(startAngle)})`,
  });
};
const opacityToAlpha = (opacity: number): number => {
  return Math.round(opacity * 255);
};
export const flutterColor = (
  color: RGB,
  opacity: number,
  variableColorName?: string,
): string => {
  const sum = color.r + color.g + color.b;
  let colorCode = "";
  if (sum === 0) {
    colorCode =
      opacity === 1
        ? "Colors.black"
        : `Colors.black.withValues(alpha: ${opacityToAlpha(opacity)})`;
  } else if (sum === 3) {
    colorCode =
      opacity === 1
        ? "Colors.white"
        : `Colors.white.withValues(alpha: ${opacityToAlpha(opacity)})`;
  } else {
    colorCode = `const Color(0x${rgbTo8hex(color, opacity).toUpperCase()})`;
  }
  if (variableColorName) {
    return `${colorCode} /* ${variableColorName} */`;
  }
  return colorCode;
};
</file>

<file path="packages/backend/src/html/builderImpl/htmlAutoLayout.ts">
import { HTMLSettings } from "types";
import { formatMultipleJSXArray } from "../../common/parseJSX";
const getFlexDirection = (node: InferredAutoLayoutResult): string =>
  node.layoutMode === "HORIZONTAL" ? "" : "column";
const getJustifyContent = (node: InferredAutoLayoutResult): string => {
  switch (node.primaryAxisAlignItems) {
    case undefined:
    case "MIN":
      return "flex-start";
    case "CENTER":
      return "center";
    case "MAX":
      return "flex-end";
    case "SPACE_BETWEEN":
      return "space-between";
  }
};
const getAlignItems = (node: InferredAutoLayoutResult): string => {
  switch (node.counterAxisAlignItems) {
    case undefined:
    case "MIN":
      return "flex-start";
    case "CENTER":
      return "center";
    case "MAX":
      return "flex-end";
    case "BASELINE":
      return "baseline";
  }
};
const getGap = (node: InferredAutoLayoutResult): string | number =>
  node.itemSpacing > 0 && node.primaryAxisAlignItems !== "SPACE_BETWEEN"
    ? node.itemSpacing
    : "";
const getFlexWrap = (node: InferredAutoLayoutResult): string =>
  node.layoutWrap === "WRAP" ? "wrap" : "";
const getAlignContent = (node: InferredAutoLayoutResult): string => {
  if (node.layoutWrap !== "WRAP") return "";
  switch (node.counterAxisAlignItems) {
    case undefined:
    case "MIN":
      return "flex-start";
    case "CENTER":
      return "center";
    case "MAX":
      return "flex-end";
    case "BASELINE":
      return "baseline";
    default:
      return "normal";
  }
};
const getFlex = (
  node: SceneNode,
  autoLayout: InferredAutoLayoutResult,
): string =>
  node.parent &&
  "layoutMode" in node.parent &&
  node.parent.layoutMode === autoLayout.layoutMode
    ? "flex"
    : "inline-flex";
export const htmlAutoLayoutProps = (
  node: SceneNode & InferredAutoLayoutResult,
  settings: HTMLSettings,
): string[] =>
  formatMultipleJSXArray(
    {
      "flex-direction": getFlexDirection(node),
      "justify-content": getJustifyContent(node),
      "align-items": getAlignItems(node),
      gap: getGap(node),
      display: getFlex(node, node),
      "flex-wrap": getFlexWrap(node),
      "align-content": getAlignContent(node),
    },
    settings.htmlGenerationMode === "jsx",
  );
</file>

<file path="packages/backend/src/swiftui/swiftuiMain.ts">
import { indentString } from "../common/indentString";
import {
  stringToClassName,
  numberToFixedString,
} from "../common/numToAutoFixed";
import { SwiftuiTextBuilder } from "./swiftuiTextBuilder";
import { SwiftuiDefaultBuilder } from "./swiftuiDefaultBuilder";
import { PluginSettings } from "types";
import { addWarning } from "../common/commonConversionWarnings";
import { getVisibleNodes } from "../common/nodeVisibility";
let localSettings: PluginSettings;
let previousExecutionCache: string[];
const getStructTemplate = (name: string, injectCode: string): string =>
  `struct ${name}: View {
  var body: some View {
    ${indentString(injectCode, 4).trimStart()};
  }
}`;
const getPreviewTemplate = (name: string, injectCode: string): string =>
  `import SwiftUI
struct ContentView: View {
  var body: some View {
    ${indentString(injectCode, 4).trimStart()};
  }
}
struct ContentView_Previews: PreviewProvider {
  static var previews: some View {
    ContentView()
  }
}`;
export const swiftuiMain = (
  sceneNode: Array<SceneNode>,
  settings: PluginSettings,
): string => {
  localSettings = settings;
  previousExecutionCache = [];
  let result = swiftuiWidgetGenerator(sceneNode, 0);
  switch (localSettings.swiftUIGenerationMode) {
    case "snippet":
      return result;
    case "struct":
      return getStructTemplate(stringToClassName(sceneNode[0].name), result);
    case "preview":
      return getPreviewTemplate(stringToClassName(sceneNode[0].name), result);
  }
  if (result.length > 0 && result.startsWith("\n")) {
    result = result.slice(1, result.length);
  }
  return result;
};
const swiftuiWidgetGenerator = (
  sceneNode: ReadonlyArray<SceneNode>,
  indentLevel: number,
): string => {
  const visibleSceneNode = getVisibleNodes(sceneNode);
  let comp: string[] = [];
  visibleSceneNode.forEach((node) => {
    switch (node.type) {
      case "RECTANGLE":
      case "ELLIPSE":
      case "LINE":
        comp.push(swiftuiContainer(node));
        break;
      case "GROUP":
      case "SECTION":
        comp.push(swiftuiGroup(node, indentLevel));
        break;
      case "FRAME":
      case "INSTANCE":
      case "COMPONENT":
      case "COMPONENT_SET":
        comp.push(swiftuiFrame(node, indentLevel));
        break;
      case "TEXT":
        comp.push(swiftuiText(node));
        break;
      case "VECTOR":
        addWarning("VectorNodes are not supported in SwiftUI");
        break;
      case "SLICE":
      default:
        break;
    }
  });
  return comp.join("\n");
};
export const swiftuiContainer = (
  node: SceneNode,
  stack: string = "",
): string => {
  // ignore the view when size is zero or less
  // while technically it shouldn't get less than 0, due to rounding errors,
  // it can get to values like: -0.000004196293048153166
  if (node.width < 0 || node.height < 0) {
    return stack;
  }
  let kind = "";
  if (node.type === "RECTANGLE" || node.type === "LINE") {
    kind = "Rectangle()";
  } else if (node.type === "ELLIPSE") {
    kind = "Ellipse()";
  } else {
    kind = stack;
  }
  const result = new SwiftuiDefaultBuilder(kind)
    .shapeForeground(node)
    .autoLayoutPadding(node)
    .size(node)
    .shapeBackground(node)
    .cornerRadius(node)
    .shapeBorder(node)
    .commonPositionStyles(node)
    .effects(node)
    .build(kind === stack ? -2 : 0);
  return result;
};
const swiftuiGroup = (
  node: GroupNode | SectionNode,
  indentLevel: number,
): string => {
  const children = widgetGeneratorWithLimits(node, indentLevel);
  return swiftuiContainer(
    node,
    children ? generateSwiftViewCode("ZStack", {}, children) : `ZStack() { }`,
  );
};
const swiftuiText = (node: TextNode): string => {
  const result = new SwiftuiTextBuilder().createText(node);
  previousExecutionCache.push(result.build());
  return result.commonPositionStyles(node).build();
};
const swiftuiFrame = (
  node: SceneNode & BaseFrameMixin,
  indentLevel: number,
): string => {
  const children = widgetGeneratorWithLimits(
    node,
    node.children.length > 1 ? indentLevel + 1 : indentLevel,
  );
  const anyStack = createDirectionalStack(children, node);
  return swiftuiContainer(node, anyStack);
};
const createDirectionalStack = (
  children: string,
  inferredAutoLayout: InferredAutoLayoutResult,
): string => {
  if (inferredAutoLayout.layoutMode !== "NONE") {
    return generateSwiftViewCode(
      inferredAutoLayout.layoutMode === "HORIZONTAL" ? "HStack" : "VStack",
      {
        alignment: getLayoutAlignment(inferredAutoLayout),
        spacing: getSpacing(inferredAutoLayout),
      },
      children,
    );
  } else {
    return generateSwiftViewCode("ZStack", {}, children);
  }
};
const getLayoutAlignment = (
  inferredAutoLayout: InferredAutoLayoutResult,
): string => {
  switch (inferredAutoLayout.counterAxisAlignItems) {
    case "MIN":
      return inferredAutoLayout.layoutMode === "VERTICAL" ? ".leading" : ".top";
    case "MAX":
      return inferredAutoLayout.layoutMode === "VERTICAL"
        ? ".trailing"
        : ".bottom";
    case "BASELINE":
      return ".firstTextBaseline";
    case "CENTER":
      return "";
  }
};
const getSpacing = (inferredAutoLayout: InferredAutoLayoutResult): number => {
  const defaultSpacing = 10;
  return Math.round(inferredAutoLayout.itemSpacing) !== defaultSpacing
    ? inferredAutoLayout.itemSpacing
    : defaultSpacing;
};
export const generateSwiftViewCode = (
  className: string,
  properties: Record<string, string | number>,
  children: string,
): string => {
  const propertiesArray = Object.entries(properties)
    .filter(([, value]) => value !== "")
    .map(
      ([key, value]) =>
        `${key}: ${typeof value === "number" ? numberToFixedString(value) : value}`,
    );
  const compactPropertiesArray = propertiesArray.join(", ");
  if (compactPropertiesArray.length > 60) {
    const formattedProperties = propertiesArray.join(",\n");
    return `${className}(\n${formattedProperties}\n) {${indentString(
      children,
    )}\n}`;
  }
  return `${className}(${compactPropertiesArray}) {\n${indentString(
    children,
  )}\n}`;
};
// todo should the plugin manually Group items? Ideally, it would detect the similarities and allow a ForEach.
const widgetGeneratorWithLimits = (
  node: SceneNode & ChildrenMixin,
  indentLevel: number,
) => {
  if (node.children.length < 10) {
    // standard way
    return swiftuiWidgetGenerator(node.children, indentLevel);
  }
  const chunk = 10;
  let strBuilder = "";
  const slicedChildren = node.children.slice(0, 100);
  // I believe no one should have more than 100 items in a single nesting level. If you do, please email me.
  if (node.children.length > 100) {
    strBuilder += `\n
  }
  for (let i = 0, j = slicedChildren.length; i < j; i += chunk) {
    const chunkChildren = slicedChildren.slice(i, i + chunk);
    const strChildren = swiftuiWidgetGenerator(chunkChildren, indentLevel);
    strBuilder += `Group {\n${indentString(strChildren)}\n}`;
  }
  return strBuilder;
};
export const swiftUICodeGenTextStyles = () => {
  const result = previousExecutionCache
    .map((style) => `${style}`)
    .join("\n// ---\n");
  if (!result) {
    return "// No text styles in this selection";
  }
  return result;
};
</file>

<file path="packages/backend/package.json">
{
  "name": "backend",
  "version": "0.0.0",
  "private": true,
  "license": "GPT-3",
  "sideEffects": false,
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "files": [
    "dist/**"
  ],
  "scripts": {
    "lint": "eslint \"src/**/*.ts*\""
  },
  "dependencies": {
    "@figma/plugin-typings": "^1.109.0",
    "js-base64": "^3.7.7",
    "nanoid": "^5.1.5",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "types": "workspace:*",
    "node-fetch": "^3.3.1"
  },
  "devDependencies": {
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "eslint": "^9.23.0",
    "eslint-config-custom": "workspace:*",
    "tsconfig": "workspace:*",
    "tsup": "^8.4.0",
    "typescript": "^5.8.2"
  }
}
</file>

<file path="packages/plugin-ui/src/components/SettingsGroup.tsx">
import { useState, ReactNode } from "react";
import { LocalCodegenPreferenceOptions, PluginSettings } from "types";
import SelectableToggle from "./SelectableToggle";
import { ChevronDownIcon, ChevronRightIcon } from "lucide-react";
interface SettingsGroupProps {
  title: string;
  settings?: LocalCodegenPreferenceOptions[];
  alwaysExpanded?: boolean;
  selectedSettings?: PluginSettings | null;
  onPreferenceChanged?: (
    key: keyof PluginSettings,
    value: boolean | string,
  ) => void;
  children?: ReactNode;
}
const SettingsGroup: React.FC<SettingsGroupProps> = ({
  title,
  settings = [],
  alwaysExpanded = false,
  selectedSettings,
  onPreferenceChanged,
  children,
}) => {
  const [expanded, setExpanded] = useState(alwaysExpanded);
  const hasContent = settings.length > 0 || children;
  if (!hasContent) {
    return null;
  }
  return (
    <div className="w-full mb-2.5 last:mb-0">
      {alwaysExpanded ? (
        <div className="flex items-center mb-1">
          <span className="text-xs font-semibold text-foreground">
            {title}
          </span>
        </div>
      ) : (
        <button
          onClick={() => setExpanded(!expanded)}
          className="flex items-center gap-1.5 text-xs font-medium text-muted-foreground hover:text-foreground transition-colors w-full text-left"
        >
          {expanded ? (
            <ChevronDownIcon className="w-3.5 h-3.5 shrink-0" />
          ) : (
            <ChevronRightIcon className="w-3.5 h-3.5 shrink-0" />
          )}
          <span className="truncate">{title}</span>
        </button>
      )}
      {(expanded || alwaysExpanded) && (
        <div
          className={`flex flex-col gap-2.5 ${!alwaysExpanded ? "px-4 mt-2" : ""}`}
        >
          {}
          {settings.length > 0 && (
            <div className="flex gap-2 items-center flex-wrap">
              {settings.map((preference) => (
                <SelectableToggle
                  key={preference.propertyName}
                  title={preference.label}
                  description={preference.description}
                  isSelected={
                    typeof selectedSettings?.[preference.propertyName] ===
                    "boolean"
                      ? (selectedSettings?.[preference.propertyName] as boolean)
                      : preference.isDefault
                  }
                  onSelect={(value) => {
                    onPreferenceChanged?.(preference.propertyName, value);
                  }}
                  buttonClass="bg-green-100 dark:bg-black dark:ring-green-800 ring-green-500"
                  checkClass="bg-green-400 dark:bg-black dark:bg-green-500 dark:border-green-500 ring-green-300 border-green-400"
                />
              ))}
            </div>
          )}
          {children}
        </div>
      )}
    </div>
  );
};
export default SettingsGroup;
</file>

<file path="packages/backend/src/altNodes/jsonNodeConversion.ts">
import { addWarning } from "../common/commonConversionWarnings";
import { PluginSettings } from "types";
import { variableToColorName } from "../tailwind/conversionTables";
import { HasGeometryTrait, Node, Paint } from "../api_types";
import { calculateRectangleFromBoundingBox } from "../common/commonPosition";
export let getNodeByIdAsyncTime = 0;
export let getNodeByIdAsyncCalls = 0;
export let getStyledTextSegmentsTime = 0;
export let getStyledTextSegmentsCalls = 0;
export let processColorVariablesTime = 0;
export let processColorVariablesCalls = 0;
export const resetPerformanceCounters = () => {
  getNodeByIdAsyncTime = 0;
  getNodeByIdAsyncCalls = 0;
  getStyledTextSegmentsTime = 0;
  getStyledTextSegmentsCalls = 0;
  processColorVariablesTime = 0;
  processColorVariablesCalls = 0;
};
const nodeNameCounters: Map<string, number> = new Map();
const variableCache = new Map<string, string>();
const memoizedVariableToColorName = async (
  variableId: string,
): Promise<string> => {
  if (!variableCache.has(variableId)) {
    const colorName = (await variableToColorName(variableId)).replaceAll(
      ",",
      "",
    );
    variableCache.set(variableId, colorName);
    return colorName;
  }
  return variableCache.get(variableId)!;
};
/**
 * Process color variables in a paint style and add pre-computed variable names
 * @param paint The paint style to process (fill or stroke)
 */
export const processColorVariables = async (paint: Paint) => {
  const start = Date.now();
  processColorVariablesCalls++;
  if (
    paint.type === "GRADIENT_ANGULAR" ||
    paint.type === "GRADIENT_DIAMOND" ||
    paint.type === "GRADIENT_LINEAR" ||
    paint.type === "GRADIENT_RADIAL"
  ) {
    const stopsWithVariables = paint.gradientStops.filter(
      (stop) => stop.boundVariables?.color,
    );
    if (stopsWithVariables.length > 0) {
      await Promise.all(
        stopsWithVariables.map(async (stop) => {
          (stop as any).variableColorName = await memoizedVariableToColorName(
            stop.boundVariables!.color!.id,
          );
        }),
      );
    }
  } else if (paint.type === "SOLID" && paint.boundVariables?.color) {
    (paint as any).variableColorName = await memoizedVariableToColorName(
      paint.boundVariables.color.id,
    );
  }
  processColorVariablesTime += Date.now() - start;
};
const processEffectVariables = async (
  paint: DropShadowEffect | InnerShadowEffect,
) => {
  const start = Date.now();
  processColorVariablesCalls++;
  if (paint.boundVariables?.color) {
    (paint as any).variableColorName = await memoizedVariableToColorName(
      paint.boundVariables.color.id,
    );
  }
  processColorVariablesTime += Date.now() - start;
};
const getColorVariables = async (
  node: HasGeometryTrait,
  settings: PluginSettings,
) => {
  if (settings.useColorVariables) {
    if (node.fills && Array.isArray(node.fills)) {
      await Promise.all(
        node.fills.map((fill: Paint) => processColorVariables(fill)),
      );
    }
    if (node.strokes && Array.isArray(node.strokes)) {
      await Promise.all(
        node.strokes.map((stroke: Paint) => processColorVariables(stroke)),
      );
    }
    if ("effects" in node && node.effects && Array.isArray(node.effects)) {
      await Promise.all(
        node.effects
          .filter(
            (effect: Effect) =>
              effect.type === "DROP_SHADOW" || effect.type === "INNER_SHADOW",
          )
          .map((effect: DropShadowEffect | InnerShadowEffect) =>
            processEffectVariables(effect),
          ),
      );
    }
  }
};
function adjustChildrenOrder(node: any) {
  if (!node.itemReverseZIndex || !node.children || node.layoutMode === "NONE") {
    return;
  }
  const children = node.children;
  const absoluteChildren = [];
  const fixedChildren = [];
  for (let i = children.length - 1; i >= 0; i--) {
    const child = children[i];
    if (child.layoutPositioning === "ABSOLUTE") {
      absoluteChildren.push(child);
    } else {
      fixedChildren.unshift(child);
    }
  }
  node.children = [...absoluteChildren, ...fixedChildren];
}
const canBeFlattened = (node: Node): boolean => {
  const flattenableTypes: string[] = [
    "VECTOR",
    "STAR",
    "POLYGON",
    "BOOLEAN_OPERATION",
    "REGULAR_POLYGON",
  ];
  if ("children" in node && node.children) {
    return node.children.every((child) => {
      if (child.type === "GROUP" && "children" in child && child.children) {
        return child.children.every((d) => canBeFlattened(d));
      }
      return flattenableTypes.includes(child.type);
    });
  }
  if (node.type === "RECTANGLE") {
    return false;
  }
  return flattenableTypes.includes(node.type);
};
const processNodePair = async (
  jsonNode: Node,
  figmaNode: SceneNode,
  settings: PluginSettings,
  parentNode?: Node,
  parentCumulativeRotation: number = 0,
): Promise<Node | Node[] | null> => {
  if (!jsonNode.id) return null;
  if (jsonNode.visible === false) return null;
  (jsonNode as any).canBeFlattened = canBeFlattened(jsonNode);
  const nodeType = jsonNode.type;
  if (parentNode) {
    jsonNode.cumulativeRotation = parentCumulativeRotation;
  }
  if (
    (nodeType === "FRAME" ||
      nodeType === "INSTANCE" ||
      nodeType === "COMPONENT" ||
      nodeType === "COMPONENT_SET") &&
    (!jsonNode.children || jsonNode.children.length === 0)
  ) {
    jsonNode.type = "RECTANGLE";
    return processNodePair(
      jsonNode,
      figmaNode,
      settings,
      parentNode,
      parentCumulativeRotation,
    );
  }
  if ("rotation" in jsonNode) {
    jsonNode.rotation = -jsonNode.rotation * (180 / Math.PI);
  }
  if (nodeType === "GROUP" && jsonNode.children) {
    const processedChildren = [];
    if (
      Array.isArray(jsonNode.children) &&
      figmaNode &&
      "children" in figmaNode
    ) {
      const visibleJsonChildren = jsonNode.children.filter(
        (child) => child.visible !== false,
      );
      const figmaChildrenById = new Map();
      figmaNode.children.forEach((child) => {
        figmaChildrenById.set(child.id, child);
      });
      for (const child of visibleJsonChildren) {
        const figmaChild = figmaChildrenById.get(child.id);
        if (!figmaChild) continue;
        const processedChild = await processNodePair(
          child,
          figmaChild,
          settings,
          parentNode,
          parentCumulativeRotation + (jsonNode.rotation || 0),
        );
        if (processedChild !== null) {
          if (Array.isArray(processedChild)) {
            processedChildren.push(...processedChild);
          } else {
            processedChildren.push(processedChild);
          }
        }
      }
    }
    return processedChildren;
  }
  if (nodeType === "SLICE") {
    return null;
  }
  if (parentNode) {
    (jsonNode as any).parent = parentNode;
  }
  const cleanName = jsonNode.name.trim();
  const count = nodeNameCounters.get(cleanName) || 0;
  nodeNameCounters.set(cleanName, count + 1);
  jsonNode.uniqueName =
    count === 0
      ? cleanName
      : `${cleanName}_${count.toString().padStart(2, "0")}`;
  if (figmaNode.type === "TEXT") {
    const getSegmentsStart = Date.now();
    getStyledTextSegmentsCalls++;
    let styledTextSegments = figmaNode.getStyledTextSegments([
      "fontName",
      "fills",
      "fontSize",
      "fontWeight",
      "hyperlink",
      "indentation",
      "letterSpacing",
      "lineHeight",
      "listOptions",
      "textCase",
      "textDecoration",
      "textStyleId",
      "fillStyleId",
      "openTypeFeatures",
    ]);
    getStyledTextSegmentsTime += Date.now() - getSegmentsStart;
    if (styledTextSegments.length > 0) {
      const baseSegmentName = (jsonNode.uniqueName || jsonNode.name)
        .replace(/[^a-zA-Z0-9_-]/g, "")
        .toLowerCase();
      // Add a uniqueId to each segment
      styledTextSegments = await Promise.all(
        styledTextSegments.map(async (segment, index) => {
          const mutableSegment: any = Object.assign({}, segment);
          if (settings.useColorVariables && segment.fills) {
            mutableSegment.fills = await Promise.all(
              segment.fills.map(async (d) => {
                if (
                  d.blendMode !== "PASS_THROUGH" &&
                  d.blendMode !== "NORMAL"
                ) {
                  addWarning("BlendMode is not supported in Text colors");
                }
                const fill = { ...d } as Paint;
                await processColorVariables(fill);
                return fill;
              }),
            );
          }
          if (styledTextSegments.length === 1) {
            (mutableSegment as any).uniqueId = `${baseSegmentName}_span`;
          } else {
            (mutableSegment as any).uniqueId =
              `${baseSegmentName}_span_${(index + 1).toString().padStart(2, "0")}`;
          }
          return mutableSegment;
        }),
      );
      jsonNode.styledTextSegments = styledTextSegments;
    }
    Object.assign(jsonNode, jsonNode.style);
    if (!jsonNode.textAutoResize) {
      jsonNode.textAutoResize = "NONE";
    }
  }
  if ("absoluteBoundingBox" in jsonNode && jsonNode.absoluteBoundingBox) {
    if (jsonNode.parent) {
      const rect = calculateRectangleFromBoundingBox(
        {
          width: jsonNode.absoluteBoundingBox.width,
          height: jsonNode.absoluteBoundingBox.height,
          x:
            jsonNode.absoluteBoundingBox.x -
            (jsonNode.parent?.absoluteBoundingBox.x || 0),
          y:
            jsonNode.absoluteBoundingBox.y -
            (jsonNode.parent?.absoluteBoundingBox.y || 0),
        },
        -((jsonNode.rotation || 0) + (jsonNode.cumulativeRotation || 0)),
      );
      jsonNode.width = rect.width;
      jsonNode.height = rect.height;
      jsonNode.x = rect.left;
      jsonNode.y = rect.top;
    } else {
      jsonNode.width = jsonNode.absoluteBoundingBox.width;
      jsonNode.height = jsonNode.absoluteBoundingBox.height;
      jsonNode.x = 0;
      jsonNode.y = 0;
    }
  }
  if ("individualStrokeWeights" in jsonNode) {
    jsonNode.strokeTopWeight = jsonNode.individualStrokeWeights.top;
    jsonNode.strokeBottomWeight = jsonNode.individualStrokeWeights.bottom;
    jsonNode.strokeLeftWeight = jsonNode.individualStrokeWeights.left;
    jsonNode.strokeRightWeight = jsonNode.individualStrokeWeights.right;
  }
  await getColorVariables(jsonNode, settings);
  if ("layoutMode" in jsonNode && jsonNode.layoutMode) {
    if (jsonNode.paddingLeft === undefined) {
      jsonNode.paddingLeft = 0;
    }
    if (jsonNode.paddingRight === undefined) {
      jsonNode.paddingRight = 0;
    }
    if (jsonNode.paddingTop === undefined) {
      jsonNode.paddingTop = 0;
    }
    if (jsonNode.paddingBottom === undefined) {
      jsonNode.paddingBottom = 0;
    }
  }
  if (!jsonNode.layoutMode) jsonNode.layoutMode = "NONE";
  if (!jsonNode.layoutGrow) jsonNode.layoutGrow = 0;
  if (!jsonNode.layoutSizingHorizontal)
    jsonNode.layoutSizingHorizontal = "FIXED";
  if (!jsonNode.layoutSizingVertical) jsonNode.layoutSizingVertical = "FIXED";
  if (!jsonNode.primaryAxisAlignItems) {
    jsonNode.primaryAxisAlignItems = "MIN";
  }
  if (!jsonNode.counterAxisAlignItems) {
    jsonNode.counterAxisAlignItems = "MIN";
  }
  const hasChildren =
    "children" in jsonNode &&
    jsonNode.children &&
    Array.isArray(jsonNode.children) &&
    jsonNode.children.length > 0;
  if (jsonNode.layoutSizingHorizontal === "HUG" && !hasChildren) {
    jsonNode.layoutSizingHorizontal = "FIXED";
  }
  if (jsonNode.layoutSizingVertical === "HUG" && !hasChildren) {
    jsonNode.layoutSizingVertical = "FIXED";
  }
  if (
    "children" in jsonNode &&
    jsonNode.children &&
    Array.isArray(jsonNode.children) &&
    "children" in figmaNode
  ) {
    const visibleJsonChildren = jsonNode.children.filter(
      (child) => child.visible !== false,
    );
    const figmaChildrenById = new Map();
    figmaNode.children.forEach((child) => {
      figmaChildrenById.set(child.id, child);
    });
    const cumulative =
      parentCumulativeRotation +
      (jsonNode.type === "GROUP" ? jsonNode.rotation || 0 : 0);
    const processedChildren = [];
    for (const child of visibleJsonChildren) {
      const figmaChild = figmaChildrenById.get(child.id);
      if (!figmaChild) continue;
      const processedChild = await processNodePair(
        child,
        figmaChild,
        settings,
        jsonNode,
        cumulative,
      );
      if (processedChild !== null) {
        if (Array.isArray(processedChild)) {
          processedChildren.push(...processedChild);
        } else {
          processedChildren.push(processedChild);
        }
      }
    }
    jsonNode.children = processedChildren;
    if (
      jsonNode.layoutMode === "NONE" ||
      jsonNode.children.some(
        (d: any) =>
          "layoutPositioning" in d && d.layoutPositioning === "ABSOLUTE",
      )
    ) {
      jsonNode.isRelative = true;
    }
    adjustChildrenOrder(jsonNode);
  }
  return jsonNode;
};
export const nodesToJSON = async (
  nodes: ReadonlyArray<SceneNode>,
  settings: PluginSettings,
): Promise<Node[]> => {
  nodeNameCounters.clear();
  const exportJsonStart = Date.now();
  const nodeResults = await Promise.all(
    nodes.map(async (node) => {
      const nodeDoc = (
        (await node.exportAsync({
          format: "JSON_REST_V1",
        })) as any
      ).document;
      let nodeCumulativeRotation = 0;
      if (node.type === "GROUP") {
        nodeDoc.type = "FRAME";
        if ("rotation" in nodeDoc && nodeDoc.rotation) {
          nodeCumulativeRotation = -nodeDoc.rotation * (180 / Math.PI);
          nodeDoc.rotation = 0;
        }
      }
      return {
        nodeDoc,
        nodeCumulativeRotation,
      };
    }),
  );
  console.log("[debug] initial nodeJson", { ...nodes[0] });
  console.log(
    `[benchmark][inside nodesToJSON] JSON_REST_V1 export: ${Date.now() - exportJsonStart}ms`,
  );
  const processNodesStart = Date.now();
  const result: Node[] = [];
  for (let i = 0; i < nodes.length; i++) {
    const processedNode = await processNodePair(
      nodeResults[i].nodeDoc,
      nodes[i],
      settings,
      undefined,
      nodeResults[i].nodeCumulativeRotation,
    );
    if (processedNode !== null) {
      if (Array.isArray(processedNode)) {
        result.push(...processedNode);
      } else {
        result.push(processedNode);
      }
    }
  }
  console.log(
    `[benchmark][inside nodesToJSON] Process node pairs: ${Date.now() - processNodesStart}ms`,
  );
  return result;
};
</file>

<file path="packages/backend/src/html/builderImpl/htmlSize.ts">
import { nodeSize } from "../../common/nodeWidthHeight";
import { formatWithJSX } from "../../common/parseJSX";
import { isPreviewGlobal } from "../htmlMain";
export const htmlSizePartial = (
  node: SceneNode,
  isJsx: boolean,
): { width: string; height: string; constraints: string[] } => {
  if (isPreviewGlobal && node.parent === undefined) {
    return {
      width: formatWithJSX("width", isJsx, "100%"),
      height: formatWithJSX("height", isJsx, "100%"),
      constraints: [],
    };
  }
  const size = nodeSize(node);
  const nodeParent = node.parent;
  let w = "";
  if (typeof size.width === "number") {
    w = formatWithJSX("width", isJsx, size.width);
  } else if (size.width === "fill") {
    if (
      nodeParent &&
      "layoutMode" in nodeParent &&
      nodeParent.layoutMode === "HORIZONTAL"
    ) {
      w = formatWithJSX("flex", isJsx, "1 1 0");
    } else {
      if (node.maxWidth) {
        w = formatWithJSX("width", isJsx, "100%");
      } else {
        w = formatWithJSX("align-self", isJsx, "stretch");
      }
    }
  }
  let h = "";
  if (typeof size.height === "number") {
    h = formatWithJSX("height", isJsx, size.height);
  } else if (typeof size.height === "string") {
    if (
      nodeParent &&
      "layoutMode" in nodeParent &&
      nodeParent.layoutMode === "VERTICAL"
    ) {
      h = formatWithJSX("flex", isJsx, "1 1 0");
    } else {
      if (node.maxHeight) {
        h = formatWithJSX("height", isJsx, "100%");
      } else {
        h = formatWithJSX("align-self", isJsx, "stretch");
      }
    }
  }
  const constraints = [];
  if (node.maxWidth !== undefined && node.maxWidth !== null) {
    constraints.push(formatWithJSX("max-width", isJsx, node.maxWidth));
  }
  if (node.minWidth !== undefined && node.minWidth !== null) {
    constraints.push(formatWithJSX("min-width", isJsx, node.minWidth));
  }
  if (node.maxHeight !== undefined && node.maxHeight !== null) {
    constraints.push(formatWithJSX("max-height", isJsx, node.maxHeight));
  }
  if (node.minHeight !== undefined && node.minHeight !== null) {
    constraints.push(formatWithJSX("min-height", isJsx, node.minHeight));
  }
  return {
    width: w,
    height: h,
    constraints: constraints,
  };
};
</file>

<file path="packages/backend/src/tailwind/builderImpl/tailwindSize.ts">
import { pxToLayoutSize } from "../conversionTables";
import { nodeSize } from "../../common/nodeWidthHeight";
import { numberToFixedString } from "../../common/numToAutoFixed";
import { TailwindSettings } from "types";
import { localTailwindSettings } from "../tailwindMain";
const formatTailwindSizeValue = (
  size: number,
  prefix: string,
  settings?: TailwindSettings,
): string => {
  const tailwindSize = pxToLayoutSize(size);
  if (!tailwindSize.startsWith("[")) {
    return `${prefix}-${tailwindSize}`;
  }
  const sizeFixed = numberToFixedString(size);
  if (sizeFixed === "0") {
    return `${prefix}-0`;
  } else {
    return `${prefix}-[${sizeFixed}px]`;
  }
};
export const tailwindSizePartial = (
  node: SceneNode,
  settings?: TailwindSettings,
): { width: string; height: string; constraints: string } => {
  const size = nodeSize(node);
  const nodeParent = node.parent;
  let w = "";
  if (typeof size.width === "number") {
    w = formatTailwindSizeValue(size.width, "w", settings);
  } else if (size.width === "fill") {
    if (
      nodeParent &&
      "layoutMode" in nodeParent &&
      nodeParent.layoutMode === "HORIZONTAL"
    ) {
      w = "flex-1";
    } else {
      if (node.maxWidth) {
        w = "w-full";
      } else {
        w = "self-stretch";
      }
    }
  }
  let h = "";
  if (typeof size.height === "number") {
    h = formatTailwindSizeValue(size.height, "h", settings);
  } else if (size.height === "fill") {
    if (
      nodeParent &&
      "layoutMode" in nodeParent &&
      nodeParent.layoutMode === "VERTICAL"
    ) {
      h = "flex-1";
    } else {
      if (node.maxHeight) {
        h = "h-full";
      } else {
        h = "self-stretch";
      }
    }
  }
  const constraints = [];
  if (node.maxWidth !== undefined && node.maxWidth !== null) {
    constraints.push(formatTailwindSizeValue(node.maxWidth, "max-w", settings));
  }
  if (node.minWidth !== undefined && node.minWidth !== null) {
    constraints.push(formatTailwindSizeValue(node.minWidth, "min-w", settings));
  }
  if (node.maxHeight !== undefined && node.maxHeight !== null) {
    constraints.push(
      formatTailwindSizeValue(node.maxHeight, "max-h", settings),
    );
  }
  if (node.minHeight !== undefined && node.minHeight !== null) {
    constraints.push(
      formatTailwindSizeValue(node.minHeight, "min-h", settings),
    );
  }
  if (localTailwindSettings.useTailwind4) {
    const wValue = w.substring(2);
    const hValue = h.substring(2);
    if (wValue === hValue) {
      w = `size-${wValue}`;
      h = "";
    }
  }
  return {
    width: w,
    height: h,
    constraints: constraints.join(" "),
  };
};
</file>

<file path="packages/plugin-ui/package.json">
{
  "name": "plugin-ui",
  "version": "0.0.0",
  "private": true,
  "license": "MIT",
  "sideEffects": false,
  "main": "./src/index.tsx",
  "types": "./src/index.tsx",
  "scripts": {
    "lint": "eslint \"src/**/*.ts*\""
  },
  "dependencies": {
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@types/react-syntax-highlighter": "15.5.13",
    "clsx": "^2.1.1",
    "copy-to-clipboard": "^3.3.3",
    "lucide-react": "^0.483.0",
    "react": "^19.0.0",
    "react-syntax-highlighter": "^15.6.1",
    "tailwind-merge": "^3.0.2",
    "tailwindcss": "^4.0.17"
  },
  "devDependencies": {
    "eslint": "^9.23.0",
    "eslint-config-custom": "workspace:*",
    "tsconfig": "workspace:*",
    "types": "workspace:*",
    "typescript": "^5.8.2"
  }
}
</file>

<file path="packages/backend/src/tailwind/builderImpl/tailwindBorder.ts">
import { getCommonRadius } from "../../common/commonRadius";
import { commonStroke } from "../../common/commonStroke";
import {
  pxToBorderRadius,
  pxToBorderWidth,
  pxToOutline,
} from "../conversionTables";
import { numberToFixedString } from "../../common/numToAutoFixed";
import { addWarning } from "../../common/commonConversionWarnings";
const getBorder = (
  weight: number,
  kind: string,
  useOutline: boolean = false,
  isBoxShadow: boolean = false,
): string => {
  if (isBoxShadow) {
    return "";
  }
  // Use outline utilities for outside/center strokes
  if (useOutline) {
    const outlineWidth = pxToOutline(weight);
    if (outlineWidth === null) {
      return `outline outline-[${numberToFixedString(weight)}px]`;
    } else {
      return `outline outline-${outlineWidth}`;
    }
  }
  // Special case: border (without width) is 1px in Tailwind
  if (weight === 1) {
    return `border${kind}`;
  }
  // Use border utilities for default and inside strokes
  const borderWidth = pxToBorderWidth(weight);
  if (borderWidth === null) {
    return `border${kind}-[${numberToFixedString(weight)}px]`;
  } else if (borderWidth === "DEFAULT") {
    return `border${kind}`;
  } else {
    return `border${kind}-${borderWidth}`;
  }
};
export const tailwindBorderWidth = (
  node: SceneNode,
): {
  isOutline: boolean;
  property: string;
  shadowProperty?: string;
} => {
  const commonBorder = commonStroke(node);
  if (!commonBorder) {
    return {
      isOutline: false,
      property: "",
    };
  }
  // Check stroke alignment and layout mode
  const strokeAlign = "strokeAlign" in node ? node.strokeAlign : "INSIDE";
  if ("all" in commonBorder) {
    if (commonBorder.all === 0) {
      return {
        isOutline: false,
        property: "",
      };
    }
    const weight = commonBorder.all;
    if (
      strokeAlign === "CENTER" ||
      strokeAlign === "OUTSIDE" ||
      node.type === "FRAME" ||
      node.type === "INSTANCE" ||
      node.type === "COMPONENT"
    ) {
      const property = getBorder(weight, "", true);
      let offsetProperty = "";
      if (strokeAlign === "CENTER") {
        offsetProperty = `outline-offset-[-${numberToFixedString(weight / 2)}px]`;
      } else if (strokeAlign === "INSIDE") {
        offsetProperty = `outline-offset-[-${numberToFixedString(weight)}px]`;
      }
      return {
        isOutline: true,
        property: offsetProperty ? `${property} ${offsetProperty}` : property,
      };
    } else {
      return {
        isOutline: false,
        property: getBorder(weight, "", false),
      };
    }
  } else {
    // For non-uniform borders, we only support border (not outline)
    addWarning(
      'Non-uniform borders are only supported with strokeAlign set to "inside". Will paint inside.',
    );
  }
  const comp = [];
  if (commonBorder.left !== 0) {
    comp.push(getBorder(commonBorder.left, "-l"));
  }
  if (commonBorder.right !== 0) {
    comp.push(getBorder(commonBorder.right, "-r"));
  }
  if (commonBorder.top !== 0) {
    comp.push(getBorder(commonBorder.top, "-t"));
  }
  if (commonBorder.bottom !== 0) {
    comp.push(getBorder(commonBorder.bottom, "-b"));
  }
  return {
    isOutline: false,
    property: comp.join(" "),
  };
};
export const tailwindBorderRadius = (node: SceneNode): string => {
  if (node.type === "ELLIPSE") {
    return "rounded-full";
  }
  const getRadius = (radius: number) => {
    const r = pxToBorderRadius(radius);
    if (r) {
      return `-${r}`;
    }
    return "";
  };
  const radius = getCommonRadius(node);
  if ("all" in radius) {
    if (radius.all === 0) {
      return "";
    } else if (radius.all > 999 && node.width < 1000 && node.height < 1000) {
      return "rounded-full";
    }
    return `rounded${getRadius(radius.all)}`;
  }
  let comp: string[] = [];
  if (radius.topLeft !== 0) {
    comp.push(`rounded-tl${getRadius(radius.topLeft)}`);
  }
  if (radius.topRight !== 0) {
    comp.push(`rounded-tr${getRadius(radius.topRight)}`);
  }
  if (radius.bottomLeft !== 0) {
    comp.push(`rounded-bl${getRadius(radius.bottomLeft)}`);
  }
  if (radius.bottomRight !== 0) {
    comp.push(`rounded-br${getRadius(radius.bottomRight)}`);
  }
  return comp.join(" ");
};
</file>

<file path="packages/plugin-ui/src/components/About.tsx">
import { useState } from "react";
import {
  ArrowRightIcon,
  Code,
  Github,
  Heart,
  Lock,
  Mail,
  MessageCircle,
  Star,
  Zap,
  Copy,
  CheckCircle,
  ToggleLeft,
  ToggleRight,
} from "lucide-react";
import { PluginSettings } from "types";
type AboutProps = {
  useOldPluginVersion?: boolean;
  onPreferenceChanged: (
    key: keyof PluginSettings,
    value: boolean | string | number,
  ) => void;
};
const About = ({
  useOldPluginVersion = false,
  onPreferenceChanged,
}: AboutProps) => {
  const [copied, setCopied] = useState(false);
  const copySelectionJson = async () => {
    try {
      parent.postMessage(
        { pluginMessage: { type: "get-selection-json" } },
        "*",
      );
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (error) {
      console.error("Failed to copy selection JSON:", error);
    }
  };
  const togglePluginVersion = () => {
    onPreferenceChanged("useOldPluginVersion2025", !useOldPluginVersion);
  };
  return (
    <div className="flex flex-col p-5 gap-6 text-sm max-w-2xl mx-auto">
      {}
      <div className="flex flex-col items-center text-center mb-2">
        <div className="w-16 h-16 bg-linear-to-br from-green-400 to-emerald-600 rounded-xl flex items-center justify-center shadow-lg mb-3">
          <Code size={32} className="text-white" />
        </div>
        <h2 className="text-2xl font-bold mb-1">Figma to Code</h2>
        <div className="flex items-center gap-1 text-neutral-600 dark:text-neutral-300">
          <span>Created with</span>
          <Heart size={14} className="text-red-500 fill-red-500" />
          <span>by Bernardo Ferrari</span>
        </div>
        <div className="mt-3 flex gap-3">
          <a
            href="https://github.com/bernaferrari"
            target="_blank"
            rel="noopener noreferrer"
            className="p-2 rounded-full bg-neutral-100 dark:bg-neutral-700 hover:bg-neutral-200 dark:hover:bg-neutral-600 transition-colors"
            aria-label="GitHub Profile"
          >
            <Github size={18} />
          </a>
          <a
            href="https://twitter.com/bernaferrari"
            target="_blank"
            rel="noopener noreferrer"
            className="p-2 rounded-full bg-neutral-100 dark:bg-neutral-700 hover:bg-neutral-200 dark:hover:bg-neutral-600 transition-colors"
            aria-label="Twitter Profile"
          >
            <XLogo />
          </a>
          <a
            href="mailto:bernaferrari2@gmail.com"
            target="_blank"
            rel="noopener noreferrer"
            className="p-2 rounded-full bg-neutral-100 dark:bg-neutral-700 hover:bg-neutral-200 dark:hover:bg-neutral-600 transition-colors"
            aria-label="Email"
          >
            <Mail size={18} />
          </a>
        </div>
      </div>
      {}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {}
        <div className="bg-white dark:bg-neutral-800 rounded-xl p-5 shadow-2xs border border-neutral-200 dark:border-neutral-700 hover:border-green-300 dark:hover:border-green-700 transition-colors">
          <div className="flex items-center gap-3 mb-3">
            <div className="p-2 bg-blue-100 dark:bg-blue-900/40 rounded-lg">
              <Lock size={20} className="text-blue-600 dark:text-blue-400" />
            </div>
            <h3 className="font-semibold text-base">Privacy Policy</h3>
          </div>
          <p className="text-neutral-600 dark:text-neutral-300 leading-relaxed">
            This plugin is completely private. All of your design data is
            processed locally in your browser and never leaves your computer. No
            analytics, no data collection, no tracking.
          </p>
        </div>
        {}
        <div className="bg-white dark:bg-neutral-800 rounded-xl p-5 shadow-2xs border border-neutral-200 dark:border-neutral-700 hover:border-green-300 dark:hover:border-green-700 transition-colors">
          <div className="flex items-center gap-3 mb-3">
            <div className="p-2 bg-purple-100 dark:bg-purple-900/40 rounded-lg">
              <Github
                size={20}
                className="text-purple-600 dark:text-purple-400"
              />
            </div>
            <h3 className="font-semibold text-base">Open Source</h3>
          </div>
          <p className="text-neutral-600 dark:text-neutral-300 leading-relaxed mb-3">
            Figma to Code is completely open-source. Contributions, bug reports,
            and feature requests are welcome!
          </p>
          <a
            href="https://github.com/bernaferrari/figmatocode"
            target="_blank"
            rel="noopener noreferrer"
            className="inline-flex items-center gap-2 px-3 py-1.5 bg-neutral-100 dark:bg-neutral-700 rounded-md text-green-600 dark:text-green-400 hover:bg-green-100 dark:hover:bg-green-900/30 transition-colors"
          >
            <Star size={14} className="text-yellow-500 fill-yellow-500" />
            <span>View on GitHub</span>
          </a>
        </div>
        {}
        <div className="bg-white dark:bg-neutral-800 rounded-xl p-5 shadow-2xs border border-neutral-200 dark:border-neutral-700 hover:border-green-300 dark:hover:border-green-700 transition-colors">
          <div className="flex items-center gap-3 mb-3">
            <div className="p-2 bg-amber-100 dark:bg-amber-900/40 rounded-lg">
              <Zap size={20} className="text-amber-600 dark:text-amber-400" />
            </div>
            <h3 className="font-semibold text-base">Features</h3>
          </div>
          <ul className="text-neutral-600 dark:text-neutral-300 space-y-2 leading-relaxed">
            <li className="flex items-start gap-2">
              <div className="mt-1.5">
                <ArrowRightIcon size={12} />
              </div>
              <span>
                Convert Figma designs to HTML, Tailwind, Flutter, and SwiftUI
              </span>
            </li>
            <li className="flex items-start gap-2">
              <div className="mt-1.5">
                <ArrowRightIcon size={12} />
              </div>
              <span>Extract colors and gradients from your designs</span>
            </li>
            <li className="flex items-start gap-2">
              <div className="mt-1.5">
                <ArrowRightIcon size={12} />
              </div>
              <span>Get responsive code that matches your design</span>
            </li>
          </ul>
        </div>
        {}
        <div className="bg-card rounded-xl p-5 shadow-2xs border border-neutral-200 dark:border-neutral-700 hover:border-green-300 dark:hover:border-green-700 transition-colors">
          <div className="flex items-center gap-3 mb-3">
            <div className="p-2 bg-green-100 dark:bg-green-900/40 rounded-lg">
              <MessageCircle
                size={20}
                className="text-green-600 dark:text-green-400"
              />
            </div>
            <h3 className="font-semibold text-base">Get in Touch</h3>
          </div>
          <p className="text-neutral-600 dark:text-neutral-300 leading-relaxed mb-3">
            Have feedback, questions, or need help? I'd love to hear from you!
            Feel free to reach out through any of these channels:
          </p>
          <div className="space-y-2">
            <a
              href="mailto:bernaferrari2@gmail.com"
              target="_blank"
              rel="noopener noreferrer"
              className="flex items-center gap-2 text-green-600 dark:text-green-400 hover:underline"
            >
              <Mail size={16} />
              <span>bernaferrari2@gmail.com</span>
            </a>
            <a
              href="https://github.com/bernaferrari/figmato-code/issues"
              target="_blank"
              rel="noopener noreferrer"
              className="flex items-center gap-2 text-green-600 dark:text-green-400 hover:underline"
            >
              <Github size={16} />
              <span>Report an issue on GitHub</span>
            </a>
          </div>
        </div>
        {}
        <div className="bg-card rounded-xl p-5 shadow-2xs border border-neutral-200 dark:border-neutral-700 hover:border-green-300 dark:hover:border-green-700 transition-colors">
          <div className="flex items-center gap-3 mb-3">
            <div className="p-2 bg-rose-100 dark:bg-rose-900/40 rounded-lg">
              <Code size={20} className="text-rose-600 dark:text-rose-400" />
            </div>
            <h3 className="font-semibold text-base">Debug Helper</h3>
          </div>
          <p className="text-neutral-600 dark:text-neutral-300 leading-relaxed mb-4">
            Having an issue? Help me debug by copying the JSON of your selected
            elements. This can be attached when reporting issues.
          </p>
          <button
            onClick={copySelectionJson}
            className="inline-flex items-center gap-2 px-4 py-2 bg-muted rounded-md text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors mb-3"
          >
            {copied ? (
              <>
                <CheckCircle size={16} />
                <span>Copied!</span>
              </>
            ) : (
              <>
                <Copy size={16} />
                <span>Copy Selection JSON</span>
              </>
            )}
          </button>
          {}
          <div className="mt-3 pt-3 border-t border-neutral-200 dark:border-neutral-700">
            <button
              onClick={togglePluginVersion}
              className="inline-flex items-center gap-2 w-full text-left text-neutral-600 dark:text-neutral-400 text-xs hover:text-neutral-800 dark:hover:text-neutral-300 transition-colors"
            >
              {useOldPluginVersion ? (
                <ToggleRight size={16} className="text-green-500" />
              ) : (
                <ToggleLeft size={16} />
              )}
              <span>Use previous plugin version</span>
            </button>
            <p className="mt-2 text-xs text-neutral-500 dark:text-neutral-400">
              The new version is up to 100x faster, but might still cause some
              issues. If you encounter problems, you can switch to the old
              version (and please report issues so they can be fixed).
            </p>
          </div>
        </div>
      </div>
      {}
      <div className="mt-2 text-center text-neutral-500 dark:text-neutral-400 text-xs">
        <p>
           {new Date().getFullYear()} Bernardo Ferrari. All rights reserved.
        </p>
      </div>
    </div>
  );
};
function XLogo() {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="18"
      height="18"
      fill="currentColor"
      viewBox="0 0 256 256"
    >
      <path d="M214.75,211.71l-62.6-98.38,61.77-67.95a8,8,0,0,0-11.84-10.76L143.24,99.34,102.75,35.71A8,8,0,0,0,96,32H48a8,8,0,0,0-6.75,12.3l62.6,98.37-61.77,68a8,8,0,1,0,11.84,10.76l58.84-64.72,40.49,63.63A8,8,0,0,0,160,224h48a8,8,0,0,0,6.75-12.29ZM164.39,208,62.57,48h29L193.43,208Z"></path>
    </svg>
  );
}
export default About;
</file>

<file path="packages/plugin-ui/src/components/SelectableToggle.tsx">
import { useState } from "react";
import { Check, HelpCircle } from "lucide-react";
import { cn } from "../lib/utils";
type SelectableToggleProps = {
  onSelect: (isSelected: boolean) => void;
  isSelected?: boolean;
  title: string;
  description?: string;
  buttonClass: string;
  checkClass: string;
};
const SelectableToggle = ({
  onSelect,
  isSelected = false,
  title,
  description,
  buttonClass,
  checkClass,
}: SelectableToggleProps) => {
  const [showTooltip, setShowTooltip] = useState(false);
  const handleClick = () => {
    onSelect(!isSelected);
  };
  return (
    <div className="relative inline-block">
      <button
        onClick={handleClick}
        className={cn(
          `h-8 px-2 flex items-center justify-center rounded-md transition-all duration-200 border`,
          isSelected
            ? `${buttonClass} text-white shadow-2xs border-transparent`
            : "bg-muted hover:bg-neutral-200 dark:hover:bg-neutral-700 text-muted-foreground border",
        )}
      >
        <div className="flex items-center gap-2 text-muted-foreground">
          <div
            className={`h-4 w-4 shrink-0 flex items-center justify-center rounded-md transition-all duration-200 border ${
              isSelected
                ? `${checkClass}`
                : "bg-white dark:bg-neutral-800 border-neutral-300 dark:border-neutral-600"
            }`}
          >
            {isSelected && (
              <Check size={10} className="text-white dark:text-black" />
            )}
          </div>
          <span
            className={cn(
              "text-sm font-medium whitespace-nowrap",
              isSelected && "text-green-800 dark:text-foreground",
            )}
          >
            {title}
          </span>
          {}
          {description && (
            <div
              className="hover:text-foreground transition-opacity cursor-help"
              onMouseEnter={() => setShowTooltip(true)}
              onMouseLeave={() => setShowTooltip(false)}
            >
              <HelpCircle size={12} />
            </div>
          )}
        </div>
      </button>
      {}
      {showTooltip && description && (
        <div className="absolute z-10 bottom-full left-1/2 transform -translate-x-1/2 mb-2 w-48 px-3 py-2 bg-white dark:bg-neutral-800 rounded-lg shadow-lg border border-neutral-200 dark:border-neutral-700 text-xs">
          <p className="text-neutral-700 dark:text-neutral-200">
            {description}
          </p>
          <div className="absolute top-full left-1/2 transform -translate-x-1/2 -mt-1 border-l-4 border-r-4 border-t-4 border-l-transparent border-r-transparent border-t-white dark:border-t-neutral-800"></div>
        </div>
      )}
    </div>
  );
};
export default SelectableToggle;
</file>

<file path="packages/backend/src/flutter/flutterMain.ts">
import {
  stringToClassName,
  generateWidgetCode,
} from "../common/numToAutoFixed";
import { retrieveTopFill } from "../common/retrieveFill";
import { FlutterDefaultBuilder } from "./flutterDefaultBuilder";
import { FlutterTextBuilder } from "./flutterTextBuilder";
import { indentString } from "../common/indentString";
import {
  getCrossAxisAlignment,
  getMainAxisAlignment,
  getWrapAlignment,
  getWrapRunAlignment,
} from "./builderImpl/flutterAutoLayout";
import { PluginSettings } from "types";
import { addWarning } from "../common/commonConversionWarnings";
import { getPlaceholderImage } from "../common/images";
import { getVisibleNodes } from "../common/nodeVisibility";
let localSettings: PluginSettings;
let previousExecutionCache: string[];
const getFullAppTemplate = (name: string, injectCode: string): string =>
  `import 'package:flutter/material.dart';
void main() {
  runApp(const FigmaToCodeApp());
}
// Generated by: https://www.figma.com/community/plugin/842128343887142055/
class FigmaToCodeApp extends StatelessWidget {
  const FigmaToCodeApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: const Color.fromARGB(255, 18, 32, 47),
      ),
      home: Scaffold(
        body: ListView(children: [
          ${name}(),
        ]),
      ),
    );
  }
}
class ${name} extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ${indentString(injectCode, 4).trimStart()};
  }
}`;
const getStatelessTemplate = (name: string, injectCode: string): string =>
  `class ${name} extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ${indentString(injectCode, 4).trimStart()};
  }
}`;
export const flutterMain = (
  sceneNode: ReadonlyArray<SceneNode>,
  settings: PluginSettings,
): string => {
  localSettings = settings;
  previousExecutionCache = [];
  let result = flutterWidgetGenerator(sceneNode);
  switch (localSettings.flutterGenerationMode) {
    case "snippet":
      return result;
    case "stateless":
      if (!result.startsWith("Column")) {
        result = generateWidgetCode("Column", { children: [result] });
      }
      return getStatelessTemplate(stringToClassName(sceneNode[0].name), result);
    case "fullApp":
      if (!result.startsWith("Column")) {
        result = generateWidgetCode("Column", { children: [result] });
      }
      return getFullAppTemplate(stringToClassName(sceneNode[0].name), result);
  }
  return result;
};
const flutterWidgetGenerator = (
  sceneNode: ReadonlyArray<SceneNode>,
): string => {
  let comp: string[] = [];
  const visibleSceneNode = getVisibleNodes(sceneNode);
  visibleSceneNode.forEach((node) => {
    switch (node.type) {
      case "RECTANGLE":
      case "ELLIPSE":
      case "STAR":
      case "POLYGON":
      case "LINE":
        comp.push(flutterContainer(node, ""));
        break;
      case "GROUP":
        comp.push(flutterGroup(node));
        break;
      case "FRAME":
      case "INSTANCE":
      case "COMPONENT":
      case "COMPONENT_SET":
        comp.push(flutterFrame(node));
        break;
      case "SECTION":
        comp.push(flutterContainer(node, ""));
        break;
      case "TEXT":
        comp.push(flutterText(node));
        break;
      case "VECTOR":
        addWarning("VectorNodes are not supported in Flutter");
        break;
      case "SLICE":
      default:
    }
  });
  return comp.join(",\n");
};
const flutterGroup = (node: GroupNode): string => {
  const widget = flutterWidgetGenerator(node.children);
  return flutterContainer(
    node,
    generateWidgetCode("Stack", {
      children: widget ? [widget] : [],
    }),
  );
};
const flutterContainer = (node: SceneNode, child: string): string => {
  let propChild = "";
  if ("fills" in node && retrieveTopFill(node.fills)?.type === "IMAGE") {
    addWarning("Image fills are replaced with placeholders");
  }
  if (child.length > 0) {
    propChild = child;
  }
  const builder = new FlutterDefaultBuilder(propChild)
    .createContainer(node)
    .blendAttr(node)
    .position(node);
  return builder.child;
};
const flutterText = (node: TextNode): string => {
  const builder = new FlutterTextBuilder().createText(node);
  previousExecutionCache.push(builder.child);
  return builder.blendAttr(node).textAutoSize(node).position(node).child;
};
const flutterFrame = (
  node: SceneNode & BaseFrameMixin & MinimalBlendMixin,
): string => {
  const hasAbsoluteChildren = node.children.some(
    (child: any) => (child as any).layoutPositioning === "ABSOLUTE",
  );
  if (hasAbsoluteChildren && node.layoutMode !== "NONE") {
    addWarning(
      `Frame "${node.name}" has absolute positioned children. Using Stack instead of ${
        node.layoutMode === "HORIZONTAL" ? "Row" : "Column"
      }.`,
    );
  }
  const children = flutterWidgetGenerator(node.children);
  if (hasAbsoluteChildren) {
    return flutterContainer(
      node,
      generateWidgetCode("Stack", {
        children: children !== "" ? [children] : [],
      }),
    );
  }
  if (node.layoutMode !== "NONE") {
    const rowColumnWrap = makeRowColumnWrap(node, children);
    return flutterContainer(node, rowColumnWrap);
  } else {
    if (node.inferredAutoLayout) {
      const rowColumnWrap = makeRowColumnWrap(node.inferredAutoLayout, children);
      return flutterContainer(node, rowColumnWrap);
    }
    if (node.isAsset) {
      return flutterContainer(node, generateWidgetCode("FlutterLogo", {}));
    }
    return flutterContainer(
      node,
      generateWidgetCode("Stack", {
        children: children !== "" ? [children] : [],
      }),
    );
  }
};
const makeRowColumnWrap = (
  autoLayout: InferredAutoLayoutResult,
  children: string,
): string => {
  const rowOrColumn = autoLayout.layoutWrap == "WRAP" && autoLayout.primaryAxisSizingMode == "FIXED" ?
    "Wrap" : autoLayout.layoutMode === "HORIZONTAL" ? "Row" : "Column";
  const widgetProps: Record<string, any> = autoLayout.layoutWrap == "WRAP"
    ? {
      alignment: getWrapAlignment(autoLayout),
      runAlignment: getWrapRunAlignment(autoLayout),
    } :
    {
      mainAxisSize: "MainAxisSize.min",
      mainAxisAlignment: getMainAxisAlignment(autoLayout),
      crossAxisAlignment: getCrossAxisAlignment(autoLayout),
    };
  if (autoLayout.layoutWrap == "WRAP") {
    if (autoLayout.primaryAxisAlignItems != "SPACE_BETWEEN" && autoLayout.itemSpacing != undefined) {
      widgetProps.spacing = autoLayout.itemSpacing;
    }
    if (autoLayout.counterAxisAlignContent != "SPACE_BETWEEN" && autoLayout.counterAxisSpacing != undefined) {
      widgetProps.runSpacing = autoLayout.counterAxisSpacing;
    }
  } else if (autoLayout.itemSpacing > 0) {
    widgetProps.spacing = autoLayout.itemSpacing;
  } else if (autoLayout.itemSpacing < 0) {
    addWarning("Flutter doesn't support negative itemSpacing");
  }
  widgetProps.children = [children];
  return generateWidgetCode(rowOrColumn, widgetProps);
};
export const flutterCodeGenTextStyles = () => {
  const result = previousExecutionCache
    .map((style) => `${style}`)
    .join("\n// ---\n");
  if (!result) {
    return "// No text styles in this selection";
  }
  return result;
};
</file>

<file path="packages/backend/src/html/htmlTextBuilder.ts">
import { formatMultipleJSX, formatWithJSX } from "../common/parseJSX";
import { HtmlDefaultBuilder } from "./htmlDefaultBuilder";
import { htmlColorFromFills } from "./builderImpl/htmlColor";
import {
  commonLetterSpacing,
  commonLineHeight,
} from "../common/commonTextHeightSpacing";
import { HTMLSettings, StyledTextSegmentSubset } from "types";
import {
  cssCollection,
  generateUniqueClassName,
  stylesToCSS,
  getComponentName,
} from "./htmlMain";
export class HtmlTextBuilder extends HtmlDefaultBuilder {
  constructor(node: TextNode, settings: HTMLSettings) {
    super(node, settings);
  }
  get htmlElement(): string {
    return "p";
  }
  getTextSegments(node: TextNode): {
    style: string;
    text: string;
    openTypeFeatures: { [key: string]: boolean };
    className?: string;
    componentName?: string;
  }[] {
    const segments = (node as any)
      .styledTextSegments as StyledTextSegmentSubset[];
    if (!segments) {
      return [];
    }
    return segments.map((segment, index) => {
      const additionalStyles: { [key: string]: string } = {};
      const layerBlurStyle = this.getLayerBlurStyle();
      if (layerBlurStyle) {
        additionalStyles.filter = layerBlurStyle;
      }
      const textShadowStyle = this.getTextShadowStyle();
      if (textShadowStyle) {
        additionalStyles["text-shadow"] = textShadowStyle;
      }
      const styleAttributes = formatMultipleJSX(
        {
          color: htmlColorFromFills(segment.fills as any),
          "font-size": segment.fontSize,
          "font-family": segment.fontName.family,
          "font-style": this.getFontStyle(segment.fontName.style),
          "font-weight": `${segment.fontWeight}`,
          "text-decoration": this.textDecoration(segment.textDecoration),
          "text-transform": this.textTransform(segment.textCase),
          "line-height": this.lineHeight(segment.lineHeight, segment.fontSize),
          "letter-spacing": this.letterSpacing(
            segment.letterSpacing,
            segment.fontSize,
          ),
          "word-wrap": "break-word",
          ...additionalStyles,
        },
        this.isJSX,
      );
      const charsWithLineBreak = segment.characters.split("\n").join("<br/>");
      const result: any = {
        style: styleAttributes,
        text: charsWithLineBreak,
        openTypeFeatures: segment.openTypeFeatures,
      };
      const mode = this.settings.htmlGenerationMode;
      if (
        (mode === "svelte" || mode === "styled-components") &&
        styleAttributes
      ) {
        const segmentName =
          (segment as any).uniqueId ||
          `${((node as any).uniqueName || node.name || "text").replace(/[^a-zA-Z0-9_-]/g, "").toLowerCase()}_text_${(index + 1).toString().padStart(2, "0")}`;
        const className = generateUniqueClassName(segmentName);
        result.className = className;
        const cssStyles = stylesToCSS(
          styleAttributes
            .split(this.isJSX ? "," : ";")
            .map((style) => style.trim())
            .filter((style) => style),
          this.isJSX,
        );
        const elementTag = "span";
        cssCollection[className] = {
          styles: cssStyles,
          nodeName: segmentName,
          nodeType: "TEXT",
          element: elementTag,
        };
        if (mode === "styled-components") {
          result.componentName = getComponentName(
            { name: segmentName },
            className,
            elementTag,
          );
        }
      }
      return result;
    });
  }
  fontSize(node: TextNode, isUI = false): this {
    if (node.fontSize !== figma.mixed) {
      const value = isUI ? Math.min(node.fontSize, 24) : node.fontSize;
      this.addStyles(formatWithJSX("font-size", this.isJSX, value));
    }
    return this;
  }
  textTrim(): this {
    if ("leadingTrim" in this.node && this.node.leadingTrim === "CAP_HEIGHT") {
      this.addStyles(formatWithJSX("text-box-trim", this.isJSX, "trim-both"));
      this.addStyles(
        formatWithJSX("text-box-edge", this.isJSX, "cap alphabetic"),
      );
    }
    return this;
  }
  textDecoration(textDecoration: TextDecoration): string {
    switch (textDecoration) {
      case "STRIKETHROUGH":
        return "line-through";
      case "UNDERLINE":
        return "underline";
      case "NONE":
        return "";
    }
  }
  textTransform(textCase: TextCase): string {
    switch (textCase) {
      case "UPPER":
        return "uppercase";
      case "LOWER":
        return "lowercase";
      case "TITLE":
        return "capitalize";
      case "ORIGINAL":
      case "SMALL_CAPS":
      case "SMALL_CAPS_FORCED":
      default:
        return "";
    }
  }
  letterSpacing(letterSpacing: LetterSpacing, fontSize: number): number | null {
    const letterSpacingProp = commonLetterSpacing(letterSpacing, fontSize);
    if (letterSpacingProp > 0) {
      return letterSpacingProp;
    }
    return null;
  }
  lineHeight(lineHeight: LineHeight, fontSize: number): number | null {
    const lineHeightProp = commonLineHeight(lineHeight, fontSize);
    if (lineHeightProp > 0) {
      return lineHeightProp;
    }
    return null;
  }
  /**
   * https://tailwindcss.com/docs/font-style/
   * example: font-extrabold
   * example: italic
   */
  getFontStyle(style: string): string {
    if (style.toLowerCase().match("italic")) {
      return "italic";
    }
    return "";
  }
  textAlignHorizontal(): this {
    const node = this.node as TextNode;
    // if alignHorizontal is LEFT, don't do anything because that is native
    // only undefined in testing
    if (node.textAlignHorizontal && node.textAlignHorizontal !== "LEFT") {
      let textAlign = "";
      switch (node.textAlignHorizontal) {
        case "CENTER":
          textAlign = "center";
          break;
        case "RIGHT":
          textAlign = "right";
          break;
        case "JUSTIFIED":
          textAlign = "justify";
          break;
      }
      this.addStyles(formatWithJSX("text-align", this.isJSX, textAlign));
    }
    return this;
  }
  textAlignVertical(): this {
    const node = this.node as TextNode;
    if (node.textAlignVertical && node.textAlignVertical !== "TOP") {
      let alignItems = "";
      switch (node.textAlignVertical) {
        case "CENTER":
          alignItems = "center";
          break;
        case "BOTTOM":
          alignItems = "flex-end";
          break;
      }
      if (alignItems) {
        this.addStyles(
          formatWithJSX("justify-content", this.isJSX, alignItems),
        );
        this.addStyles(formatWithJSX("display", this.isJSX, "flex"));
        this.addStyles(formatWithJSX("flex-direction", this.isJSX, "column"));
      }
    }
    return this;
  }
  private getLayerBlurStyle(): string {
    if (this.node && (this.node as TextNode).effects) {
      const effects = (this.node as TextNode).effects;
      const blurEffect = effects.find(
        (effect) =>
          effect.type === "LAYER_BLUR" &&
          effect.visible !== false &&
          effect.radius > 0,
      );
      if (blurEffect && blurEffect.radius) {
        return `blur(${blurEffect.radius}px)`;
      }
    }
    return "";
  }
  /**
   * Returns a CSS text-shadow value if a drop shadow effect is applied.
   */
  private getTextShadowStyle(): string {
    if (this.node && (this.node as TextNode).effects) {
      const effects = (this.node as TextNode).effects;
      const dropShadow = effects.find(
        (effect) => effect.type === "DROP_SHADOW" && effect.visible !== false,
      );
      if (dropShadow) {
        const ds = dropShadow as DropShadowEffect;
        const offsetX = Math.round(ds.offset.x);
        const offsetY = Math.round(ds.offset.y);
        const blurRadius = Math.round(ds.radius);
        const r = Math.round(ds.color.r * 255);
        const g = Math.round(ds.color.g * 255);
        const b = Math.round(ds.color.b * 255);
        const a = ds.color.a;
        return `${offsetX}px ${offsetY}px ${blurRadius}px rgba(${r}, ${g}, ${b}, ${a.toFixed(
          2,
        )})`;
      }
    }
    return "";
  }
}
</file>

<file path="packages/backend/src/html/builderImpl/htmlColor.ts">
import { numberToFixedString } from "../../common/numToAutoFixed";
import { retrieveTopFill } from "../../common/retrieveFill";
import { GradientPaint, Paint } from "../../api_types";
export const processColorWithVariable = (fill: {
  color: RGB;
  opacity?: number;
  variableColorName?: string;
}): string => {
  const opacity = fill.opacity ?? 1;
  if (fill.variableColorName) {
    const varName = fill.variableColorName;
    const fallbackColor = htmlColor(fill.color, opacity);
    return `var(--${varName}, ${fallbackColor})`;
  }
  return htmlColor(fill.color, opacity);
};
const getColorAndVariable = (
  fill: Paint,
): {
  color: RGB;
  opacity: number;
  variableColorName?: string;
} => {
  if (fill.type === "SOLID") {
    return {
      color: fill.color,
      opacity: fill.opacity ?? 1,
      variableColorName: (fill as any).variableColorName,
    };
  } else if (
    (fill.type === "GRADIENT_LINEAR" ||
      fill.type === "GRADIENT_RADIAL" ||
      fill.type === "GRADIENT_ANGULAR" ||
      fill.type === "GRADIENT_DIAMOND") &&
    fill.gradientStops.length > 0
  ) {
    const firstStop = fill.gradientStops[0];
    return {
      color: firstStop.color,
      opacity: fill.opacity ?? 1,
      variableColorName: (firstStop as any).variableColorName,
    };
  }
  return { color: { r: 0, g: 0, b: 0 }, opacity: 0 };
};
export const htmlColorFromFills = (
  fills: ReadonlyArray<Paint> | undefined,
): string => {
  const fill = retrieveTopFill(fills);
  if (fill) {
    const colorInfo = getColorAndVariable(fill);
    return processColorWithVariable(colorInfo);
  }
  return "";
};
/**
 * Convert fills to an HTML color string
 */
export const htmlColorFromFill = (fill: Paint): string => {
  return processColorWithVariable(fill as any);
};
/**
 * Convert RGB color to CSS color string
 */
export const htmlColor = (color: RGB, alpha: number = 1): string => {
  if (color.r === 1 && color.g === 1 && color.b === 1 && alpha === 1) {
    return "white";
  }
  if (color.r === 0 && color.g === 0 && color.b === 0 && alpha === 1) {
    return "black";
  }
  if (alpha === 1) {
    const r = Math.round(color.r * 255);
    const g = Math.round(color.g * 255);
    const b = Math.round(color.b * 255);
    const toHex = (num: number): string => num.toString(16).padStart(2, "0");
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
  }
  const r = numberToFixedString(color.r * 255);
  const g = numberToFixedString(color.g * 255);
  const b = numberToFixedString(color.b * 255);
  const a = numberToFixedString(alpha);
  return `rgba(${r}, ${g}, ${b}, ${a})`;
};
const processGradientStop = (
  stop: ColorStop,
  fillOpacity: number = 1,
  positionMultiplier: number = 100,
  unit: string = "%",
): string => {
  const fillInfo = {
    color: stop.color,
    opacity: stop.color.a * fillOpacity,
    boundVariables: stop.boundVariables,
    variableColorName: (stop as any).variableColorName,
  };
  const color = processColorWithVariable(fillInfo);
  const position = `${(stop.position * positionMultiplier).toFixed(0)}${unit}`;
  return `${color} ${position}`;
};
const processGradientStops = (
  stops: ReadonlyArray<ColorStop>,
  fillOpacity: number = 1,
  positionMultiplier: number = 100,
  unit: string = "%",
): string => {
  return stops
    .map((stop) =>
      processGradientStop(stop, fillOpacity, positionMultiplier, unit),
    )
    .join(", ");
};
export const htmlGradientFromFills = (fill: Paint): string => {
  if (!fill) return "";
  switch (fill.type) {
    case "GRADIENT_LINEAR":
      return htmlLinearGradient(fill);
    case "GRADIENT_ANGULAR":
      return htmlAngularGradient(fill);
    case "GRADIENT_RADIAL":
      return htmlRadialGradient(fill);
    case "GRADIENT_DIAMOND":
      return htmlDiamondGradient(fill);
    default:
      return "";
  }
};
/**
 * Generate CSS linear gradient
 */
export const htmlLinearGradient = (fill: GradientPaint) => {
  const [start, end] = fill.gradientHandlePositions;
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  let angle = Math.atan2(dy, dx) * (180 / Math.PI); // Angle in degrees
  angle = (angle + 360) % 360; // Normalize to 0-360
  const cssAngle = (angle + 90) % 360; // Adjust for CSS convention
  const mappedFill = processGradientStops(
    fill.gradientStops,
    fill.opacity ?? 1,
  );
  return `linear-gradient(${cssAngle.toFixed(0)}deg, ${mappedFill})`;
};
/**
 * Generate CSS radial gradient
 */
export const htmlRadialGradient = (fill: GradientPaint) => {
  const [center, h1, h2] = fill.gradientHandlePositions;
  const cx = center.x * 100; // Center X as percentage
  const cy = center.y * 100; // Center Y as percentage
  // Calculate horizontal radius (distance from center to h1)
  const rx = Math.sqrt((h1.x - center.x) ** 2 + (h1.y - center.y) ** 2) * 100;
  // Calculate vertical radius (distance from center to h2)
  const ry = Math.sqrt((h2.x - center.x) ** 2 + (h2.y - center.y) ** 2) * 100;
  const mappedStops = processGradientStops(
    fill.gradientStops,
    fill.opacity ?? 1,
  );
  return `radial-gradient(ellipse ${rx.toFixed(2)}% ${ry.toFixed(2)}% at ${cx.toFixed(2)}% ${cy.toFixed(2)}%, ${mappedStops})`;
};
/**
 * Generate CSS conic (angular) gradient
 */
export const htmlAngularGradient = (fill: GradientPaint) => {
  const [center, _, startDirection] = fill.gradientHandlePositions;
  const cx = center.x * 100; // Center X as percentage
  const cy = center.y * 100; // Center Y as percentage
  // Calculate the starting angle
  const dx = startDirection.x - center.x;
  const dy = startDirection.y - center.y;
  let angle = Math.atan2(dy, dx) * (180 / Math.PI); // Convert to degrees
  angle = (angle + 360) % 360; // Normalize to 0-360 degrees
  const mappedFill = processGradientStops(
    fill.gradientStops,
    fill.opacity ?? 1,
    360,
    "deg",
  );
  return `conic-gradient(from ${angle.toFixed(0)}deg at ${cx.toFixed(2)}% ${cy.toFixed(2)}%, ${mappedFill})`;
};
export const htmlDiamondGradient = (fill: GradientPaint) => {
  const stops = processGradientStops(
    fill.gradientStops,
    fill.opacity ?? 1,
    50,
    "%",
  );
  const gradientConfigs = [
    { direction: "to bottom right", position: "bottom right" },
    { direction: "to bottom left", position: "bottom left" },
    { direction: "to top left", position: "top left" },
    { direction: "to top right", position: "top right" },
  ];
  return gradientConfigs
    .map(
      ({ direction, position }) =>
        `linear-gradient(${direction}, ${stops}) ${position} / 50% 50% no-repeat`,
    )
    .join(", ");
};
export const buildBackgroundValues = (
  paintArray: ReadonlyArray<Paint> | PluginAPI["mixed"],
): string => {
  if (paintArray === figma.mixed) {
    return "";
  }
  // If only one fill, use plain color or gradient
  if (paintArray.length === 1) {
    const paint = paintArray[0];
    if (paint.type === "SOLID") {
      return htmlColorFromFills(paintArray);
    } else if (
      paint.type === "GRADIENT_LINEAR" ||
      paint.type === "GRADIENT_RADIAL" ||
      paint.type === "GRADIENT_ANGULAR" ||
      paint.type === "GRADIENT_DIAMOND"
    ) {
      return htmlGradientFromFills(paint);
    }
    return "";
  }
  // For multiple fills, reverse to match CSS layering (first is top-most)
  const styles = [...paintArray].reverse().map((paint, index) => {
    if (paint.type === "SOLID") {
      const color = htmlColorFromFills([paint]);
      if (index === 0) {
        return `linear-gradient(0deg, ${color} 0%, ${color} 100%)`;
      }
      return color;
    } else if (
      paint.type === "GRADIENT_LINEAR" ||
      paint.type === "GRADIENT_RADIAL" ||
      paint.type === "GRADIENT_ANGULAR" ||
      paint.type === "GRADIENT_DIAMOND"
    ) {
      return htmlGradientFromFills(paint);
    }
    return ""; // Handle other paint types safely
  });
  return styles.filter((value) => value !== "").join(", ");
};
</file>

<file path="packages/plugin-ui/src/PluginUI.tsx">
import copy from "copy-to-clipboard";
import Preview from "./components/Preview";
import GradientsPanel from "./components/GradientsPanel";
import ColorsPanel from "./components/ColorsPanel";
import CodePanel from "./components/CodePanel";
import About from "./components/About";
import WarningsPanel from "./components/WarningsPanel";
import {
  Framework,
  HTMLPreview,
  LinearGradientConversion,
  PluginSettings,
  SolidColorConversion,
  Warning,
} from "types";
import {
  preferenceOptions,
  selectPreferenceOptions,
} from "./codegenPreferenceOptions";
import Loading from "./components/Loading";
import { useState } from "react";
import { InfoIcon } from "lucide-react";
import React from "react";
type PluginUIProps = {
  code: string;
  htmlPreview: HTMLPreview;
  warnings: Warning[];
  selectedFramework: Framework;
  setSelectedFramework: (framework: Framework) => void;
  settings: PluginSettings | null;
  onPreferenceChanged: (
    key: keyof PluginSettings,
    value: boolean | string | number,
  ) => void;
  colors: SolidColorConversion[];
  gradients: LinearGradientConversion[];
  isLoading: boolean;
};
const frameworks: Framework[] = ["HTML", "Tailwind", "Flutter", "SwiftUI"];
type FrameworkTabsProps = {
  frameworks: Framework[];
  selectedFramework: Framework;
  setSelectedFramework: (framework: Framework) => void;
  showAbout: boolean;
  setShowAbout: (show: boolean) => void;
};
const FrameworkTabs = ({
  frameworks,
  selectedFramework,
  setSelectedFramework,
  showAbout,
  setShowAbout,
}: FrameworkTabsProps) => {
  return (
    <div className="grid grid-cols-4 sm:grid-cols-2 md:grid-cols-4 gap-1 grow">
      {frameworks.map((tab) => (
        <button
          key={`tab ${tab}`}
          className={`w-full text-sm rounded-md transition-colors font-medium ${
            selectedFramework === tab && !showAbout
              ? "bg-primary text-primary-foreground shadow-xs"
              : "bg-muted hover:bg-primary/90 hover:text-primary-foreground"
          }`}
          onClick={() => {
            setSelectedFramework(tab as Framework);
            setShowAbout(false);
          }}
        >
          {tab}
        </button>
      ))}
    </div>
  );
};
export const PluginUI = (props: PluginUIProps) => {
  const [showAbout, setShowAbout] = useState(false);
  const [previewExpanded, setPreviewExpanded] = useState(false);
  const [previewViewMode, setPreviewViewMode] = useState<
    "desktop" | "mobile" | "precision"
  >("precision");
  const [previewBgColor, setPreviewBgColor] = useState<"white" | "black">(
    "white",
  );
  if (props.isLoading) return <Loading />;
  const isEmpty = props.code === "";
  const warnings = props.warnings ?? [];
  return (
    <div className="flex flex-col h-full dark:text-white">
      <div className="p-2 dark:bg-card">
        <div className="flex gap-1 bg-muted dark:bg-card rounded-lg p-1">
          <FrameworkTabs
            frameworks={frameworks}
            selectedFramework={props.selectedFramework}
            setSelectedFramework={props.setSelectedFramework}
            showAbout={showAbout}
            setShowAbout={setShowAbout}
          />
          <button
            className={`w-8 h-8 flex items-center justify-center rounded-md text-sm font-medium ${
              showAbout
                ? "bg-primary text-primary-foreground shadow-xs"
                : "bg-muted hover:bg-primary/90 hover:text-primary-foreground"
            }`}
            onClick={() => setShowAbout(!showAbout)}
            aria-label="About"
          >
            <InfoIcon size={16} />
          </button>
        </div>
      </div>
      <div
        style={{
          height: 1,
          width: "100%",
          backgroundColor: "rgba(255,255,255,0.12)",
        }}
      ></div>
      <div className="flex flex-col h-full overflow-y-auto">
        {showAbout ? (
          <About
            useOldPluginVersion={props.settings?.useOldPluginVersion2025}
            onPreferenceChanged={props.onPreferenceChanged}
          />
        ) : (
          <div className="flex flex-col items-center px-4 py-2 gap-2 dark:bg-transparent">
            {isEmpty === false && props.htmlPreview && (
              <Preview
                htmlPreview={props.htmlPreview}
                expanded={previewExpanded}
                setExpanded={setPreviewExpanded}
                viewMode={previewViewMode}
                setViewMode={setPreviewViewMode}
                bgColor={previewBgColor}
                setBgColor={setPreviewBgColor}
              />
            )}
            {warnings.length > 0 && <WarningsPanel warnings={warnings} />}
            <CodePanel
              code={props.code}
              selectedFramework={props.selectedFramework}
              preferenceOptions={preferenceOptions}
              selectPreferenceOptions={selectPreferenceOptions}
              settings={props.settings}
              onPreferenceChanged={props.onPreferenceChanged}
            />
            {props.colors.length > 0 && (
              <ColorsPanel
                colors={props.colors}
                onColorClick={(value) => {
                  copy(value);
                }}
              />
            )}
            {props.gradients.length > 0 && (
              <GradientsPanel
                gradients={props.gradients}
                onColorClick={(value) => {
                  copy(value);
                }}
              />
            )}
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="apps/plugin/package.json">
{
  "name": "plugin",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "pnpm run build:ui && pnpm run build:main --minify --tree-shaking=true",
    "build:main": "esbuild plugin-src/code.ts --bundle --target=ES6 --outfile=dist/code.js",
    "build:ui": "vite build --minify esbuild --emptyOutDir=false",
    "build:watch": "concurrently -n backend,ui \"pnpm run build:main --watch\" \"pnpm run build:ui --watch\"",
    "dev": "pnpm build:watch"
  },
  "dependencies": {
    "@figma/plugin-typings": "^1.109.0",
    "backend": "workspace:*",
    "clsx": "^2.1.1",
    "copy-to-clipboard": "^3.3.3",
    "lucide-react": "^0.483.0",
    "motion": "^12.6.2",
    "nanoid": "^5.1.5",
    "plugin-ui": "workspace:*",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.0.2"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.0.17",
    "@types/node": "^22.13.14",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "@typescript-eslint/eslint-plugin": "^8.28.0",
    "@typescript-eslint/parser": "^8.28.0",
    "@vitejs/plugin-react": "^4.3.4",
    "@vitejs/plugin-react-swc": "^3.8.1",
    "concurrently": "^9.1.2",
    "esbuild": "^0.25.1",
    "eslint-config-custom": "workspace:*",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "postcss": "^8.5.3",
    "tailwindcss": "4.0.14",
    "tsconfig": "workspace:*",
    "types": "workspace:*",
    "typescript": "^5.8.2",
    "vite": "^5.4.15",
    "vite-plugin-singlefile": "^2.2.0"
  }
}
</file>

<file path="packages/backend/src/common/commonPosition.ts">
import { HTMLSettings, TailwindSettings } from "types";
export const getCommonPositionValue = (
  node: SceneNode,
  settings?: HTMLSettings | TailwindSettings,
): { x: number; y: number } => {
  if (node.parent && node.parent.absoluteBoundingBox) {
    if (settings?.embedVectors && node.svg) {
      return {
        x: node.absoluteBoundingBox.x - node.parent.absoluteBoundingBox.x,
        y: node.absoluteBoundingBox.y - node.parent.absoluteBoundingBox.y,
      };
    }
    return { x: node.x, y: node.y };
  }
  if (node.parent && node.parent.type === "GROUP") {
    return {
      x: node.x - node.parent.x,
      y: node.y - node.parent.y,
    };
  }
  return {
    x: node.x,
    y: node.y,
  };
};
interface BoundingBox {
  width: number;
  height: number;
  x: number;
  y: number;
}
interface RectangleStyle {
  width: number;
  height: number;
  left: number;
  top: number;
  rotation: number;
}
export function calculateRectangleFromBoundingBox(
  boundingBox: BoundingBox,
  figmaRotationDegrees: number,
): RectangleStyle {
  const cssRotationDegrees = -figmaRotationDegrees;
  const theta = (cssRotationDegrees * Math.PI) / 180;
  const cosTheta = Math.cos(theta);
  const sinTheta = Math.sin(theta);
  const absCosTheta = Math.abs(cosTheta);
  const absSinTheta = Math.abs(sinTheta);
  const { width: w_b, height: h_b, x: x_b, y: y_b } = boundingBox;
  const denominator = absCosTheta * absCosTheta - absSinTheta * absSinTheta;
  const h = (w_b * absSinTheta - h_b * absCosTheta) / -denominator;
  const w = (w_b - h * absSinTheta) / absCosTheta;
  const corners = [
    { x: 0, y: 0 },
    { x: w, y: 0 },
    { x: w, y: h },
    { x: 0, y: h },
  ];
  const rotatedCorners = corners.map(({ x, y }) => ({
    x: x * cosTheta + y * sinTheta,
    y: -x * sinTheta + y * cosTheta,
  }));
  const minX = Math.min(...rotatedCorners.map((c) => c.x));
  const minY = Math.min(...rotatedCorners.map((c) => c.y));
  const left = x_b - minX;
  const top = y_b - minY;
  return {
    width: parseFloat(w.toFixed(2)),
    height: parseFloat(h.toFixed(2)),
    left: parseFloat(left.toFixed(2)),
    top: parseFloat(top.toFixed(2)),
    rotation: cssRotationDegrees,
  };
}
export const commonIsAbsolutePosition = (node: SceneNode) => {
  if ("layoutPositioning" in node && node.layoutPositioning === "ABSOLUTE") {
    return true;
  }
  if (!node.parent || node.parent === undefined) {
    return false;
  }
  if (
    ("layoutMode" in node.parent && node.parent.layoutMode === "NONE") ||
    !("layoutMode" in node.parent)
  ) {
    return true;
  }
  return false;
};
</file>

<file path="packages/backend/src/tailwind/tailwindMain.ts">
import { retrieveTopFill } from "../common/retrieveFill";
import { indentString } from "../common/indentString";
import { addWarning } from "../common/commonConversionWarnings";
import { getVisibleNodes } from "../common/nodeVisibility";
import { getPlaceholderImage } from "../common/images";
import { TailwindTextBuilder } from "./tailwindTextBuilder";
import { TailwindDefaultBuilder } from "./tailwindDefaultBuilder";
import { tailwindAutoLayoutProps } from "./builderImpl/tailwindAutoLayout";
import { renderAndAttachSVG } from "../altNodes/altNodeUtils";
import { AltNode, PluginSettings, TailwindSettings } from "types";
export let localTailwindSettings: PluginSettings;
let previousExecutionCache: {
  style: string;
  text: string;
  openTypeFeatures: Record<string, boolean>;
}[] = [];
const SELF_CLOSING_TAGS = ["img"];
export const tailwindMain = async (
  sceneNode: Array<SceneNode>,
  settings: PluginSettings,
): Promise<string> => {
  console.log("tailwindMain: Starting code generation for sceneNode", sceneNode);
  localTailwindSettings = settings;
  previousExecutionCache = [];
  let result = await tailwindWidgetGenerator(sceneNode, settings);
  console.log("tailwindMain[29]: Raw generated result:", result);
  if (result.startsWith("\n")) {
    result = result.slice(1);
    console.log("tailwindMain[34]: Removed leading newline, updated result:", result);
  }
  console.log("tailwindMain[37]: Finished code generation, returning result");
  return result;
};
const tailwindWidgetGenerator = async (
  sceneNode: ReadonlyArray<SceneNode>,
  settings: TailwindSettings,
): Promise<string> => {
  console.log("tailwindWidgetGenerator[45]: Received scene nodes:", sceneNode);
  const visibleNodes = getVisibleNodes(sceneNode);
  console.log("tailwindWidgetGenerator[47]: Filtered visible nodes:", visibleNodes);
  const promiseOfConvertedCode = visibleNodes.map(convertNode(settings));
  const code = (await Promise.all(promiseOfConvertedCode)).join("");
  console.log("tailwindWidgetGenerator[50]: Combined converted code:");
  return code;
};
const convertNode =
  (settings: TailwindSettings) =>
  async (node: SceneNode): Promise<string> => {
    console.log("convertNode[57]: Processing node", node.id, "of type", node.type);
    if (settings.embedVectors && (node as any).canBeFlattened) {
      console.log("convertNode[59]: Node can be flattened and embedVectors is true for", node.id);
      const altNode = await renderAndAttachSVG(node);
      console.log("convertNode[61]: Received altNode:", altNode.id);
      if (altNode.svg) {
        console.log("convertNode[63]: SVG exists for node", node.id, "wrapping SVG now.");
        return tailwindWrapSVG(altNode, settings);
      }
    }
    console.log("convertName[68]", node.type)
    switch (node.type) {
      case "RECTANGLE":
      case "ELLIPSE":
        console.log("convertNode: Handling RECTANGLE/ELLIPSE node", node.id);
        return tailwindContainer(node, "", "", settings);
      case "GROUP":
        console.log("convertNode: Handling GROUP node", node.id);
        return tailwindGroup(node, settings);
      case "FRAME":
      case "COMPONENT":
      case "INSTANCE":
      case "COMPONENT_SET":
        console.log("convertNode[81]: Handling FRAME/COMPONENT/INSTANCE/COMPONENT_SET node", node.id);
        return tailwindFrame(node, settings);
      case "TEXT":
        console.log("convertNode: Handling TEXT node", node.id);
        return tailwindText(node, settings);
      case "LINE":
        console.log("convertNode: Handling LINE node", node.id);
        return tailwindLine(node, settings);
      case "SECTION":
        console.log("convertNode: Handling SECTION node", node.id);
        return tailwindSection(node, settings);
      case "VECTOR":
        console.log("convertNode: Handling VECTOR node", node.id);
        if (!settings.embedVectors) {
          addWarning("Vector is not supported");
          console.log("convertNode: Warning added for VECTOR node", node.id);
        }
        return tailwindContainer(
          { ...node, type: "RECTANGLE" } as any,
          "",
          "",
          settings,
        );
      default:
        addWarning(`${node.type} node is not supported`);
        console.log("convertNode: Node type not supported:", node.type);
    }
    return "";
  };
const tailwindWrapSVG = (
  node: AltNode<SceneNode>,
  settings: TailwindSettings,
): string => {
  console.log("tailwindWrapSVG: Wrapping SVG for node", node.id);
  if (!node.svg) {
    console.log("tailwindWrapSVG: No SVG available for node", node.id);
    return "";
  }
  const builder = new TailwindDefaultBuilder(node, settings)
    .addData("svg-wrapper")
    .position();
  const builtAttributes = builder.build();
  console.log("tailwindWrapSVG: Built attributes for SVG wrapper:", builtAttributes);
  return `\n<div${builtAttributes}>\n${node.svg}</div>`;
};
const tailwindGroup = async (
  node: GroupNode,
  settings: TailwindSettings,
): Promise<string> => {
  console.log("tailwindGroup: Processing GROUP node", node.id);
  if (node.width < 0 || node.height <= 0 || node.children.length === 0) {
    console.log("tailwindGroup: Group node has invalid dimensions or no children", node.id);
    return "";
  }
  const builder = new TailwindDefaultBuilder(node, settings)
    .blend()
    .size()
    .position();
  console.log("tailwindGroup: Builder attributes:", builder.attributes, "Style:", builder.style);
  if (builder.attributes || builder.style) {
    const attr = builder.build("");
    console.log("tailwindGroup[144]: Built attributes:", attr);
    const generator = await tailwindWidgetGenerator(node.children, settings);
    console.log("tailwindGroup[146]: Generated children code:");
    return `\n<div${attr}>${indentString(generator)}\n</div>`;
  }
  const childrenCode = await tailwindWidgetGenerator(node.children, settings);
  console.log("tailwindGroup: Returning children code for GROUP node:", childrenCode);
  return childrenCode;
};
export const tailwindText = (
  node: TextNode,
  settings: TailwindSettings,
): string => {
  console.log("tailwindText: Processing TEXT node", node.id);
  const layoutBuilder = new TailwindTextBuilder(node, settings)
    .commonPositionStyles()
    .textAlignHorizontal()
    .textAlignVertical();
  const styledHtml = layoutBuilder.getTextSegments(node);
  console.log("tailwindText: Styled HTML segments:", styledHtml);
  previousExecutionCache.push(...styledHtml);
  let content = "";
  if (styledHtml.length === 1) {
    const segment = styledHtml[0];
    layoutBuilder.addAttributes(segment.style);
    const getFeatureTag = (features: Record<string, boolean>): string => {
      if (features.SUBS === true) return "sub";
      if (features.SUPS === true) return "sup";
      return "";
    };
    const additionalTag = getFeatureTag(segment.openTypeFeatures);
    content = additionalTag
      ? `<${additionalTag}>${segment.text}</${additionalTag}>`
      : segment.text;
  } else {
    content = styledHtml
      .map((style) => {
        const tag =
          style.openTypeFeatures.SUBS === true
            ? "sub"
            : style.openTypeFeatures.SUPS === true
              ? "sup"
              : "span";
        return `<${tag} class="${style.style}">${style.text}</${tag}>`;
      })
      .join("");
  }
  const builtAttributes = layoutBuilder.build();
  console.log("tailwindText[192]: Built layout builder attributes:", builtAttributes);
  return `\n<div${builtAttributes}>${content}</div>`;
};
const tailwindFrame = async (
  node: FrameNode | InstanceNode | ComponentNode | ComponentSetNode,
  settings: TailwindSettings,
): Promise<string> => {
  console.log("tailwindFrame[200]: Processing frame-like node", node.id);
  const childrenStr = await tailwindWidgetGenerator(node.children, settings);
  console.log("tailwindFrame[202]: Generated children string:");
  const clipsContentClass =
    node.clipsContent && "children" in node && node.children.length > 0
      ? "overflow-hidden"
      : "";
  let layoutProps = "";
  if (node.layoutMode !== "NONE") {
    layoutProps = tailwindAutoLayoutProps(node, node);
    console.log("tailwindFrame[210]: Layout properties from auto layout:", layoutProps);
  }
  const combinedProps = [layoutProps, clipsContentClass]
    .filter(Boolean)
    .join(" ");
  console.log("tailwindFrame[215]: Combined properties for frame:", combinedProps);
  const containREsult= tailwindContainer(node, childrenStr, combinedProps, settings);
  console.log("tailwindFrame[217]: tailwindFrame call complete");
  return containREsult;
};
export const tailwindContainer = (
  node: SceneNode &
    SceneNodeMixin &
    BlendMixin &
    LayoutMixin &
    GeometryMixin &
    MinimalBlendMixin,
  children: string,
  additionalAttr: string,
  settings: TailwindSettings,
): string => {
  console.log("tailwindContainer[230]: Processing container node", node.id);
  if (node.width < 0 || node.height < 0) {
    console.log("tailwindContainer[232]: Node has invalid dimensions, returning children for node", node.id);
    return children;
  }
  const builder = new TailwindDefaultBuilder(node, settings)
    .commonPositionStyles()
    .commonShapeStyles();
  if (!builder.attributes && !additionalAttr) {
    console.log("tailwindContainer[239]: Builder has no attributes, returning children for node", node.id);
    return children;
  }
  const build = builder.build(additionalAttr);
  console.log("tailwindContainer[243]: Built attributes:", build);
  let tag = "div";
  let src = "";
  const topFill = retrieveTopFill(node.fills);
  console.log("tailwindContainer[247]");
  if (topFill?.type === "IMAGE") {
    addWarning("Image fills are replaced with placeholders");
    console.log("tailwindContainer[250]");
    const imageURL = getPlaceholderImage(node.width, node.height);
    if (!("children" in node) || node.children.length === 0) {
      tag = "img";
      src = ` src="${imageURL}"`;
      console.log("tailwindContainer[254]: Using img tag with src", imageURL);
    } else {
      builder.addAttributes(`bg-[url(${imageURL})]`);
      console.log("tailwindContainer[257]: Added background image attribute", imageURL);
    }
  }
  if (children) {
    const container = `\n<${tag}${build}${src}>${indentString(children)}\n</${tag}>`;
    console.log("tailwindContainer[261]: Returning container with children:");
    return container;
  } else if (
    SELF_CLOSING_TAGS.includes(tag) ||
    settings.tailwindGenerationMode === "jsx"
  ) {
    const container = `\n<${tag}${build}${src} />`;
    console.log("tailwindContainer[268]: Returning self-closing container:");
    return container;
  } else {
    const container = `\n<${tag}${build}${src}></${tag}>`;
    console.log("tailwindContainer[272]: Returning container without children:");
    return container;
  }
};
export const tailwindLine = (
  node: LineNode,
  settings: TailwindSettings,
): string => {
  console.log("tailwindLine[283]: Processing LINE node", node.id);
  const builder = new TailwindDefaultBuilder(node, settings)
    .commonPositionStyles()
    .commonShapeStyles();
  const lineContainer = `\n<div${builder.build()}></div>`;
  console.log("tailwindLine[288]: Generated line container:", lineContainer);
  return lineContainer;
};
export const tailwindSection = async (
  node: SectionNode,
  settings: TailwindSettings,
): Promise<string> => {
  console.log("tailwindSection[294]: Processing SECTION node", node.id);
  const childrenStr = await tailwindWidgetGenerator(node.children, settings);
  const builder = new TailwindDefaultBuilder(node, settings)
    .size()
    .position()
    .customColor(node.fills, "bg");
  const build = builder.build();
  const sectionContainer = childrenStr
    ? `\n<div${build}>${indentString(childrenStr)}\n</div>`
    : `\n<div${build}></div>`;
  console.log("tailwindSection[306]: Generated section container:", sectionContainer);
  return sectionContainer;
};
export const tailwindCodeGenTextStyles = (): string => {
  if (previousExecutionCache.length === 0) {
    console.log("tailwindCodeGenTextStyles[312]: No text styles found");
    return "// No text styles in this selection";
  }
  const codeStyles = previousExecutionCache
    .map((style) => `// ${style.text}\n${style.style.split(" ").join("\n")}`)
    .join("\n---\n");
  console.log("tailwindCodeGenTextStyles[318]: Generated text style code:", codeStyles);
  return codeStyles;
};
</file>

<file path="packages/plugin-ui/src/components/Preview.tsx">
import React from "react";
import { HTMLPreview } from "types";
import {
  Maximize2,
  Minimize2,
  MonitorSmartphone,
  Smartphone,
  Circle,
  Ruler,
  Monitor,
} from "lucide-react";
import { cn } from "../lib/utils";
const Preview: React.FC<{
  htmlPreview: HTMLPreview;
  expanded: boolean;
  setExpanded: React.Dispatch<React.SetStateAction<boolean>>;
  viewMode: "desktop" | "mobile" | "precision";
  setViewMode: React.Dispatch<
    React.SetStateAction<"desktop" | "mobile" | "precision">
  >;
  bgColor: "white" | "black";
  setBgColor: React.Dispatch<React.SetStateAction<"white" | "black">>;
}> = (props) => {
  const {
    htmlPreview,
    expanded,
    setExpanded,
    viewMode,
    setViewMode,
    bgColor,
    setBgColor,
  } = props;
  const containerWidth = expanded ? 320 : 240;
  const containerHeight = expanded ? 180 : 120;
  const scaleFactor = Math.min(
    containerWidth / htmlPreview.size.width,
    containerHeight / htmlPreview.size.height,
  );
  const contentWidth =
    viewMode === "desktop"
      ? containerWidth
      : viewMode === "mobile"
        ? Math.floor(containerWidth * 0.4)
        : htmlPreview.size.width * scaleFactor + 2;
  return (
    <div className="flex flex-col w-full bg-card rounded-lg border border-border">
      {}
      <div className="flex justify-between items-center px-3 py-2 border-b border-border">
        <h3 className="text-sm font-medium text-muted-foreground flex items-center gap-2">
          <MonitorSmartphone size={16} />
          Preview
        </h3>
        <div className="flex items-center gap-1">
          {}
          <button
            onClick={() => setBgColor(bgColor === "white" ? "black" : "white")}
            className="p-1.5 mr-1 rounded-sm hover:bg-neutral-100 dark:hover:bg-neutral-700 text-neutral-500 dark:text-neutral-400 transition-colors"
            aria-label={`Switch the preview to ${bgColor === "white" ? "black" : "white"} background.\nUseful to avoid black text on black background.`}
            title={`Switch the preview to ${bgColor === "white" ? "black" : "white"} background.\nUseful to avoid black text on black background.`}
          >
            <Circle size={14} fill={bgColor} className="stroke-current" />
          </button>
          {}
          {
}
          {}
          <button
            onClick={() => setExpanded(!expanded)}
            className="p-1 rounded-sm hover:bg-neutral-100 dark:hover:bg-neutral-700 text-neutral-500 dark:text-neutral-400 transition-colors"
            aria-label={expanded ? "Minimize preview" : "Maximize preview"}
            title={expanded ? "Minimize preview" : "Maximize preview"}
          >
            {expanded ? <Minimize2 size={14} /> : <Maximize2 size={14} />}
          </button>
        </div>
      </div>
      {}
      <div className="flex justify-center items-center bg-neutral-50 dark:bg-neutral-900 p-3">
        {}
        <div
          className="relative"
          style={{
            width: containerWidth,
            height: containerHeight,
            transition: "width 0.3s ease, height 0.3s ease",
          }}
        >
          {}
          <div
            className={`absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2`}
            style={{
              width: contentWidth,
              height:
                viewMode === "mobile"
                  ? Math.min(containerHeight * 0.9, containerHeight)
                  : viewMode === "precision"
                    ? htmlPreview.size.height * scaleFactor
                    : containerHeight,
              transition: "width 0.3s ease, height 0.3s ease",
            }}
          >
            {}
            <div
              className={cn(
                "w-full h-full flex justify-center items-center overflow-hidden",
                bgColor === "white" ? "bg-white" : "bg-black",
                viewMode === "desktop"
                  ? "border border-neutral-300 dark:border-neutral-600 rounded-sm shadow-2xs"
                  : viewMode === "mobile"
                    ? "border-2 border-neutral-400 dark:border-neutral-500 rounded-xl shadow-2xs"
                    : "border border-indigo-400 dark:border-indigo-500 rounded-sm shadow-2xs",
                `transition-all duration-300 ease-in-out`,
              )}
            >
              {}
              <div className="w-full h-full flex justify-center items-center">
                <div
                  style={{
                    zoom: scaleFactor,
                    width:
                      viewMode === "precision"
                        ? htmlPreview.size.width
                        : "100%",
                    height:
                      viewMode === "precision"
                        ? htmlPreview.size.height
                        : "100%",
                    transformOrigin: "center",
                    maxWidth: "100%",
                    maxHeight: "100%",
                    aspectRatio:
                      viewMode === "precision"
                        ? `${htmlPreview.size.width} / ${htmlPreview.size.height}`
                        : undefined,
                    transition: "all 0.3s ease",
                  }}
                  dangerouslySetInnerHTML={{
                    __html: htmlPreview.content,
                  }}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
      {}
      <div className="px-3 py-1.5 text-xs text-neutral-500 dark:text-neutral-400 flex items-center justify-between border-t border-neutral-200 dark:border-neutral-700">
        <span>
          {htmlPreview.size.width.toFixed(0)}
          {htmlPreview.size.height.toFixed(0)}px
        </span>
        {
}
      </div>
    </div>
  );
};
export default Preview;
</file>

<file path="packages/plugin-ui/src/codegenPreferenceOptions.ts">
import { LocalCodegenPreferenceOptions, SelectPreferenceOptions } from "types";
export const preferenceOptions: LocalCodegenPreferenceOptions[] = [
  {
    itemType: "individual_select",
    propertyName: "useTailwind4",
    label: "Tailwind 4",
    description: "Enable Tailwind CSS version 4 features and syntax.",
    isDefault: false,
    includedLanguages: ["Tailwind"],
  },
  {
    itemType: "individual_select",
    propertyName: "showLayerNames",
    label: "Layer names",
    description: "Include Figma layer names in classes.",
    isDefault: false,
    includedLanguages: ["HTML", "Tailwind"],
  },
  {
    itemType: "individual_select",
    propertyName: "roundTailwindValues",
    label: "Round values",
    description:
      "Round pixel values to nearest Tailwind sizes (within a 15% range).",
    isDefault: false,
    includedLanguages: ["Tailwind"],
  },
  {
    itemType: "individual_select",
    propertyName: "roundTailwindColors",
    label: "Round colors",
    description: "Round Figma color values to nearest Tailwind colors.",
    isDefault: false,
    includedLanguages: ["Tailwind"],
  },
  {
    itemType: "individual_select",
    propertyName: "useColorVariables",
    label: "Color Variables",
    description:
      "Export code using Figma variables as colors. Example: 'bg-background' instead of 'bg-white'.",
    isDefault: true,
    includedLanguages: ["HTML", "Tailwind", "Flutter"],
  },
  {
    itemType: "individual_select",
    propertyName: "embedImages",
    label: "Embed Images",
    description:
      "Convert Figma images to Base64 and embed them in the code. This may be slow. If there are too many images, it could freeze Figma.",
    isDefault: false,
    includedLanguages: ["HTML"],
  },
  {
    itemType: "individual_select",
    propertyName: "embedVectors",
    label: "Embed Vectors",
    description:
      "Enable this to convert vector shapes to SVGs and embed them in the design. This can be a slow operation. If unchecked, shapes will be converted into rectangles.",
    isDefault: false,
    includedLanguages: ["HTML", "Tailwind"],
  },
];
export const selectPreferenceOptions: SelectPreferenceOptions[] = [
  {
    itemType: "select",
    propertyName: "htmlGenerationMode",
    label: "Mode",
    options: [
      { label: "HTML", value: "html" },
      { label: "React (JSX)", value: "jsx" },
      { label: "Svelte", value: "svelte" },
      { label: "styled-components", value: "styled-components" },
    ],
    includedLanguages: ["HTML"],
  },
  {
    itemType: "select",
    propertyName: "tailwindGenerationMode",
    label: "Mode",
    options: [
      { label: "HTML", value: "html" },
      { label: "React (JSX)", value: "jsx" },
    ],
    includedLanguages: ["Tailwind"],
  },
  {
    itemType: "select",
    propertyName: "flutterGenerationMode",
    label: "Mode",
    options: [
      { label: "Full App", value: "fullApp" },
      { label: "Widget", value: "stateless" },
      { label: "Snippet", value: "snippet" },
    ],
    includedLanguages: ["Flutter"],
  },
  {
    itemType: "select",
    propertyName: "swiftUIGenerationMode",
    label: "Mode",
    options: [
      { label: "Preview", value: "preview" },
      { label: "Struct", value: "struct" },
      { label: "Snippet", value: "snippet" },
    ],
    includedLanguages: ["SwiftUI"],
  },
];
</file>

<file path="packages/backend/src/tailwind/conversionTables.ts">
import { nearestColorFrom } from "../nearest-color/nearestColor";
import { numberToFixedString } from "../common/numToAutoFixed";
import { localTailwindSettings } from "./tailwindMain";
import { config } from "./tailwindConfig";
import { rgbTo6hex } from "../common/color";
export const nearestValue = (goal: number, array: Array<number>): number => {
  return array.reduce((prev, curr) => {
    return Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev;
  });
};
export const nearestValueWithThreshold = (
  goal: number,
  array: Array<number>,
  thresholdPercent: number = 15,
): number | null => {
  const nearest = nearestValue(goal, array);
  const diff = Math.abs(nearest - goal);
  const percentDiff = (diff / goal) * 100;
  if (percentDiff <= thresholdPercent) {
    return nearest;
  }
  return null;
};
export const exactValue = (
  goal: number,
  array: Array<number>,
): number | null => {
  for (let i = 0; i < array.length; i++) {
    const diff = Math.abs(goal - array[i]);
    if (diff <= 0.05) {
      return array[i];
    }
  }
  return null;
};
const pxToRemToTailwind = (
  value: number,
  conversionMap: Record<number, string>,
): string => {
  const keys = Object.keys(conversionMap).map((d) => +d);
  const baseFontSize = localTailwindSettings.baseFontSize || 16;
  const remValue = value / baseFontSize;
  const convertedValue = exactValue(remValue, keys);
  if (convertedValue) {
    return conversionMap[convertedValue];
  } else if (localTailwindSettings.roundTailwindValues) {
    const thresholdValue = nearestValueWithThreshold(remValue, keys, 15);
    if (thresholdValue !== null) {
      return conversionMap[thresholdValue];
    }
  }
  return `[${numberToFixedString(value)}px]`;
};
const pxToTailwind = (
  value: number,
  conversionMap: Record<number, string>,
): string | null => {
  const keys = Object.keys(conversionMap).map((d) => +d);
  const convertedValue = exactValue(value, keys);
  if (convertedValue) {
    return conversionMap[convertedValue];
  } else if (localTailwindSettings.roundTailwindValues) {
    const thresholdValue = nearestValueWithThreshold(value, keys, 15);
    if (thresholdValue !== null) {
      return conversionMap[thresholdValue];
    }
  }
  return `[${numberToFixedString(value)}px]`;
};
export const pxToLetterSpacing = (value: number): string => {
  return pxToRemToTailwind(value, config.letterSpacing);
};
export const pxToLineHeight = (value: number): string => {
  return pxToRemToTailwind(value, config.lineHeight);
};
export const pxToFontSize = (value: number): string => {
  return pxToRemToTailwind(value, config.fontSize);
};
export const pxToBorderRadius = (value: number): string => {
  const conversionMap = localTailwindSettings.useTailwind4
  ? config.borderRadiusV4
  : config.borderRadius;
  return pxToRemToTailwind(value, conversionMap);
};
export const pxToBorderWidth = (value: number): string | null => {
  return pxToTailwind(value, config.border);
};
export const pxToOutline = (value: number): string | null => {
  return pxToTailwind(value, config.outline);
};
export const pxToBlur = (value: number): string | null => {
  const conversionMap = localTailwindSettings.useTailwind4
  ? config.blurV4
  : config.blur;
  return pxToTailwind(value, conversionMap);
};
export const pxToLayoutSize = (value: number): string => {
  const baseFontSize = localTailwindSettings.baseFontSize || 16;
  const scaledValue = (value * 16) / baseFontSize;
  const result = pxToTailwind(scaledValue, config.layoutSize);
  return result !== null ? result : `[${numberToFixedString(value)}px]`;
};
export const nearestOpacity = (nodeOpacity: number): number => {
  return nearestValue(nodeOpacity * 100, config.opacity);
};
export const nearestColor = nearestColorFrom(Object.keys(config.color));
export const nearestColorFromRgb = (color: RGB) => {
  const colorMultiplied = {
    r: color.r * 255,
    g: color.g * 255,
    b: color.b * 255,
  };
  const value = nearestColor(colorMultiplied);
  const name = config.color[value];
  return { name, value };
};
export const variableToColorName = async (id: string) => {
  return (
    (await figma.variables.getVariableByIdAsync(id))?.name
      .replaceAll("/", "-")
      .replaceAll(" ", "-") || id.toLowerCase().replaceAll(":", "-")
  );
};
export function getColorInfo(fill: SolidPaint | ColorStop) {
  let colorName: string;
  let colorType: "arbitrary" | "tailwind" | "variable";
  let hex: string = "#" + rgbTo6hex(fill.color);
  let meta: string = "";
  // variable
  if ((fill as any).variableColorName) {
    // Use pre-computed variable name if available
    colorName = (fill as any).variableColorName; // || variableToColorName(fill.boundVariables.color);
    colorType = "variable";
    meta = "custom";
    return {
      colorType,
      colorName,
      hex,
      meta,
    };
  }
  if (fill.color.r === 0 && fill.color.g === 0 && fill.color.b === 0) {
    return {
      colorType: "tailwind",
      colorName: "black",
      hex: "#000000",
      meta: "",
    };
  } else if (fill.color.r === 1 && fill.color.g === 1 && fill.color.b === 1) {
    return {
      colorType: "tailwind",
      colorName: "white",
      hex: "#ffffff",
      meta: "",
    };
  } else {
    // get tailwind color as comparison
    const { name, value } = nearestColorFromRgb(fill.color);
    // round color
    if (localTailwindSettings.roundTailwindColors || hex === value) {
      colorName = name;
      colorType = "tailwind";
      if (hex !== value) {
        meta = "rounded";
      }
      hex = value;
    }
    else {
      colorName = `[${hex}]`;
      colorType = "arbitrary";
    }
  }
  return {
    colorType,
    colorName,
    hex,
    meta,
  };
}
</file>

<file path="packages/types/src/types.ts">
import "@figma/plugin-typings";
export type Framework = "Flutter" | "SwiftUI" | "HTML" | "Tailwind";
export interface HTMLSettings {
  showLayerNames: boolean;
  embedImages: boolean;
  embedVectors: boolean;
  useColorVariables: boolean;
  htmlGenerationMode: "html" | "jsx" | "styled-components" | "svelte";
}
export interface TailwindSettings extends HTMLSettings {
  tailwindGenerationMode: "html" | "jsx";
  roundTailwindValues: boolean;
  roundTailwindColors: boolean;
  useColorVariables: boolean;
  customTailwindPrefix?: string;
  embedVectors: boolean;
  baseFontSize: number;
  useTailwind4: boolean;
}
export interface FlutterSettings {
  flutterGenerationMode: string;
}
export interface SwiftUISettings {
  swiftUIGenerationMode: string;
}
export interface PluginSettings
  extends HTMLSettings,
    TailwindSettings,
    FlutterSettings,
    SwiftUISettings {
  framework: Framework;
  useOldPluginVersion2025: boolean;
  responsiveRoot: boolean;
}
export interface ConversionData {
  code: string;
  settings: PluginSettings;
  htmlPreview: HTMLPreview;
  colors: SolidColorConversion[];
  gradients: LinearGradientConversion[];
  warnings: Warning[];
}
export type Warning = string;
export type Warnings = Set<Warning>;
export interface Message {
  type: string;
}
export interface UIMessage {
  pluginMessage: Message;
}
export type EmptyMessage = Message & { type: "empty" };
export type ConversionStartMessage = Message & { type: "conversionStarted" };
export type ConversionMessage = Message & {
  type: "code";
} & ConversionData;
export type SettingWillChangeMessage<T> = Message & {
  type: "pluginSettingWillChange";
  key: string;
  value: T;
};
export type SettingsChangedMessage = Message & {
  type: "pluginSettingsChanged";
  settings: PluginSettings;
};
export type ErrorMessage = Message & {
  type: "error";
  error: string;
};
export type ParentNode = BaseNode & ChildrenMixin;
export type AltNodeMetadata<T extends BaseNode> = {
  originalNode: T;
  canBeFlattened: boolean;
  svg?: string;
  base64?: string;
};
export type AltNode<T extends BaseNode> = T & AltNodeMetadata<T>;
export type ExportableNode = SceneNode & ExportMixin & MinimalFillsMixin;
export type LayoutMode =
  | ""
  | "Absolute"
  | "TopStart"
  | "TopCenter"
  | "TopEnd"
  | "CenterStart"
  | "Center"
  | "CenterEnd"
  | "BottomStart"
  | "BottomCenter"
  | "BottomEnd";
export interface BoundingRect {
  x: number;
  y: number;
}
interface AllSides {
  all: number;
}
interface Sides {
  left: number;
  right: number;
  top: number;
  bottom: number;
}
interface Corners {
  topLeft: number;
  topRight: number;
  bottomRight: number;
  bottomLeft: number;
}
interface HorizontalAndVertical {
  horizontal: number;
  vertical: number;
}
export type PaddingType = Sides | AllSides | HorizontalAndVertical;
export type BorderSide = AllSides | Sides;
export type CornerRadius = AllSides | Corners;
export type SizeValue = number | "fill" | null;
export interface Size {
  readonly width: SizeValue;
  readonly height: SizeValue;
}
export type StyledTextSegmentSubset = Omit<
  StyledTextSegment,
  "listSpacing" | "paragraphIndent" | "paragraphSpacing" | "textStyleOverrides"
>;
export type FontWeightNumber =
  | "100"
  | "200"
  | "300"
  | "400"
  | "500"
  | "600"
  | "700"
  | "800"
  | "900";
export interface RGB {
  r: number;
  g: number;
  b: number;
}
export type ColorSpec = {
  source: string;
  rgb: RGB;
};
export type SolidColorConversion = {
  hex: string;
  colorName: string;
  exportValue: string;
  contrastWhite: number;
  contrastBlack: number;
  meta?: string;
};
export type LinearGradientConversion = {
  cssPreview: string;
  exportValue: string;
};
export interface HTMLPreview {
  size: { width: number; height: number };
  content: string;
}
export interface TailwindTextConversion {
  name: string;
  attr: string;
  full: string;
  style: string;
  contrastBlack: number;
}
export type TailwindColorType = "text" | "bg" | "border" | "outline";
export type SwiftUIModifier = [
  string,
  string | SwiftUIModifier | SwiftUIModifier[],
];
export interface PreferenceOptions {
  itemType: string;
  label: string;
  propertyName: string;
  includedLanguages?: Framework[];
}
export interface SelectPreferenceOptions extends PreferenceOptions {
  itemType: "select";
  propertyName: Exclude<keyof PluginSettings, "framework">;
  options: { label: string; value: string; isDefault?: boolean }[];
}
export interface LocalCodegenPreferenceOptions extends PreferenceOptions {
  itemType: "individual_select";
  propertyName: Exclude<
    keyof PluginSettings,
    "framework" | "flutterGenerationMode" | "swiftUIGenerationMode"
  >;
  description: string;
  value?: boolean;
  isDefault?: boolean;
}
</file>

<file path="packages/backend/src/tailwind/builderImpl/tailwindColor.ts">
import { gradientAngle } from "../../common/color";
import {
  getColorInfo,
  nearestOpacity,
  nearestValue,
} from "../conversionTables";
import { TailwindColorType } from "types";
import { retrieveTopFill } from "../../common/retrieveFill";
import {
  htmlAngularGradient,
  htmlRadialGradient,
} from "../../html/builderImpl/htmlColor";
import { GradientPaint, Paint } from "../../api_types";
import { localTailwindSettings } from "../tailwindMain";
export function tailwindColor(fill: SolidPaint, useVarSyntax: boolean = false) {
  const { hex, colorType, colorName, meta } = getColorInfo(fill);
  const exportValue = tailwindSolidColor(fill, "bg", useVarSyntax);
  return {
    exportValue,
    colorName,
    colorType,
    hex,
    meta,
  };
}
function calculateEffectiveOpacity(
  fill: SolidPaint | ColorStop,
  parentOpacity?: number,
): number {
  let effectiveOpacity =
    typeof parentOpacity === "number" ? parentOpacity : 1.0;
  if ("opacity" in fill && typeof fill.opacity === "number") {
    effectiveOpacity *= fill.opacity;
  }
  if ("color" in fill && "a" in fill.color) {
    effectiveOpacity *= fill.color.a;
  }
  return effectiveOpacity;
}
export const tailwindSolidColor = (
  fill: SolidPaint | ColorStop,
  kind: TailwindColorType,
  useVarSyntax: boolean = false,
): string => {
  if (useVarSyntax && (fill as any).variableColorName) {
    const varName = (fill as any).variableColorName;
    const { hex } = getColorInfo(fill);
    return `${kind}-[var(--${varName},${hex})]`;
  }
  const { colorName } = getColorInfo(fill);
  const effectiveOpacity = calculateEffectiveOpacity(fill);
  const opacity =
    effectiveOpacity !== 1.0 ? `/${nearestOpacity(effectiveOpacity)}` : "";
  return `${kind}-${colorName}${opacity}`;
};
/**
 * Get the color name for a gradient stop, including opacity if needed
 *
 * @param stop The gradient color stop
 * @param parentOpacity The opacity of the parent gradient
 * @param useVarSyntax Whether to use CSS variable syntax for variables
 * @returns Color name with optional opacity suffix
 */
export const tailwindGradientStop = (
  stop: ColorStop,
  parentOpacity: number = 1.0,
): string => {
  const { colorName } = getColorInfo(stop);
  const effectiveOpacity = calculateEffectiveOpacity(stop, parentOpacity);
  const opacity =
    effectiveOpacity !== 1.0 ? `/${nearestOpacity(effectiveOpacity)}` : "";
  return `${colorName}${opacity}`;
};
// retrieve the SOLID color for tailwind
export const tailwindColorFromFills = (
  fills: ReadonlyArray<Paint>,
  kind: TailwindColorType,
): string => {
  // [when testing] fills can be undefined
  const fill = retrieveTopFill(fills);
  if (fill && fill.type === "SOLID") {
    return tailwindSolidColor(fill, kind);
  } else if (
    fill &&
    (fill.type === "GRADIENT_LINEAR" ||
      fill.type === "GRADIENT_ANGULAR" ||
      fill.type === "GRADIENT_RADIAL" ||
      fill.type === "GRADIENT_DIAMOND")
  ) {
    if (fill.gradientStops.length > 0) {
      return tailwindSolidColor(fill.gradientStops[0], kind);
    }
  }
  return "";
};
export const tailwindGradientFromFills = (
  fills: ReadonlyArray<Paint>,
): string => {
  const fill = retrieveTopFill(fills);
  // Return early if no fill exists
  if (!fill) {
    return "";
  }
  if (fill.type === "GRADIENT_LINEAR") {
    return tailwindGradient(fill);
  }
  if (localTailwindSettings.useTailwind4) {
    if (fill.type === "GRADIENT_RADIAL") {
      return tailwindRadialGradient(fill);
    }
    if (fill.type === "GRADIENT_ANGULAR") {
      return tailwindConicGradient(fill);
    }
    if (fill.type === "GRADIENT_DIAMOND") {
      return "";
    }
  } else {
    // Use arbitrary values with HTML-based gradient syntax for other gradient types
    if (fill.type === "GRADIENT_ANGULAR") {
      return tailwindArbitraryGradient(htmlAngularGradient(fill));
    }
    if (fill.type === "GRADIENT_RADIAL") {
      return tailwindArbitraryGradient(htmlRadialGradient(fill));
    }
    if (fill.type === "GRADIENT_DIAMOND") {
      return "";
    }
  }
  return "";
};
/**
 * Converts CSS gradient syntax to Tailwind arbitrary value syntax
 * @param cssGradient The CSS gradient string (e.g., "radial-gradient(...)")
 * @returns Tailwind class with arbitrary value (e.g., "bg-[radial-gradient(...)]")
 */
const tailwindArbitraryGradient = (cssGradient: string): string => {
  // Replace spaces with underscores for Tailwind compatibility
  const tailwindValue = cssGradient.replace(/\s+/g, "_");
  return `bg-[${tailwindValue}]`;
};
const directionMap: Record<number, string> = {
  0: "bg-gradient-to-r",
  45: "bg-gradient-to-br",
  90: "bg-gradient-to-b",
  135: "bg-gradient-to-bl",
  "-45": "bg-gradient-to-tr",
  "-90": "bg-gradient-to-t",
  "-135": "bg-gradient-to-tl",
  180: "bg-gradient-to-l",
};
function getGradientDirectionClass(
  angle: number,
  useTailwind4: boolean,
): string {
  const angleValues = [0, 45, 90, 135, 180, -45, -90, -135, -180];
  if (useTailwind4) {
    const roundedAngle = Math.round(angle);
    if (angleValues.includes(roundedAngle)) {
      return directionMap[roundedAngle];
    }
    const exactAngle = Math.round(((angle % 360) + 360) % 360);
    return `bg-linear-${exactAngle}`;
  }
  let snappedAngle = nearestValue(angle, angleValues);
  if (snappedAngle === -180) snappedAngle = 180;
  const entry = directionMap[snappedAngle];
  if (entry) {
    return entry;
  }
  return "bg-gradient-to-r";
}
const needsPositionOverride = (actual: number, expected: number): boolean => {
  return Math.abs(actual - expected) > 0.05;
};
const getStopPositionModifier = (
  stopPosition: number,
  expectedPosition: number,
  unit: string = "%",
  multiplier: number = 100,
): string => {
  if (needsPositionOverride(stopPosition, expectedPosition)) {
    const position = Math.round(stopPosition * multiplier);
    return ` ${position}${unit}`;
  }
  return "";
};
/**
 * Generates a complete gradient stop with position if needed
 * @param prefix The stop prefix (from-, via-, to-)
 * @param stop The gradient stop
 * @param globalOpacity The global opacity
 * @param expectedPosition The expected default position (0-1)
 * @param unit The unit to use (%, deg)
 * @param multiplier Multiplier for the position value
 * @returns Complete gradient stop string
 */
function generateGradientStop(
  prefix: string,
  stop: ColorStop,
  globalOpacity: number = 1.0,
  expectedPosition: number,
  unit: string = "%",
  multiplier: number = 100,
): string {
  const colorValue = tailwindGradientStop(stop, globalOpacity);
  const colorPart = `${prefix}-${colorValue}`;
  if (!localTailwindSettings.useTailwind4) {
    return colorPart;
  }
  // Only add position if it significantly differs from the default
  const positionModifier = getStopPositionModifier(
    stop.position,
    expectedPosition,
    unit,
    multiplier,
  );
  return positionModifier
    ? `${colorPart} ${prefix}${positionModifier}`
    : colorPart;
}
export const tailwindGradient = (fill: GradientPaint): string => {
  const globalOpacity = fill.opacity ?? 1.0;
  const direction = getGradientDirectionClass(
    gradientAngle(fill),
    localTailwindSettings.useTailwind4,
  );
  if (fill.gradientStops.length === 1) {
    const fromStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
    );
    return [direction, fromStop].filter(Boolean).join(" ");
  } else if (fill.gradientStops.length === 2) {
    const firstStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
    );
    const lastStop = generateGradientStop(
      "to",
      fill.gradientStops[1],
      globalOpacity,
      1,
    );
    return [direction, firstStop, lastStop].filter(Boolean).join(" ");
  } else {
    const firstStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
    );
    const viaStop = generateGradientStop(
      "via",
      fill.gradientStops[1],
      globalOpacity,
      0.5,
    );
    const lastStop = generateGradientStop(
      "to",
      fill.gradientStops[fill.gradientStops.length - 1],
      globalOpacity,
      1,
    );
    return [direction, firstStop, viaStop, lastStop].filter(Boolean).join(" ");
  }
};
const tailwindRadialGradient = (fill: GradientPaint): string => {
  const globalOpacity = fill.opacity ?? 1.0;
  const [center] = fill.gradientHandlePositions;
  const cx = Math.round(center.x * 100);
  const cy = Math.round(center.y * 100);
  const isCustomPosition = Math.abs(cx - 50) > 5 || Math.abs(cy - 50) > 5;
  const baseClass = isCustomPosition
    ? `bg-radial-[at_${cx}%_${cy}%]`
    : "bg-radial";
  if (fill.gradientStops.length === 1) {
    const fromStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
    );
    return [baseClass, fromStop].filter(Boolean).join(" ");
  } else if (fill.gradientStops.length === 2) {
    const firstStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
    );
    const lastStop = generateGradientStop(
      "to",
      fill.gradientStops[1],
      globalOpacity,
      1,
    );
    return [baseClass, firstStop, lastStop].filter(Boolean).join(" ");
  } else {
    const firstStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
    );
    const viaStop = generateGradientStop(
      "via",
      fill.gradientStops[1],
      globalOpacity,
      0.5,
    );
    const lastStop = generateGradientStop(
      "to",
      fill.gradientStops[fill.gradientStops.length - 1],
      globalOpacity,
      1,
    );
    return [baseClass, firstStop, viaStop, lastStop].filter(Boolean).join(" ");
  }
};
const tailwindConicGradient = (fill: GradientPaint): string => {
  const [center, , startDirection] = fill.gradientHandlePositions;
  const globalOpacity = fill.opacity ?? 1.0;
  const dx = startDirection.x - center.x;
  const dy = startDirection.y - center.y;
  let angle = Math.atan2(dy, dx) * (180 / Math.PI);
  angle = (angle + 360) % 360;
  const normalizedAngle = Math.round(angle);
  const cx = Math.round(center.x * 100);
  const cy = Math.round(center.y * 100);
  const isCustomPosition = Math.abs(cx - 50) > 5 || Math.abs(cy - 50) > 5;
  let baseClass = `bg-conic-${normalizedAngle}`;
  if (isCustomPosition) {
    baseClass = `bg-conic-[from_${normalizedAngle}deg_at_${cx}%_${cy}%]`;
  }
  if (fill.gradientStops.length === 1) {
    const fromStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
      "deg",
      360,
    );
    return [baseClass, fromStop].filter(Boolean).join(" ");
  } else if (fill.gradientStops.length === 2) {
    const firstStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
      "deg",
      360,
    );
    const lastStop = generateGradientStop(
      "to",
      fill.gradientStops[1],
      globalOpacity,
      1,
      "deg",
      360,
    );
    return [baseClass, firstStop, lastStop].filter(Boolean).join(" ");
  } else {
    const firstStop = generateGradientStop(
      "from",
      fill.gradientStops[0],
      globalOpacity,
      0,
      "deg",
      360,
    );
    const viaStop = generateGradientStop(
      "via",
      fill.gradientStops[1],
      globalOpacity,
      0.5,
      "deg",
      360,
    );
    const lastStop = generateGradientStop(
      "to",
      fill.gradientStops[fill.gradientStops.length - 1],
      globalOpacity,
      1,
      "deg",
      360,
    );
    return [baseClass, firstStop, viaStop, lastStop].filter(Boolean).join(" ");
  }
};
</file>

<file path="apps/plugin/plugin-src/code.ts">
import { tailwindCodeGenTextStyles } from "./../../../packages/backend/src/tailwind/tailwindMain";
import {
  run,
  flutterMain,
  tailwindMain,
  swiftuiMain,
  htmlMain,
  postSettingsChanged,
} from "backend";
import { nodesToJSON } from "backend/src/altNodes/jsonNodeConversion";
import { retrieveGenericSolidUIColors } from "backend/src/common/retrieveUI/retrieveColors";
import { flutterCodeGenTextStyles } from "backend/src/flutter/flutterMain";
import { htmlCodeGenTextStyles } from "backend/src/html/htmlMain";
import { swiftUICodeGenTextStyles } from "backend/src/swiftui/swiftuiMain";
import { PluginSettings, SettingWillChangeMessage } from "types";
let userPluginSettings: PluginSettings;
export const defaultPluginSettings: PluginSettings = {
  framework: "HTML",
  showLayerNames: false,
  useOldPluginVersion2025: false,
  responsiveRoot: false,
  flutterGenerationMode: "snippet",
  swiftUIGenerationMode: "snippet",
  roundTailwindValues: true,
  roundTailwindColors: true,
  useColorVariables: true,
  customTailwindPrefix: "",
  embedImages: false,
  embedVectors: false,
  htmlGenerationMode: "html",
  tailwindGenerationMode: "jsx",
  baseFontSize: 16,
  useTailwind4: false,
};
function isKeyOfPluginSettings(key: string): key is keyof PluginSettings {
  return key in defaultPluginSettings;
}
const getUserSettings = async () => {
  console.log("[DEBUG] getUserSettings - Starting to fetch user settings");
  const possiblePluginSrcSettings =
    (await figma.clientStorage.getAsync("userPluginSettings")) ?? {};
  console.log(
    "[DEBUG] getUserSettings - Raw settings from storage:",
    possiblePluginSrcSettings,
  );
  const updatedPluginSrcSettings = {
    ...defaultPluginSettings,
    ...Object.keys(defaultPluginSettings).reduce((validSettings, key) => {
      if (
        isKeyOfPluginSettings(key) &&
        key in possiblePluginSrcSettings &&
        typeof possiblePluginSrcSettings[key] ===
          typeof defaultPluginSettings[key]
      ) {
        validSettings[key] = possiblePluginSrcSettings[key] as any;
      }
      return validSettings;
    }, {} as Partial<PluginSettings>),
  };
  userPluginSettings = updatedPluginSrcSettings as PluginSettings;
  console.log("[DEBUG] getUserSettings - Final settings:", userPluginSettings);
  return userPluginSettings;
};
const initSettings = async () => {
  console.log("[DEBUG] initSettings - Initializing plugin settings");
  await getUserSettings();
  postSettingsChanged(userPluginSettings);
  console.log("[DEBUG] initSettings - Calling safeRun with settings");
  safeRun(userPluginSettings);
};
let isLoading = false;
const safeRun = async (settings: PluginSettings) => {
  console.log(
    "[DEBUG] safeRun - Called with isLoading =",
    isLoading,
    "selection =",
    figma.currentPage.selection,
  );
  if (isLoading === false) {
    try {
      isLoading = true;
      console.log("[DEBUG] safeRun - Starting run execution");
      await run(settings);
      console.log("[DEBUG] safeRun - Run execution completed");
      setTimeout(() => {
        console.log("[DEBUG] safeRun - Resetting isLoading to false");
        isLoading = false;
      }, 1);
    } catch (e) {
      console.log("[DEBUG] safeRun - Error caught in execution");
      isLoading = false;
      if (e && typeof e === "object" && "message" in e) {
        const error = e as Error;
        console.log("error: ", error.stack);
        figma.ui.postMessage({ type: "error", error: error.message });
      } else {
        const errorMessage = String(e);
        console.log("Unknown error: ", errorMessage);
        figma.ui.postMessage({
          type: "error",
          error: errorMessage || "Unknown error occurred",
        });
      }
      figma.ui.postMessage({ type: "conversion-complete", success: false });
    }
  } else {
    console.log(
      "[DEBUG] safeRun - Skipping execution because isLoading =",
      isLoading,
    );
  }
};
const standardMode = async () => {
  console.log("[DEBUG] standardMode - Starting standard mode initialization");
  figma.showUI(__html__, { width: 450, height: 700, themeColors: true });
  await initSettings();
  figma.on("selectionchange", () => {
    console.log(
      "[DEBUG] selectionchange event - New selection:",
      figma.currentPage.selection,
    );
    safeRun(userPluginSettings);
  });
  figma.loadAllPagesAsync();
  figma.on("documentchange", () => {
    console.log("[DEBUG] documentchange event triggered");
    safeRun(userPluginSettings);
  });
  figma.ui.onmessage = async (msg) => {
    console.log("[DEBUG] figma.ui.onmessage", msg);
    if (msg.type === "pluginSettingWillChange") {
      const { key, value } = msg as SettingWillChangeMessage<unknown>;
      console.log(`[DEBUG] Setting changed: ${key} = ${value}`);
      (userPluginSettings as any)[key] = value;
      figma.clientStorage.setAsync("userPluginSettings", userPluginSettings);
      safeRun(userPluginSettings);
    } else if (msg.type === "get-selection-json") {
      console.log("[DEBUG] get-selection-json message received");
      const nodes = figma.currentPage.selection;
      if (nodes.length === 0) {
        figma.ui.postMessage({
          type: "selection-json",
          data: { message: "No nodes selected" },
        });
        return;
      }
      const result: {
        json?: SceneNode[];
        oldConversion?: any;
        newConversion?: any;
      } = {};
      try {
        result.json = (await Promise.all(
          nodes.map(
            async (node) =>
              (
                (await node.exportAsync({
                  format: "JSON_REST_V1",
                })) as any
              ).document,
          ),
        )) as SceneNode[];
      } catch (error) {
        console.error("Error exporting JSON:", error);
      }
      try {
        const newNodes = await nodesToJSON(nodes, userPluginSettings);
        const removeParent = (node: any) => {
          if (node.parent) {
            delete node.parent;
          }
          if (node.children) {
            node.children.forEach(removeParent);
          }
        };
        newNodes.forEach(removeParent);
        result.newConversion = newNodes;
      } catch (error) {
        console.error("Error in new conversion:", error);
      }
      const nodeJson = result;
      console.log("[DEBUG] Exported node JSON:", nodeJson);
      figma.ui.postMessage({
        type: "selection-json",
        data: nodeJson,
      });
    }
  };
};
const codegenMode = async () => {
  console.log("[DEBUG] codegenMode - Starting codegen mode initialization");
  await getUserSettings();
  figma.codegen.on(
    "generate",
    async ({ language, node }: CodegenEvent): Promise<CodegenResult[]> => {
      console.log(
        `[DEBUG] codegen.generate - Language: ${language}, Node:`,
        node,
      );
      const convertedSelection = await nodesToJSON([node], userPluginSettings);
      console.log(
        "[DEBUG] codegen.generate - Converted selection:",
        convertedSelection,
      );
      switch (language) {
        case "html":
          return [
            {
              title: "Code",
              code: (
                await htmlMain(
                  convertedSelection,
                  { ...userPluginSettings, htmlGenerationMode: "html" },
                  true,
                )
              ).html,
              language: "HTML",
            },
            {
              title: "Text Styles",
              code: htmlCodeGenTextStyles(userPluginSettings),
              language: "HTML",
            },
          ];
        case "html_jsx":
          return [
            {
              title: "Code",
              code: (
                await htmlMain(
                  convertedSelection,
                  { ...userPluginSettings, htmlGenerationMode: "jsx" },
                  true,
                )
              ).html,
              language: "HTML",
            },
            {
              title: "Text Styles",
              code: htmlCodeGenTextStyles(userPluginSettings),
              language: "HTML",
            },
          ];
        case "html_svelte":
          return [
            {
              title: "Code",
              code: (
                await htmlMain(
                  convertedSelection,
                  { ...userPluginSettings, htmlGenerationMode: "svelte" },
                  true,
                )
              ).html,
              language: "HTML",
            },
            {
              title: "Text Styles",
              code: htmlCodeGenTextStyles(userPluginSettings),
              language: "HTML",
            },
          ];
        case "html_styled_components":
          return [
            {
              title: "Code",
              code: (
                await htmlMain(
                  convertedSelection,
                  {
                    ...userPluginSettings,
                    htmlGenerationMode: "styled-components",
                  },
                  true,
                )
              ).html,
              language: "HTML",
            },
            {
              title: "Text Styles",
              code: htmlCodeGenTextStyles(userPluginSettings),
              language: "HTML",
            },
          ];
        case "tailwind":
        case "tailwind_jsx":
          return [
            {
              title: "Code",
              code: await tailwindMain(convertedSelection, {
                ...userPluginSettings,
                tailwindGenerationMode:
                  language === "tailwind_jsx" ? "jsx" : "html",
              }),
              language: "HTML",
            },
            {
              title: "Tailwind Colors",
              code: (await retrieveGenericSolidUIColors("Tailwind"))
                .map((d) => {
                  let str = `${d.hex};`;
                  if (d.colorName !== d.hex) {
                    str += ` // ${d.colorName}`;
                  }
                  if (d.meta) {
                    str += ` (${d.meta})`;
                  }
                  return str;
                })
                .join("\n"),
              language: "JAVASCRIPT",
            },
            {
              title: "Text Styles",
              code: tailwindCodeGenTextStyles(),
              language: "HTML",
            },
          ];
        case "flutter":
          return [
            {
              title: "Code",
              code: flutterMain(convertedSelection, {
                ...userPluginSettings,
                flutterGenerationMode: "snippet",
              }),
              language: "SWIFT",
            },
            {
              title: "Text Styles",
              code: flutterCodeGenTextStyles(),
              language: "SWIFT",
            },
          ];
        case "swiftUI":
          return [
            {
              title: "SwiftUI",
              code: swiftuiMain(convertedSelection, {
                ...userPluginSettings,
                swiftUIGenerationMode: "snippet",
              }),
              language: "SWIFT",
            },
            {
              title: "Text Styles",
              code: swiftUICodeGenTextStyles(),
              language: "SWIFT",
            },
          ];
        default:
          break;
      }
      const blocks: CodegenResult[] = [];
      return blocks;
    },
  );
};
switch (figma.mode) {
  case "default":
  case "inspect":
    console.log("[DEBUG] Starting plugin in", figma.mode, "mode");
    standardMode();
    break;
  case "codegen":
    console.log("[DEBUG] Starting plugin in codegen mode");
    codegenMode();
    break;
  default:
    console.log("[DEBUG] Unknown plugin mode:", figma.mode);
    break;
}
</file>

<file path="packages/backend/src/html/htmlMain.ts">
import { indentString } from "../common/indentString";
import { HtmlTextBuilder } from "./htmlTextBuilder";
import { HtmlDefaultBuilder } from "./htmlDefaultBuilder";
import { htmlAutoLayoutProps } from "./builderImpl/htmlAutoLayout";
import { formatWithJSX } from "../common/parseJSX";
import {
  PluginSettings,
  HTMLPreview,
  AltNode,
  HTMLSettings,
  ExportableNode,
} from "types";
import { renderAndAttachSVG } from "../altNodes/altNodeUtils";
import { getVisibleNodes } from "../common/nodeVisibility";
import {
  exportNodeAsBase64PNG,
  getPlaceholderImage,
  nodeHasImageFill,
} from "../common/images";
import { addWarning } from "../common/commonConversionWarnings";
const selfClosingTags = ["img"];
export let isPreviewGlobal = false;
let previousExecutionCache: { style: string; text: string }[];
export interface HtmlOutput {
  html: string;
  css?: string;
}
export type HtmlGenerationMode =
  | "html"
  | "jsx"
  | "styled-components"
  | "svelte";
interface CSSCollection {
  [className: string]: {
    styles: string[];
    nodeName?: string;
    nodeType?: string;
    element?: string;
  };
}
export let cssCollection: CSSCollection = {};
const classNameCounters: Map<string, number> = new Map();
export function generateUniqueClassName(prefix = "figma"): string {
  const sanitizedPrefix =
    prefix.replace(/[^a-zA-Z0-9_-]/g, "").replace(/^[0-9_-]/, "f") ||
    "figma";
  const count = classNameCounters.get(sanitizedPrefix) || 0;
  classNameCounters.set(sanitizedPrefix, count + 1);
  return count === 0
    ? sanitizedPrefix
    : `${sanitizedPrefix}_${count.toString().padStart(2, "0")}`;
}
export function resetClassNameCounters(): void {
  classNameCounters.clear();
}
export function stylesToCSS(styles: string[], isJSX: boolean): string[] {
  return styles
    .map((style) => {
      if (!style.trim()) return "";
      // Handle JSX format if needed
      if (isJSX) {
        return style.replace(/^([a-zA-Z0-9]+):/, (match, prop) => {
          // Convert camelCase to kebab-case for CSS
          return (
            prop
              .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2")
              .toLowerCase() + ":"
          );
        });
      }
      return style;
    })
    .filter(Boolean);
}
export function getComponentName(
  node: any,
  className?: string,
  nodeType = "div",
): string {
  let name = "Styled";
  const nodeName: string = node.uniqueName || node.name;
  if (nodeName && nodeName.length > 0) {
    const cleanName = nodeName
      .replace(/[^a-zA-Z0-9]/g, "")
      .replace(/^[a-z]/, (match) => match.toUpperCase());
    name += cleanName || nodeType.charAt(0).toUpperCase() + nodeType.slice(1);
  }
  // Fall back to className if provided
  else if (className) {
    const parts = className.split("-");
    if (parts.length > 0 && parts[0]) {
      name += parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
    } else {
      name += nodeType.charAt(0).toUpperCase() + nodeType.slice(1);
    }
  }
  // Last resort
  else {
    name += nodeType.charAt(0).toUpperCase() + nodeType.slice(1);
  }
  return name;
}
// Get the collected CSS as a string with improved formatting
export function getCollectedCSS(): string {
  if (Object.keys(cssCollection).length === 0) {
    return "";
  }
  return Object.entries(cssCollection)
    .map(([className, { styles }]) => {
      if (!styles.length) return "";
      return `.${className} {\n  ${styles.join(";\n  ")}${styles.length ? ";" : ""}\n}`;
    })
    .filter(Boolean)
    .join("\n\n");
}
export function generateStyledComponents(): string {
  const components: string[] = [];
  Object.entries(cssCollection).forEach(
    ([className, { styles, nodeName, nodeType, element }]) => {
      if (!styles.length) return;
      const baseElement = element || (nodeType === "TEXT" ? "p" : "div");
      const componentName = getComponentName(
        { name: nodeName },
        className,
        baseElement,
      );
      const styledComponent = `const ${componentName} = styled.${baseElement}\`
  ${styles.join(";\n  ")}${styles.length ? ";" : ""}
\`;`;
      components.push(styledComponent);
    },
  );
  if (components.length === 0) {
    return "";
  }
  return `${components.join("\n\n")}`;
}
// Get a valid React component name from a layer name
export function getReactComponentName(node: any): string {
  // Use uniqueName if available, otherwise use name
  const name: string = node?.uniqueName || node?.name;
  // Default name if nothing valid is provided
  if (!name || name.trim() === "") {
    return "App";
  }
  // Convert to PascalCase
  let componentName = name
    .replace(/[^a-zA-Z0-9_]/g, " ") // Replace non-alphanumeric chars with spaces
    .split(/\s+/) // Split by spaces
    .map((part) =>
      part ? part.charAt(0).toUpperCase() + part.slice(1).toLowerCase() : "",
    )
    .join("");
  // Ensure it starts with uppercase letter (React component convention)
  componentName =
    componentName.charAt(0).toUpperCase() + componentName.slice(1);
  // Ensure it's a valid identifier - if it starts with a number, prefix with 'Component'
  if (/^[0-9]/.test(componentName)) {
    componentName = "Component" + componentName;
  }
  // If we ended up with nothing valid, use the default
  return componentName || "App";
}
// Get a Svelte-friendly component name
export function getSvelteElementName(
  elementType: string,
  nodeName?: string,
): string {
  // For Svelte, use semantic element names where possible
  if (elementType === "TEXT" || elementType === "p") {
    return "p";
  } else if (elementType === "img" || elementType === "IMAGE") {
    return "img";
  } else if (
    nodeName &&
    (nodeName.toLowerCase().includes("button") ||
      nodeName.toLowerCase().includes("btn"))
  ) {
    return "button";
  } else if (nodeName && nodeName.toLowerCase().includes("link")) {
    return "a";
  } else {
    return "div"; // Default element
  }
}
// Generate semantic class names for Svelte
export function getSvelteClassName(prefix?: string, nodeType?: string): string {
  if (!prefix) {
    return nodeType?.toLowerCase() || "element";
  }
  // Clean and format the prefix
  return prefix
    .replace(/[^a-zA-Z0-9_-]/g, "-")
    .replace(/-{2,}/g, "-") // Replace multiple hyphens with a single one
    .replace(/^-+|-+$/g, "") // Remove leading/trailing hyphens
    .toLowerCase();
}
// Generate component code based on the specified mode
function generateComponentCode(
  html: string,
  sceneNode: Array<SceneNode>,
  mode: HtmlGenerationMode,
): string {
  switch (mode) {
    case "styled-components":
      return generateReactComponent(html, sceneNode);
    case "svelte":
      return generateSvelteComponent(html);
    case "html":
    case "jsx":
    default:
      return html;
  }
}
// Generate React component from HTML, with optional styled-components
function generateReactComponent(
  html: string,
  sceneNode: Array<SceneNode>,
): string {
  const styledComponentsCode = generateStyledComponents();
  const componentName = getReactComponentName(sceneNode[0]);
  const imports = [
    'import React from "react";',
    'import styled from "styled-components";',
  ];
  return `${imports.join("\n")}
${styledComponentsCode ? `\n${styledComponentsCode}` : ""}
export const ${componentName} = () => {
  return (
${indentString(html, 4)}
  );
};`;
}
// Generate Svelte component from the collected styles and HTML
function generateSvelteComponent(html: string): string {
  // Build CSS classes similar to styled-components but for Svelte
  const cssRules: string[] = [];
  Object.entries(cssCollection).forEach(([className, { styles }]) => {
    if (!styles.length) return;
    // Always use class selector to avoid conflicts
    cssRules.push(
      `.${className} {\n  ${styles.join(";\n  ")}${styles.length ? ";" : ""}\n}`,
    );
  });
  return `${html}
<style>
${cssRules.join("\n\n")}
</style>`;
}
export const htmlMain = async (
  sceneNode: Array<SceneNode>,
  settings: PluginSettings,
  isPreview: boolean = false,
): Promise<HtmlOutput> => {
  isPreviewGlobal = isPreview;
  previousExecutionCache = [];
  cssCollection = {};
  resetClassNameCounters(); // Reset counters for each new generation
  let htmlContent = await htmlWidgetGenerator(sceneNode, settings);
  // remove the initial \n that is made in Container.
  if (htmlContent.length > 0 && htmlContent.startsWith("\n")) {
    htmlContent = htmlContent.slice(1, htmlContent.length);
  }
  // Always return an object with html property
  const output: HtmlOutput = { html: htmlContent };
  // Handle different HTML generation modes
  const mode = settings.htmlGenerationMode || "html";
  if (mode !== "html") {
    // Generate component code for non-html modes
    output.html = generateComponentCode(htmlContent, sceneNode, mode);
    // For svelte mode, we don't need separate CSS as it's included in the component
    if (mode === "svelte" && Object.keys(cssCollection).length > 0) {
      // CSS is already included in the Svelte component
    }
  } else if (Object.keys(cssCollection).length > 0) {
    // For plain HTML with CSS, include CSS separately
    output.css = getCollectedCSS();
  }
  return output;
};
export const generateHTMLPreview = async (
  nodes: SceneNode[],
  settings: PluginSettings,
): Promise<HTMLPreview> => {
  let result = await htmlMain(
    nodes,
    {
      ...settings,
      htmlGenerationMode: "html",
    },
    nodes.length > 1 ? false : true,
  );
  if (nodes.length > 1) {
    result.html = `<div style="width: 100%; height: 100%">${result.html}</div>`;
  }
  return {
    size: {
      width: Math.max(...nodes.map((node) => node.width)),
      height: nodes.reduce((sum, node) => sum + node.height, 0),
    },
    content: result.html,
  };
};
const htmlWidgetGenerator = async (
  sceneNode: ReadonlyArray<SceneNode>,
  settings: HTMLSettings,
): Promise<string> => {
  // filter non visible nodes. This is necessary at this step because conversion already happened.
  const promiseOfConvertedCode = getVisibleNodes(sceneNode).map(
    convertNode(settings),
  );
  const code = (await Promise.all(promiseOfConvertedCode)).join("");
  return code;
};
const convertNode = (settings: HTMLSettings) => async (node: SceneNode) => {
  if (settings.embedVectors && (node as any).canBeFlattened) {
    const altNode = await renderAndAttachSVG(node);
    if (altNode.svg) {
      return htmlWrapSVG(altNode, settings);
    }
  }
  switch (node.type) {
    case "RECTANGLE":
    case "ELLIPSE":
      return await htmlContainer(node, "", [], settings);
    case "GROUP":
      return await htmlGroup(node, settings);
    case "FRAME":
    case "COMPONENT":
    case "INSTANCE":
    case "COMPONENT_SET":
      return await htmlFrame(node, settings);
    case "SECTION":
      return await htmlSection(node, settings);
    case "TEXT":
      return htmlText(node, settings);
    case "LINE":
      return htmlLine(node, settings);
    case "VECTOR":
      if (!settings.embedVectors && !isPreviewGlobal) {
        addWarning("Vector is not supported");
      }
      return await htmlContainer(
        { ...node, type: "RECTANGLE" } as any,
        "",
        [],
        settings,
      );
    default:
      addWarning(`${node.type} node is not supported`);
      return "";
  }
};
const htmlWrapSVG = (
  node: AltNode<SceneNode>,
  settings: HTMLSettings,
): string => {
  if (node.svg === "") return "";
  const builder = new HtmlDefaultBuilder(node, settings)
    .addData("svg-wrapper")
    .position();
  return `\n<div${builder.build()}>\n${node.svg ?? ""}</div>`;
};
const htmlGroup = async (
  node: GroupNode,
  settings: HTMLSettings,
): Promise<string> => {
  if (node.width < 0 || node.height <= 0 || node.children.length === 0) {
    return "";
  }
  // this needs to be called after CustomNode because widthHeight depends on it
  const builder = new HtmlDefaultBuilder(node, settings).commonPositionStyles();
  if (builder.styles) {
    const attr = builder.build();
    const generator = await htmlWidgetGenerator(node.children, settings);
    return `\n<div${attr}>${indentString(generator)}\n</div>`;
  }
  return await htmlWidgetGenerator(node.children, settings);
};
// For htmlText and htmlContainer, use the htmlGenerationMode to determine styling approach
const htmlText = (node: TextNode, settings: HTMLSettings): string => {
  let layoutBuilder = new HtmlTextBuilder(node, settings)
    .commonPositionStyles()
    .textTrim()
    .textAlignHorizontal()
    .textAlignVertical();
  const styledHtml = layoutBuilder.getTextSegments(node);
  previousExecutionCache.push(...styledHtml);
  const mode = settings.htmlGenerationMode || "html";
  if (mode === "styled-components") {
    const componentName = layoutBuilder.cssClassName
      ? getComponentName(node, layoutBuilder.cssClassName, "p")
      : getComponentName(node, undefined, "p");
    if (styledHtml.length === 1) {
      return `\n<${componentName}>${styledHtml[0].text}</${componentName}>`;
    } else {
      const content = styledHtml
        .map((style) => {
          const tag =
            style.openTypeFeatures.SUBS === true
              ? "sub"
              : style.openTypeFeatures.SUPS === true
                ? "sup"
                : "span";
          if (style.componentName) {
            return `<${style.componentName}>${style.text}</${style.componentName}>`;
          }
          return `<${tag}>${style.text}</${tag}>`;
        })
        .join("");
      return `\n<${componentName}>${content}</${componentName}>`;
    }
  }
  // Standard HTML/CSS approach for HTML, React or Svelte
  let content = "";
  if (styledHtml.length === 1) {
    // For HTML and React modes, we use inline styles
    if (mode === "html" || mode === "jsx") {
      layoutBuilder.addStyles(styledHtml[0].style);
    }
    content = styledHtml[0].text;
    const additionalTag =
      styledHtml[0].openTypeFeatures.SUBS === true
        ? "sub"
        : styledHtml[0].openTypeFeatures.SUPS === true
          ? "sup"
          : "";
    if (additionalTag) {
      content = `<${additionalTag}>${content}</${additionalTag}>`;
    } else if (mode === "svelte" && styledHtml[0].className) {
      content = `<span class="${styledHtml[0].className}">${content}</span>`;
    }
  } else {
    content = styledHtml
      .map((style) => {
        const tag =
          style.openTypeFeatures.SUBS === true
            ? "sub"
            : style.openTypeFeatures.SUPS === true
              ? "sup"
              : "span";
        if (mode === "svelte" && style.className) {
          return `<span class="${style.className}">${style.text}</span>`;
        }
        return `<${tag} style="${style.style}">${style.text}</${tag}>`;
      })
      .join("");
  }
  // Always use div as container to be consistent with styled-components
  return `\n<div${layoutBuilder.build()}>${content}</div>`;
};
const htmlFrame = async (
  node: SceneNode & BaseFrameMixin,
  settings: HTMLSettings,
): Promise<string> => {
  const childrenStr = await htmlWidgetGenerator(node.children, settings);
  if (node.layoutMode !== "NONE") {
    const rowColumn = htmlAutoLayoutProps(node, settings);
    return await htmlContainer(node, childrenStr, rowColumn, settings);
  }
  return await htmlContainer(node, childrenStr, [], settings);
};
const htmlContainer = async (
  node: SceneNode &
    SceneNodeMixin &
    BlendMixin &
    LayoutMixin &
    GeometryMixin &
    MinimalBlendMixin,
  children: string,
  additionalStyles: string[] = [],
  settings: HTMLSettings,
): Promise<string> => {
  if (node.width <= 0 || node.height <= 0) {
    return children;
  }
  const builder = new HtmlDefaultBuilder(node, settings)
    .commonPositionStyles()
    .commonShapeStyles();
  if (builder.styles || additionalStyles) {
    let tag = "div";
    let src = "";
    if (nodeHasImageFill(node)) {
      const altNode = node as AltNode<ExportableNode>;
      const hasChildren = "children" in node && node.children.length > 0;
      let imgUrl = "";
      if (
        settings.embedImages &&
        (settings as PluginSettings).framework === "HTML"
      ) {
        imgUrl = (await exportNodeAsBase64PNG(altNode, hasChildren)) ?? "";
      } else {
        imgUrl = getPlaceholderImage(node.width, node.height);
      }
      if (hasChildren) {
        builder.addStyles(
          formatWithJSX(
            "background-image",
            settings.htmlGenerationMode === "jsx",
            `url(${imgUrl})`,
          ),
        );
      } else {
        tag = "img";
        src = ` src="${imgUrl}"`;
      }
    }
    const build = builder.build(additionalStyles);
    const mode = settings.htmlGenerationMode || "html";
    if (mode === "styled-components" && builder.cssClassName) {
      const componentName = getComponentName(node, builder.cssClassName);
      if (children) {
        return `\n<${componentName}>${indentString(children)}\n</${componentName}>`;
      } else {
        return `\n<${componentName} ${src}/>`;
      }
    }
    if (children) {
      return `\n<${tag}${build}${src}>${indentString(children)}\n</${tag}>`;
    } else if (
      selfClosingTags.includes(tag) ||
      settings.htmlGenerationMode === "jsx"
    ) {
      return `\n<${tag}${build}${src} />`;
    } else {
      return `\n<${tag}${build}${src}></${tag}>`;
    }
  }
  return children;
};
const htmlSection = async (
  node: SectionNode,
  settings: HTMLSettings,
): Promise<string> => {
  const childrenStr = await htmlWidgetGenerator(node.children, settings);
  const builder = new HtmlDefaultBuilder(node, settings)
    .size()
    .position()
    .applyFillsToStyle(node.fills, "background");
  if (childrenStr) {
    return `\n<div${builder.build()}>${indentString(childrenStr)}\n</div>`;
  } else {
    return `\n<div${builder.build()}></div>`;
  }
};
const htmlLine = (node: LineNode, settings: HTMLSettings): string => {
  const builder = new HtmlDefaultBuilder(node, settings)
    .commonPositionStyles()
    .commonShapeStyles();
  return `\n<div${builder.build()}></div>`;
};
export const htmlCodeGenTextStyles = (settings: HTMLSettings) => {
  const result = previousExecutionCache
    .map(
      (style) =>
        `// ${style.text}\n${style.style.split(settings.htmlGenerationMode === "jsx" ? "," : ";").join(";\n")}`,
    )
    .join("\n---\n");
  if (!result) {
    return "// No text styles in this selection";
  }
  return result;
};
</file>

<file path="packages/backend/src/tailwind/tailwindDefaultBuilder.ts">
import {
  stringToClassName,
  numberToFixedString,
} from "./../common/numToAutoFixed";
import { tailwindShadow } from "./builderImpl/tailwindShadow";
import {
  tailwindVisibility,
  tailwindRotation,
  tailwindOpacity,
  tailwindBlendMode,
  tailwindBackgroundBlendMode,
} from "./builderImpl/tailwindBlend";
import {
  tailwindBorderWidth,
  tailwindBorderRadius,
} from "./builderImpl/tailwindBorder";
import {
  tailwindColorFromFills,
  tailwindGradientFromFills,
} from "./builderImpl/tailwindColor";
import { tailwindSizePartial } from "./builderImpl/tailwindSize";
import { tailwindPadding } from "./builderImpl/tailwindPadding";
import {
  commonIsAbsolutePosition,
  getCommonPositionValue,
} from "../common/commonPosition";
import { pxToBlur } from "./conversionTables";
import {
  formatDataAttribute,
  getClassLabel,
} from "../common/commonFormatAttributes";
import { TailwindColorType, TailwindSettings } from "types";
import { MinimalFillsTrait, Paint } from "../api_types";
const isNotEmpty = (s: string) => s !== "" && s !== null && s !== undefined;
const dropEmptyStrings = (strings: string[]) => strings.filter(isNotEmpty);
export class TailwindDefaultBuilder {
  attributes: string[] = [];
  style: string;
  data: string[];
  styleSeparator: string = "";
  node: SceneNode;
  settings: TailwindSettings;
  get name() {
    return this.settings.showLayerNames ? this.node.name : "";
  }
  get visible() {
    return this.node.visible ?? true;
  }
  get isJSX() {
    return this.settings.tailwindGenerationMode === "jsx";
  }
  constructor(node: SceneNode, settings: TailwindSettings) {
    this.node = node;
    this.settings = settings;
    this.styleSeparator = this.isJSX ? "," : ";";
    this.style = "";
    this.data = [];
  }
  addAttributes = (...newStyles: string[]) => {
    // Filter out empty strings and trim any extra spaces
    const cleanedStyles = dropEmptyStrings(newStyles).map((s) => s.trim());
    this.attributes.push(...cleanedStyles);
  };
  prependAttributes = (...newStyles: string[]) => {
    // Filter out empty strings and trim any extra spaces
    const cleanedStyles = dropEmptyStrings(newStyles).map((s) => s.trim());
    this.attributes.unshift(...cleanedStyles);
  };
  blend(): this {
    this.addAttributes(
      tailwindVisibility(this.node),
      tailwindRotation(this.node as LayoutMixin),
      tailwindOpacity(this.node as MinimalBlendMixin),
      tailwindBlendMode(this.node as MinimalBlendMixin),
    );
    return this;
  }
  commonPositionStyles(): this {
    this.size();
    this.autoLayoutPadding();
    this.position();
    this.blend();
    return this;
  }
  commonShapeStyles(): this {
    this.customColor((this.node as MinimalFillsTrait).fills, "bg");
    this.radius();
    this.shadow();
    this.border();
    this.blur();
    return this;
  }
  radius(): this {
    if (this.node.type === "ELLIPSE") {
      this.addAttributes("rounded-full");
    } else {
      this.addAttributes(tailwindBorderRadius(this.node));
    }
    return this;
  }
  border(): this {
    if ("strokes" in this.node) {
      const { isOutline, property } = tailwindBorderWidth(this.node);
      this.addAttributes(property);
      this.customColor(
        this.node.strokes as MinimalStrokesTrait,
        isOutline ? "outline" : "border",
      );
    }
    return this;
  }
  position(): this {
    const { node } = this;
    if (commonIsAbsolutePosition(node)) {
      const { x, y } = getCommonPositionValue(node, this.settings);
      const parsedX = numberToFixedString(x);
      const parsedY = numberToFixedString(y);
      if (parsedX === "0") {
        this.addAttributes(`left-0`);
      } else {
        this.addAttributes(`left-[${parsedX}px]`);
      }
      if (parsedY === "0") {
        this.addAttributes(`top-0`);
      } else {
        this.addAttributes(`top-[${parsedY}px]`);
      }
      this.addAttributes(`absolute`);
    } else if (node.type === "GROUP" || (node as any).isRelative) {
      this.addAttributes("relative");
    }
    return this;
  }
  customColor(paint: ReadonlyArray<Paint>, kind: TailwindColorType): this {
    if (this.visible) {
      let gradient = "";
      if (kind === "bg") {
        gradient = tailwindGradientFromFills(paint);
        const blendModeClass = tailwindBackgroundBlendMode(paint);
        if (blendModeClass) {
          this.addAttributes(blendModeClass);
        }
      }
      if (gradient) {
        this.addAttributes(gradient);
      } else {
        this.addAttributes(tailwindColorFromFills(paint, kind));
      }
    }
    return this;
  }
  shadow(): this {
    this.addAttributes(...tailwindShadow(this.node as BlendMixin));
    return this;
  }
  size(): this {
    const { node, settings } = this;
    const { width, height, constraints } = tailwindSizePartial(node, settings);
    if (node.type === "TEXT") {
      switch (node.textAutoResize) {
        case "WIDTH_AND_HEIGHT":
          break;
        case "HEIGHT":
          this.addAttributes(width);
          break;
        case "NONE":
        case "TRUNCATE":
          this.addAttributes(width, height);
          break;
      }
    } else {
      this.addAttributes(width, height);
    }
    if (constraints) {
      this.addAttributes(constraints);
    }
    return this;
  }
  autoLayoutPadding(): this {
    if ("paddingLeft" in this.node) {
      this.addAttributes(...tailwindPadding(this.node));
    }
    return this;
  }
  blur() {
    const { node } = this;
    if ("effects" in node && node.effects.length > 0) {
      const blur = node.effects.find(
        (e) => e.type === "LAYER_BLUR" && e.visible,
      );
      if (blur) {
        const blurValue = pxToBlur(blur.radius / 2);
        if (blurValue) {
          this.addAttributes(
            blurValue === "blur" ? "blur" : `blur-${blurValue}`,
          );
        }
      }
      const backgroundBlur = node.effects.find(
        (e) => e.type === "BACKGROUND_BLUR" && e.visible,
      );
      if (backgroundBlur) {
        const backgroundBlurValue = pxToBlur(backgroundBlur.radius / 2);
        if (backgroundBlurValue) {
          this.addAttributes(
            `backdrop-blur${
              backgroundBlurValue ? `-${backgroundBlurValue}` : ""
            }`,
          );
        }
      }
    }
  }
  addData(label: string, value?: string): this {
    const attribute = formatDataAttribute(label, value);
    this.data.push(attribute);
    return this;
  }
  build(additionalAttr = ""): string {
    if (additionalAttr) {
      this.addAttributes(additionalAttr);
    }
    // if (this.name !== "") {
    //   this.prependAttributes(stringToClassName(this.name));
    // }
    if (this.name) {
      this.addData("layer", this.name.trim());
    }
    if ("componentProperties" in this.node && this.node.componentProperties) {
      Object.entries(this.node.componentProperties)
        ?.map((prop) => {
          if (prop[1].type === "VARIANT" || prop[1].type === "BOOLEAN") {
            const cleanName = prop[0]
              .split("#")[0]
              .replace(/\s+/g, "-")
              .toLowerCase();
            return formatDataAttribute(cleanName, String(prop[1].value));
          }
          return "";
        })
        .filter(Boolean)
        .sort()
        .forEach((d) => this.data.push(d));
    }
    const classLabel = getClassLabel(this.isJSX);
    const classNames =
      this.attributes.length > 0
        ? ` ${classLabel}="${this.attributes.filter(Boolean).join(" ")}"`
        : "";
    const styles = this.style.length > 0 ? ` style="${this.style}"` : "";
    const dataAttributes = this.data.join("");
    return `${dataAttributes}${classNames}${styles}`;
  }
  reset(): void {
    this.attributes = [];
    this.data = [];
    this.style = "";
  }
}
</file>

<file path="packages/plugin-ui/src/components/CodePanel.tsx">
import {
  Framework,
  LocalCodegenPreferenceOptions,
  PluginSettings,
  SelectPreferenceOptions,
} from "types";
import { useMemo, useState } from "react";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { coldarkDark as theme } from "react-syntax-highlighter/dist/esm/styles/prism";
import { CopyButton } from "./CopyButton";
import EmptyState from "./EmptyState";
import SettingsGroup from "./SettingsGroup";
import FrameworkTabs from "./FrameworkTabs";
import { TailwindSettings } from "./TailwindSettings";
interface CodePanelProps {
  code: string;
  selectedFramework: Framework;
  settings: PluginSettings | null;
  preferenceOptions: LocalCodegenPreferenceOptions[];
  selectPreferenceOptions: SelectPreferenceOptions[];
  onPreferenceChanged: (
    key: keyof PluginSettings,
    value: boolean | string | number,
  ) => void;
}
const CodePanel = (props: CodePanelProps) => {
  const [syntaxHovered, setSyntaxHovered] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);
  const initialLinesToShow = 25;
  const {
    code,
    preferenceOptions,
    selectPreferenceOptions,
    selectedFramework,
    settings,
    onPreferenceChanged,
  } = props;
  const isCodeEmpty = code === "";
  // Helper function to add the prefix before every class (or className) in the code.
  // It finds every occurrence of class="..." or className="..." and, for each class,
  // prepends the custom prefix.
  const applyPrefixToClasses = (
    codeString: string,
    prefix: string | undefined,
  ) => {
    if (!prefix) {
      return codeString;
    }
    return codeString.replace(
      /(class(?:Name)?)="([^"]*)"/g,
      (match, attr, classes) => {
        const prefixedClasses = classes
          .split(/\s+/)
          .filter(Boolean)
          .map((cls: string) => prefix + cls)
          .join(" ");
        return `${attr}="${prefixedClasses}"`;
      },
    );
  };
  const truncateCode = (codeString: string, lines: number) => {
    const codeLines = codeString.split("\n");
    if (codeLines.length <= lines) {
      return codeString;
    }
    return codeLines.slice(0, lines).join("\n") + "\n...";
  };
  const prefixedCode =
    selectedFramework === "Tailwind" &&
    settings?.customTailwindPrefix?.trim() !== ""
      ? applyPrefixToClasses(code, settings?.customTailwindPrefix)
      : code;
  // Memoize the line count calculation to improve performance for large code blocks
  const lineCount = useMemo(
    () => prefixedCode.split("\n").length,
    [prefixedCode],
  );
  const shouldTruncate = !isExpanded && lineCount > initialLinesToShow;
  const displayedCode = shouldTruncate
    ? truncateCode(prefixedCode, initialLinesToShow)
    : prefixedCode;
  const showMoreButton = lineCount > initialLinesToShow;
  const handleButtonHover = () => setSyntaxHovered(true);
  const handleButtonLeave = () => setSyntaxHovered(false);
  const {
    essentialPreferences,
    stylingPreferences,
    selectableSettingsFiltered,
  } = useMemo(() => {
    const frameworkPreferences = preferenceOptions.filter((preference) =>
      preference.includedLanguages?.includes(selectedFramework),
    );
    const essentialPropertyNames = ["jsx"];
    const stylingPropertyNames = [
      "useTailwind4",
      "roundTailwindValues",
      "roundTailwindColors",
      "useColorVariables",
      "showLayerNames",
      "embedImages",
      "embedVectors",
    ];
    return {
      essentialPreferences: frameworkPreferences.filter((p) =>
        essentialPropertyNames.includes(p.propertyName),
      ),
      stylingPreferences: frameworkPreferences.filter((p) =>
        stylingPropertyNames.includes(p.propertyName),
      ),
      selectableSettingsFiltered: selectPreferenceOptions.filter((p) =>
        p.includedLanguages?.includes(selectedFramework),
      ),
    };
  }, [preferenceOptions, selectPreferenceOptions, selectedFramework]);
  return (
    <div className="w-full flex flex-col gap-2 mt-2">
      <div className="flex items-center justify-between w-full">
        <p className="text-lg font-medium text-center dark:text-white rounded-lg">
          Code
        </p>
        {!isCodeEmpty && (
          <CopyButton
            value={prefixedCode}
            onMouseEnter={handleButtonHover}
            onMouseLeave={handleButtonLeave}
          />
        )}
      </div>
      {!isCodeEmpty && (
        <div className="flex flex-col p-3 bg-card border rounded-lg text-sm">
          {}
          <SettingsGroup
            title=""
            settings={essentialPreferences}
            alwaysExpanded={true}
            selectedSettings={settings}
            onPreferenceChanged={onPreferenceChanged}
          />
          {/* Framework-specific options */}
          {selectableSettingsFiltered.length > 0 && (
            <div className="mt-1 mb-2 last:mb-0">
              <p className="text-xs font-medium text-gray-700 dark:text-gray-300">
                {selectedFramework} Options
              </p>
              {selectableSettingsFiltered.map((preference) => {
                return (
                  <FrameworkTabs
                    options={preference.options}
                    selectedValue={
                      (settings?.[preference.propertyName] ??
                        preference.options.find((option) => option.isDefault)
                          ?.value ??
                        "") as string
                    }
                    onChange={(value) => {
                      onPreferenceChanged(preference.propertyName, value);
                    }}
                  />
                );
              })}
            </div>
          )}
          {/* Styling preferences with custom prefix for Tailwind */}
          {(stylingPreferences.length > 0 ||
            selectedFramework === "Tailwind") && (
            <SettingsGroup
              title="Styling Options"
              settings={stylingPreferences}
              selectedSettings={settings}
              onPreferenceChanged={onPreferenceChanged}
            >
              {selectedFramework === "Tailwind" && (
                <TailwindSettings
                  settings={settings}
                  onPreferenceChanged={onPreferenceChanged}
                />
              )}
            </SettingsGroup>
          )}
        </div>
      )}
      <div
        className={`rounded-lg ring-green-600 transition-all duration-200 overflow-clip ${
          syntaxHovered ? "ring-2" : "ring-0"
        }`}
      >
        {isCodeEmpty ? (
          <EmptyState />
        ) : (
          <>
            <SyntaxHighlighter
              language={
                selectedFramework === "HTML" &&
                settings?.htmlGenerationMode === "styled-components"
                  ? "jsx"
                  : selectedFramework === "Flutter"
                    ? "dart"
                    : selectedFramework === "SwiftUI"
                      ? "swift"
                      : "html"
              }
              style={theme}
              customStyle={{
                fontSize: 12,
                borderRadius: 8,
                marginTop: 0,
                marginBottom: 0,
                backgroundColor: syntaxHovered ? "#1E2B1A" : "#1B1B1B",
                transitionProperty: "all",
                transitionTimingFunction: "ease",
                transitionDuration: "0.2s",
              }}
            >
              {displayedCode}
            </SyntaxHighlighter>
            {showMoreButton && (
              <div className="flex justify-center dark:bg-[#1B1B1B] border-t dark:border-gray-700">
                <button
                  onClick={() => setIsExpanded(!isExpanded)}
                  className="text-xs w-full flex justify-center py-3 text-blue-500 hover:text-blue-400 transition-colors"
                  aria-label="Show more code. This could be slow or freeze Figma for a few seconds."
                  title="Show more code. This could be slow or freeze Figma for a few seconds."
                >
                  {isExpanded ? "Show Less" : "Show More"}
                </button>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
};
export default CodePanel;
</file>

<file path="packages/backend/src/html/htmlDefaultBuilder.ts">
import { formatWithJSX } from "../common/parseJSX";
import { htmlShadow } from "./builderImpl/htmlShadow";
import {
  htmlVisibility,
  htmlRotation,
  htmlOpacity,
  htmlBlendMode,
} from "./builderImpl/htmlBlend";
import {
  buildBackgroundValues,
  htmlColorFromFills,
} from "./builderImpl/htmlColor";
import { htmlPadding } from "./builderImpl/htmlPadding";
import { htmlSizePartial } from "./builderImpl/htmlSize";
import { htmlBorderRadius } from "./builderImpl/htmlBorderRadius";
import {
  commonIsAbsolutePosition,
  getCommonPositionValue,
} from "../common/commonPosition";
import {
  numberToFixedString,
  stringToClassName,
} from "../common/numToAutoFixed";
import { commonStroke } from "../common/commonStroke";
import {
  formatClassAttribute,
  formatDataAttribute,
  formatStyleAttribute,
} from "../common/commonFormatAttributes";
import { HTMLSettings } from "types";
import {
  cssCollection,
  generateUniqueClassName,
  stylesToCSS,
} from "./htmlMain";
export class HtmlDefaultBuilder {
  styles: Array<string>;
  data: Array<string>;
  node: SceneNode;
  settings: HTMLSettings;
  cssClassName: string | null = null;
  get name() {
    if (this.settings.htmlGenerationMode === "styled-components") {
      return this.settings.showLayerNames
        ? (this.node as any).uniqueName || this.node.name
        : "";
    }
    return this.settings.showLayerNames ? this.node.name : "";
  }
  get visible() {
    return this.node.visible;
  }
  get isJSX() {
    return this.settings.htmlGenerationMode === "jsx";
  }
  get exportCSS() {
    return this.settings.htmlGenerationMode === "svelte";
  }
  get useStyledComponents() {
    return this.settings.htmlGenerationMode === "styled-components";
  }
  get useInlineStyles() {
    return (
      this.settings.htmlGenerationMode === "html" ||
      this.settings.htmlGenerationMode === "jsx"
    );
  }
  get htmlElement(): string {
    if (this.node.type === "TEXT") return "p";
    return "div";
  }
  constructor(node: SceneNode, settings: HTMLSettings) {
    this.node = node;
    this.settings = settings;
    this.styles = [];
    this.data = [];
    if (
      this.settings.htmlGenerationMode === "svelte" ||
      this.settings.htmlGenerationMode === "styled-components"
    ) {
      let baseClassName =
        (this.node as any).uniqueName ||
        this.node.name ||
        this.node.type.toLowerCase();
      baseClassName = baseClassName
        .replace(/[^a-zA-Z0-9\s_-]/g, "")
        .replace(/\s+/g, "-")
        .toLowerCase();
      // Make sure it's valid
      if (!/^[a-z]/i.test(baseClassName)) {
        baseClassName = `${this.node.type.toLowerCase()}-${baseClassName}`;
      }
      // Generate unique class name with simple counter suffix
      this.cssClassName = generateUniqueClassName(baseClassName);
    }
  }
  commonPositionStyles(): this {
    this.size();
    this.autoLayoutPadding();
    this.position();
    this.blend();
    return this;
  }
  commonShapeStyles(): this {
    if ("fills" in this.node) {
      this.applyFillsToStyle(
        this.node.fills,
        this.node.type === "TEXT" ? "text" : "background",
      );
    }
    this.shadow();
    this.border(this.settings);
    this.blur();
    return this;
  }
  addStyles = (...newStyles: string[]) => {
    this.styles.push(...newStyles.filter((style) => style));
  };
  blend(): this {
    const { node, isJSX } = this;
    this.addStyles(
      htmlVisibility(node, isJSX),
      ...htmlRotation(node as LayoutMixin, isJSX),
      htmlOpacity(node as MinimalBlendMixin, isJSX),
      htmlBlendMode(node as MinimalBlendMixin, isJSX),
    );
    return this;
  }
  border(settings: HTMLSettings): this {
    const { node } = this;
    this.addStyles(...htmlBorderRadius(node, this.isJSX));
    const commonBorder = commonStroke(node);
    if (!commonBorder) {
      return this;
    }
    const strokes = ("strokes" in node && node.strokes) || undefined;
    const color = htmlColorFromFills(strokes as any);
    if (!color) {
      return this;
    }
    const borderStyle =
      "dashPattern" in node && node.dashPattern.length > 0 ? "dotted" : "solid";
    const strokeAlign = "strokeAlign" in node ? node.strokeAlign : "INSIDE";
    const consolidateBorders = (border: number): string =>
      [`${numberToFixedString(border)}px`, color, borderStyle]
        .filter((d) => d)
        .join(" ");
    if ("all" in commonBorder) {
      if (commonBorder.all === 0) {
        return this;
      }
      const weight = commonBorder.all;
      if (
        strokeAlign === "CENTER" ||
        strokeAlign === "OUTSIDE" ||
        node.type === "FRAME" ||
        node.type === "INSTANCE" ||
        node.type === "COMPONENT"
      ) {
        this.addStyles(
          formatWithJSX("outline", this.isJSX, consolidateBorders(weight)),
        );
        if (strokeAlign === "CENTER") {
          this.addStyles(
            formatWithJSX(
              "outline-offset",
              this.isJSX,
              `${numberToFixedString(-weight / 2)}px`,
            ),
          );
        } else if (strokeAlign === "INSIDE") {
          this.addStyles(
            formatWithJSX(
              "outline-offset",
              this.isJSX,
              `${numberToFixedString(-weight)}px`,
            ),
          );
        }
      } else {
        this.addStyles(
          formatWithJSX("border", this.isJSX, consolidateBorders(weight)),
        );
      }
    } else {
      if (commonBorder.left !== 0) {
        this.addStyles(
          formatWithJSX(
            "border-left",
            this.isJSX,
            consolidateBorders(commonBorder.left),
          ),
        );
      }
      if (commonBorder.top !== 0) {
        this.addStyles(
          formatWithJSX(
            "border-top",
            this.isJSX,
            consolidateBorders(commonBorder.top),
          ),
        );
      }
      if (commonBorder.right !== 0) {
        this.addStyles(
          formatWithJSX(
            "border-right",
            this.isJSX,
            consolidateBorders(commonBorder.right),
          ),
        );
      }
      if (commonBorder.bottom !== 0) {
        this.addStyles(
          formatWithJSX(
            "border-bottom",
            this.isJSX,
            consolidateBorders(commonBorder.bottom),
          ),
        );
      }
    }
    return this;
  }
  position(): this {
    const { node, isJSX } = this;
    const isAbsolutePosition = commonIsAbsolutePosition(node);
    if (isAbsolutePosition) {
      const { x, y } = getCommonPositionValue(node, this.settings);
      this.addStyles(
        formatWithJSX("left", isJSX, x),
        formatWithJSX("top", isJSX, y),
        formatWithJSX("position", isJSX, "absolute"),
      );
    } else {
      if (node.type === "GROUP" || (node as any).isRelative) {
        this.addStyles(formatWithJSX("position", isJSX, "relative"));
      }
    }
    return this;
  }
  applyFillsToStyle(
    paintArray: ReadonlyArray<Paint> | PluginAPI["mixed"],
    property: "text" | "background",
  ): this {
    if (property === "text") {
      this.addStyles(
        formatWithJSX(
          "text",
          this.isJSX,
          htmlColorFromFills(paintArray as any),
        ),
      );
      return this;
    }
    const backgroundValues = buildBackgroundValues(paintArray as any);
    if (backgroundValues) {
      this.addStyles(formatWithJSX("background", this.isJSX, backgroundValues));
      if (paintArray !== figma.mixed) {
        const blendModes = this.buildBackgroundBlendModes(paintArray);
        if (blendModes) {
          this.addStyles(
            formatWithJSX("background-blend-mode", this.isJSX, blendModes),
          );
        }
      }
    }
    return this;
  }
  buildBackgroundBlendModes(paintArray: ReadonlyArray<Paint>): string {
    if (
      paintArray.length === 0 ||
      paintArray.every(
        (d) => d.blendMode === "NORMAL" || d.blendMode === "PASS_THROUGH",
      )
    ) {
      return "";
    }
    // Reverse the array to match the background order
    const blendModes = [...paintArray].reverse().map((paint) => {
      if (paint.blendMode === "PASS_THROUGH") {
        return "normal";
      }
      return paint.blendMode?.toLowerCase();
    });
    return blendModes.join(", ");
  }
  shadow(): this {
    const { node, isJSX } = this;
    if ("effects" in node) {
      const shadow = htmlShadow(node);
      if (shadow) {
        this.addStyles(formatWithJSX("box-shadow", isJSX, htmlShadow(node)));
      }
    }
    return this;
  }
  size(): this {
    const { node, settings } = this;
    const { width, height, constraints } = htmlSizePartial(
      node,
      settings.htmlGenerationMode === "jsx",
    );
    if (node.type === "TEXT") {
      switch (node.textAutoResize) {
        case "WIDTH_AND_HEIGHT":
          break;
        case "HEIGHT":
          this.addStyles(width);
          break;
        case "NONE":
        case "TRUNCATE":
          this.addStyles(width, height);
          break;
      }
    } else {
      this.addStyles(width, height);
    }
    if (constraints.length > 0) {
      this.addStyles(...constraints);
    }
    return this;
  }
  autoLayoutPadding(): this {
    const { node, isJSX } = this;
    if ("paddingLeft" in node) {
      this.addStyles(...htmlPadding(node, isJSX));
    }
    return this;
  }
  blur() {
    const { node } = this;
    if ("effects" in node && node.effects.length > 0) {
      const blur = node.effects.find(
        (e) => e.type === "LAYER_BLUR" && e.visible,
      );
      if (blur) {
        this.addStyles(
          formatWithJSX(
            "filter",
            this.isJSX,
            `blur(${numberToFixedString(blur.radius / 2)}px)`,
          ),
        );
      }
      const backgroundBlur = node.effects.find(
        (e) => e.type === "BACKGROUND_BLUR" && e.visible,
      );
      if (backgroundBlur) {
        this.addStyles(
          formatWithJSX(
            "backdrop-filter",
            this.isJSX,
            `blur(${numberToFixedString(backgroundBlur.radius / 2)}px)`,
          ),
        );
      }
    }
  }
  addData(label: string, value?: string): this {
    const attribute = formatDataAttribute(label, value);
    this.data.push(attribute);
    return this;
  }
  build(additionalStyle: Array<string> = []): string {
    this.addStyles(...additionalStyle);
    const mode = this.settings.htmlGenerationMode || "html";
    if (
      mode === "styled-components" &&
      !this.data.length &&
      this.styles.length > 0 &&
      this.cssClassName
    ) {
      this.storeStyles();
      return ""; // Return empty string as we're using the component directly
    }
    let classNames: string[] = [];
    if (this.name) {
      this.addData("layer", this.name.trim());
    }
    if ("componentProperties" in this.node && this.node.componentProperties) {
      Object.entries(this.node.componentProperties)
        ?.map((prop) => {
          if (prop[1].type === "VARIANT" || prop[1].type === "BOOLEAN") {
            const cleanName = prop[0]
              .split("#")[0]
              .replace(/\s+/g, "-")
              .toLowerCase();
            return formatDataAttribute(cleanName, String(prop[1].value));
          }
          return "";
        })
        .filter(Boolean)
        .sort()
        .forEach((d) => this.data.push(d));
    }
    // For Svelte mode, we use classes
    if (mode === "svelte" && this.styles.length > 0 && this.cssClassName) {
      classNames.push(this.cssClassName);
      this.storeStyles();
      this.styles = [];
    }
    else if (
      mode === "styled-components" &&
      this.styles.length > 0 &&
      this.cssClassName
    ) {
      classNames.push(this.cssClassName);
      this.storeStyles();
    }
    const dataAttributes = this.data.join("");
    // Class attributes
    const classAttribute =
      mode === "styled-components"
        ? formatClassAttribute(
            classNames.filter((c) => c !== this.cssClassName),
            this.isJSX,
          )
        : formatClassAttribute(classNames, this.isJSX);
    const styleAttribute = formatStyleAttribute(this.styles, this.isJSX);
    return `${dataAttributes}${classAttribute}${styleAttribute}`;
  }
  private storeStyles(): void {
    if (!this.cssClassName || this.styles.length === 0) return;
    const cssStyles = stylesToCSS(this.styles, this.isJSX);
    let element = this.node.type === "TEXT" ? "p" : "div";
    if ((this.node as any).name?.toLowerCase().includes("button")) {
      element = "button";
    } else if (
      (this.node as any).name?.toLowerCase().includes("img") ||
      (this.node as any).name?.toLowerCase().includes("image")
    ) {
      element = "img";
    }
    cssCollection[this.cssClassName] = {
      styles: cssStyles,
      nodeName:
        (this.node as any).uniqueName ||
        this.node.name?.replace(/[^a-zA-Z0-9]/g, "") ||
        undefined,
      nodeType: this.node.type,
      element: element,
    };
  }
}
</file>

<file path="packages/backend/src/code.ts">
import {
  retrieveGenericLinearGradients,
  retrieveGenericSolidUIColors,
} from "./common/retrieveUI/retrieveColors";
import {
  addWarning,
  clearWarnings,
  warnings,
} from "./common/commonConversionWarnings";
import { postConversionComplete, postEmptyMessage } from "./messaging";
import { PluginSettings } from "types";
import { convertToCode } from "./common/retrieveUI/convertToCode";
import { generateHTMLPreview } from "./html/htmlMain";
import { oldConvertNodesToAltNodes } from "./altNodes/oldAltConversion";
import {
  getNodeByIdAsyncCalls,
  getNodeByIdAsyncTime,
  getStyledTextSegmentsCalls,
  getStyledTextSegmentsTime,
  nodesToJSON,
  processColorVariablesCalls,
  processColorVariablesTime,
  resetPerformanceCounters,
} from "./altNodes/jsonNodeConversion";
export const run = async (settings: PluginSettings) => {
  resetPerformanceCounters();
  clearWarnings();
  const { framework, useOldPluginVersion2025 } = settings;
  const selection = figma.currentPage.selection;
  if (selection.length === 0) {
    postEmptyMessage();
    return;
  }
  const nodeToJSONStart = Date.now();
  let convertedSelection: any;
  if (useOldPluginVersion2025) {
    convertedSelection = oldConvertNodesToAltNodes(selection, null);
    console.log("convertedSelection", convertedSelection);
  } else {
    convertedSelection = await nodesToJSON(selection, settings);
    console.log(`[benchmark] nodesToJSON: ${Date.now() - nodeToJSONStart}ms`);
    console.log("nodeJson", convertedSelection);
  }
  console.log("[debug] convertedSelection", { ...convertedSelection[0] });
  if (convertedSelection.length === 0) {
    postEmptyMessage();
    return;
  }
  const convertToCodeStart = Date.now();
  const code = await convertToCode(convertedSelection, settings);
  console.log(
    `[benchmark] convertToCode: ${Date.now() - convertToCodeStart}ms`,
  );
  const generatePreviewStart = Date.now();
  const htmlPreview = await generateHTMLPreview(convertedSelection, settings);
  console.log(
    `[benchmark] generateHTMLPreview: ${Date.now() - generatePreviewStart}ms`,
  );
  const colorPanelStart = Date.now();
  const colors = await retrieveGenericSolidUIColors(framework);
  const gradients = await retrieveGenericLinearGradients(framework);
  console.log(
    `[benchmark] color and gradient panel: ${Date.now() - colorPanelStart}ms`,
  );
  console.log(
    `[benchmark] total generation time: ${Date.now() - nodeToJSONStart}ms`,
  );
  console.log(
    `[benchmark] getNodeByIdAsync: ${getNodeByIdAsyncTime}ms (${getNodeByIdAsyncCalls} calls, avg: ${(getNodeByIdAsyncTime / getNodeByIdAsyncCalls || 1).toFixed(2)}ms)`,
  );
  console.log(
    `[benchmark] getStyledTextSegments: ${getStyledTextSegmentsTime}ms (${getStyledTextSegmentsCalls} calls, avg: ${
      getStyledTextSegmentsCalls > 0
        ? (getStyledTextSegmentsTime / getStyledTextSegmentsCalls).toFixed(2)
        : 0
    }ms)`,
  );
  console.log(
    `[benchmark] processColorVariables: ${processColorVariablesTime}ms (${processColorVariablesCalls} calls, avg: ${
      processColorVariablesCalls > 0
        ? (processColorVariablesTime / processColorVariablesCalls).toFixed(2)
        : 0
    }ms)`,
  );
  postConversionComplete({
    code,
    htmlPreview,
    colors,
    gradients,
    settings,
    warnings: [...warnings],
  });
};
</file>

</files>

<instruction>
## THIS TASK

debug:dev: [generateTailwindv4FromFigma][225] exception ReferenceError: figma is not defined
debug:dev:     at commonStroke (../../packages/backend/src/common/commonStroke.ts:26:35)
debug:dev:     at tailwindBorderWidth (../../packages/backend/src/tailwind/builderImpl/tailwindBorder.ts:60:36)
debug:dev:     at TailwindDefaultBuilder.border (../../packages/backend/src/tailwind/tailwindDefaultBuilder.ts:115:58)
debug:dev:     at TailwindDefaultBuilder.commonShapeStyles (../../packages/backend/src/tailwind/tailwindDefaultBuilder.ts:99:9)
debug:dev:     at tailwindContainer (../../packages/backend/src/tailwind/tailwindMain.ts:240:5)
debug:dev:     at tailwindFrame (../../packages/backend/src/tailwind/tailwindMain.ts:217:23)
debug:dev:     at async tailwindWidgetGenerator (../../packages/backend/src/tailwind/tailwindMain.ts:49:16)
debug:dev:     at async tailwindFrame (../../packages/backend/src/tailwind/tailwindMain.ts:202:22)
debug:dev:     at async tailwindWidgetGenerator (../../packages/backend/src/tailwind/tailwindMain.ts:49:16)
debug:dev:     at async tailwindFrame (../../packages/backend/src/tailwind/tailwindMain.ts:202:22)
debug:dev:     at async tailwindWidgetGenerator (../../packages/backend/src/tailwind/tailwindMain.ts:49:16)
debug:dev:     at async tailwindFrame (../../packages/backend/src/tailwind/tailwindMain.ts:202:22)
debug:dev:     at async tailwindWidgetGenerator (../../packages/backend/src/tailwind/tailwindMain.ts:49:16)
debug:dev:     at async tailwindFrame (../../packages/backend/src/tailwind/tailwindMain.ts:202:22)
debug:dev:     at async tailwindWidgetGenerator (../../packages/backend/src/tailwind/tailwindMain.ts:49:16)
debug:dev:     at async tailwindMain (../../packages/backend/src/tailwind/tailwindMain.ts:28:15)
debug:dev:     at async generateTailwindv4FromFigma (../../packages/backend/src/api/tailwindv4Api.ts:224:21)
debug:dev:     at async POST (app/api/generate-tailwind/route.ts:19:17)
debug:dev:   24 |       bottom: node.strokeBottomWeight / divideBy,
debug:dev:   25 |     };
debug:dev: > 26 |   } else if (node.strokeWeight !== figma.mixed && node.strokeWeight !== 0) {
debug:dev:      |                                   ^
debug:dev:   27 |     return { all: node.strokeWeight / divideBy };
debug:dev:   28 |   }

packages/FigmaToCode/apps/debug/tsconfig.json

"typeRoots": [
      "node_modules/@types",
      "node_modules/@figma"
    ],

    typeroots was added but doesn't seem to make a difference what else is needed? 

## END THIS TASK

</instruction>
